use crate::core::formats::{
    Subtitle, SubtitleEntry, SubtitleFormat, SubtitleFormatType, SubtitleMetadata,
};
use crate::error::SubXError;
use crate::Result;
use std::time::Duration;

/// ASS/SSA 高級字幕格式解析（暫未實作）
pub struct AssFormat;

impl SubtitleFormat for AssFormat {
    fn parse(&self, content: &str) -> Result<Subtitle> {
        let mut entries = Vec::new();
        let mut in_events = false;
        let mut fields: Vec<&str> = Vec::new();
        for line in content.lines() {
            let l = line.trim_start();
            if l.eq_ignore_ascii_case("[events]") {
                in_events = true;
                continue;
            }
            if !in_events {
                continue;
            }
            if l.to_lowercase().starts_with("format:") {
                fields = l["Format:".len()..].split(',').map(|s| s.trim()).collect();
                continue;
            }
            if l.to_lowercase().starts_with("dialogue:") {
                let data = l["Dialogue:".len()..].trim();
                let parts: Vec<&str> = data.splitn(fields.len(), ',').collect();
                if parts.len() < fields.len() {
                    continue;
                }
                let start = parts[fields
                    .iter()
                    .position(|&f| f.eq_ignore_ascii_case("start"))
                    .unwrap()]
                .trim();
                let end = parts[fields
                    .iter()
                    .position(|&f| f.eq_ignore_ascii_case("end"))
                    .unwrap()]
                .trim();
                let text_index = fields
                    .iter()
                    .position(|&f| f.eq_ignore_ascii_case("text"))
                    .unwrap();
                let text = parts[text_index..].join(",").replace("\\N", "\n");
                let start_time = parse_ass_time(start)?;
                let end_time = parse_ass_time(end)?;
                entries.push(SubtitleEntry {
                    index: entries.len() + 1,
                    start_time,
                    end_time,
                    text,
                    styling: None,
                });
            }
        }
        Ok(Subtitle {
            entries,
            metadata: SubtitleMetadata {
                title: None,
                language: None,
                encoding: "utf-8".to_string(),
                frame_rate: None,
                original_format: SubtitleFormatType::Ass,
            },
            format: SubtitleFormatType::Ass,
        })
    }

    fn serialize(&self, subtitle: &Subtitle) -> Result<String> {
        let mut output = String::new();
        output.push_str("[Script Info]\n");
        output.push_str("; Script generated by SubX\n");
        output.push_str("ScriptType: v4.00+\n\n");
        output.push_str("[V4+ Styles]\n");
        output.push_str("Format: Name,Fontname,Fontsize,PrimaryColour,SecondaryColour,OutlineColour,BackColour,Bold,Italic,Underline,StrikeOut,ScaleX,ScaleY,Spacing,Angle,BorderStyle,Outline,Shadow,Alignment,MarginL,MarginR,MarginV,Encoding\n");
        output.push_str("Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,2,10,10,10,1\n\n");
        output.push_str("[Events]\n");
        output.push_str("Format: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text\n");
        for entry in &subtitle.entries {
            let text = entry.text.replace('\n', "\\N");
            let start = format_ass_time(entry.start_time);
            let end = format_ass_time(entry.end_time);
            output.push_str(&format!(
                "Dialogue: 0,{},{},Default,,0000,0000,0000,,{}\n",
                start, end, text
            ));
        }
        Ok(output)
    }

    fn detect(&self, content: &str) -> bool {
        content.contains("[Script Info]") || content.contains("Dialogue:")
    }

    fn format_name(&self) -> &'static str {
        "ASS"
    }

    fn file_extensions(&self) -> &'static [&'static str] {
        &["ass", "ssa"]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE_ASS: &str = "[Script Info]\nScriptType: v4.00+\n\n[V4+ Styles]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n\n[Events]\nFormat: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text\nDialogue: 0,0:00:01.00,0:00:02.50,Default,,0000,0000,0000,,Hello\\NASS\n";

    #[test]
    fn test_detect_ass() {
        let fmt = AssFormat;
        assert!(fmt.detect(SAMPLE_ASS));
        assert!(!fmt.detect("Not ASS content"));
    }

    #[test]
    fn test_parse_ass_and_serialize() {
        let fmt = AssFormat;
        let subtitle = fmt.parse(SAMPLE_ASS).expect("ASS parse failed");
        assert_eq!(subtitle.entries.len(), 1);
        assert_eq!(subtitle.entries[0].text, "Hello\nASS");
        let out = fmt.serialize(&subtitle).expect("ASS serialize failed");
        assert!(out.contains("Dialogue: 0,0:00:01.00,0:00:02.50"));
        assert!(out.contains("Hello\\NASS"));
    }
}

fn parse_ass_time(time: &str) -> Result<Duration> {
    let parts: Vec<&str> = time.split(&[':', '.'][..]).collect();
    if parts.len() != 4 {
        return Err(SubXError::subtitle_format(
            "ASS",
            format!("Invalid time format: {}", time),
        ));
    }
    let hours: u64 = parts[0]
        .parse()
        .map_err(|e: std::num::ParseIntError| SubXError::subtitle_format("ASS", e.to_string()))?;
    let minutes: u64 = parts[1]
        .parse()
        .map_err(|e: std::num::ParseIntError| SubXError::subtitle_format("ASS", e.to_string()))?;
    let seconds: u64 = parts[2]
        .parse()
        .map_err(|e: std::num::ParseIntError| SubXError::subtitle_format("ASS", e.to_string()))?;
    let centi: u64 = parts[3]
        .parse()
        .map_err(|e: std::num::ParseIntError| SubXError::subtitle_format("ASS", e.to_string()))?;
    Ok(Duration::from_millis(
        hours * 3600 * 1000 + minutes * 60 * 1000 + seconds * 1000 + centi * 10,
    ))
}

fn format_ass_time(duration: Duration) -> String {
    let total_ms = duration.as_millis();
    let hours = total_ms / 3600000;
    let minutes = (total_ms % 3600000) / 60000;
    let seconds = (total_ms % 60000) / 1000;
    let centi = (total_ms % 1000) / 10;
    format!("{}:{:02}:{:02}.{:02}", hours, minutes, seconds, centi)
}
