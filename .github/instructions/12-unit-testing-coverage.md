# Product Backlog #12: å–®å…ƒæ¸¬è©¦èˆ‡ç¨‹å¼ç¢¼è¦†è“‹ç‡

## é ˜åŸŸç¯„åœ
å–®å…ƒæ¸¬è©¦å¯¦ä½œã€æ¨¡æ“¬æ¸¬è©¦ã€ç¨‹å¼ç¢¼è¦†è“‹ç‡åˆ†æã€æ¸¬è©¦åŸºç¤è¨­æ–½

## å®Œæˆé …ç›®

### 1. æ¸¬è©¦åŸºç¤è¨­æ–½å»ºç«‹
- [ ] è¨­å®šæ¸¬è©¦è¦†è“‹ç‡å·¥å…· (cargo-tarpaulin)
- [ ] æ–°å¢ mockall æ¡†æ¶ç”¨æ–¼æ¨¡æ“¬æ¸¬è©¦
- [ ] å»ºç«‹æ¸¬è©¦è³‡æ–™ç”¢ç”Ÿå™¨
- [ ] è¨­å®š CI/CD æ¸¬è©¦è¦†è“‹ç‡æª¢æŸ¥
- [ ] å»ºç«‹æ¸¬è©¦å·¥å…·è¼”åŠ©å‡½å¼

### 2. éŒ¯èª¤è™•ç†æ¨¡çµ„æ¸¬è©¦
- [ ] `SubXError` å„ç¨®éŒ¯èª¤é¡å‹å»ºç«‹æ¸¬è©¦
- [ ] éŒ¯èª¤è¨Šæ¯æ ¼å¼åŒ–æ¸¬è©¦
- [ ] éŒ¯èª¤é€€å‡ºç¢¼é©—è­‰
- [ ] éŒ¯èª¤éˆè¿½è¹¤æ¸¬è©¦
- [ ] ç”¨æˆ¶å‹å–„éŒ¯èª¤è¨Šæ¯æ¸¬è©¦

### 3. é…ç½®ç®¡ç†ç³»çµ±æ¸¬è©¦
- [ ] é…ç½®æª”æ¡ˆè®€å¯«åŠŸèƒ½æ¸¬è©¦
- [ ] ç’°å¢ƒè®Šæ•¸å„ªå…ˆæ¬Šæ¸¬è©¦
- [ ] é…ç½®é©—è­‰æ©Ÿåˆ¶æ¸¬è©¦
- [ ] é è¨­å€¼è¼‰å…¥æ¸¬è©¦
- [ ] é…ç½®åˆä½µé‚è¼¯æ¸¬è©¦
- [ ] è·¨å¹³å°è·¯å¾‘è™•ç†æ¸¬è©¦

### 4. å­—å¹•æ ¼å¼è§£æå¼•æ“æ¸¬è©¦
- [ ] SRT æ ¼å¼è§£æèˆ‡åºåˆ—åŒ–æ¸¬è©¦
- [ ] ASS æ ¼å¼è§£æèˆ‡åºåˆ—åŒ–æ¸¬è©¦
- [ ] VTT æ ¼å¼è§£æèˆ‡åºåˆ—åŒ–æ¸¬è©¦
- [ ] SUB æ ¼å¼è§£æèˆ‡åºåˆ—åŒ–æ¸¬è©¦
- [ ] æ ¼å¼è‡ªå‹•æª¢æ¸¬æ¸¬è©¦
- [ ] ç·¨ç¢¼æª¢æ¸¬èˆ‡è½‰æ›æ¸¬è©¦
- [ ] éŒ¯èª¤æ ¼å¼è™•ç†æ¸¬è©¦

### 5. AI æœå‹™æ•´åˆæ¸¬è©¦
- [ ] OpenAI å®¢æˆ¶ç«¯æ¨¡æ“¬æ¸¬è©¦
- [ ] é‡è©¦æ©Ÿåˆ¶æ¸¬è©¦
- [ ] å¿«å–ç³»çµ±æ¸¬è©¦
- [ ] Prompt å»ºæ§‹æ¸¬è©¦
- [ ] å›æ‡‰è§£ææ¸¬è©¦
- [ ] éŒ¯èª¤è™•ç†æ¸¬è©¦

### 6. æª”æ¡ˆåŒ¹é…å¼•æ“æ¸¬è©¦
- [ ] æª”æ¡ˆç™¼ç¾ç³»çµ±æ¸¬è©¦
- [ ] æª”ååˆ†æå™¨æ¸¬è©¦
- [ ] å…§å®¹æ¡æ¨£å™¨æ¸¬è©¦
- [ ] åŒ¹é…çµæœç”Ÿæˆæ¸¬è©¦
- [ ] Dry-run å¿«å–æ¸¬è©¦
- [ ] æª”æ¡ˆæ“ä½œå®‰å…¨æ€§æ¸¬è©¦

### 7. æ ¼å¼è½‰æ›ç³»çµ±æ¸¬è©¦
- [ ] æ ¼å¼é–“è½‰æ›é‚è¼¯æ¸¬è©¦
- [ ] æ¨£å¼ä¿ç•™æ©Ÿåˆ¶æ¸¬è©¦
- [ ] æ‰¹é‡è½‰æ›æ¸¬è©¦
- [ ] è½‰æ›å“è³ªé©—è­‰æ¸¬è©¦
- [ ] éŒ¯èª¤æ¢å¾©æ¸¬è©¦

### 8. éŸ³è¨Šè™•ç†èˆ‡åŒæ­¥æ¸¬è©¦
- [ ] éŸ³è¨Šè§£ç¢¼æ¸¬è©¦
- [ ] å°è©±æª¢æ¸¬ç®—æ³•æ¸¬è©¦
- [ ] äº¤å‰ç›¸é—œåˆ†ææ¸¬è©¦
- [ ] æ™‚é–“è»¸åŒæ­¥æ¸¬è©¦
- [ ] åç§»è¨ˆç®—æ¸¬è©¦

### 9. CLI ä»‹é¢æ¸¬è©¦
- [ ] å‘½ä»¤è§£ææ¸¬è©¦
- [ ] åƒæ•¸é©—è­‰æ¸¬è©¦
- [ ] éŒ¯èª¤è™•ç†æ¸¬è©¦
- [ ] å¹«åŠ©è³‡è¨Šæ¸¬è©¦
- [ ] ç”¨æˆ¶ä»‹é¢è¼¸å‡ºæ¸¬è©¦

### 10. è¦†è“‹ç‡ç›®æ¨™èˆ‡ç›£æ§
- [ ] é”æˆ 50% ä»¥ä¸Šæ•´é«”æ¸¬è©¦è¦†è“‹ç‡
- [ ] æ ¸å¿ƒæ¨¡çµ„é”æˆ 70% ä»¥ä¸Šè¦†è“‹ç‡
- [ ] å»ºç«‹è¦†è“‹ç‡ç›£æ§æ©Ÿåˆ¶
- [ ] è¨­å®šè¦†è“‹ç‡å›æ­¸æª¢æŸ¥

## æŠ€è¡“è¨­è¨ˆ

### æ¸¬è©¦åŸºç¤è¨­æ–½é…ç½®

**Cargo.toml æ¸¬è©¦ç›¸ä¾å¥—ä»¶æ›´æ–°ï¼š**
```toml
[dev-dependencies]
tokio-test = "0.4"
assert_cmd = "2.0"
predicates = "3.0"
tempfile = "3.8"
criterion = { version = "0.5", features = ["html_reports"] }
# æ–°å¢æ¸¬è©¦ç›¸ä¾å¥—ä»¶
mockall = "0.11"
serial_test = "3.0"
rstest = "0.18"
test-case = "3.0"
tarpaulin = "0.27"
wiremock = "0.5"
```

**æ¸¬è©¦è¦†è“‹ç‡å·¥å…·è¨­å®šï¼š**
```toml
# tarpaulin.toml
[tarpaulin]
out = ["Html", "Lcov"]
target-dir = "target/tarpaulin"
timeout = 120
fail-under = 50
ignore-panics = true
count = true
all-features = true
exclude = [
    "benches/*",
    "tests/*"
]
```

### éŒ¯èª¤è™•ç†æ¨¡çµ„æ¸¬è©¦å¯¦ä½œ
```rust
// src/error.rs (æ¸¬è©¦æ¨¡çµ„)
#[cfg(test)]
mod tests {
    use super::*;
    use std::io;

    #[test]
    fn test_config_error_creation() {
        let error = SubXError::config("æ¸¬è©¦é…ç½®éŒ¯èª¤");
        assert!(matches!(error, SubXError::Config { .. }));
        assert_eq!(error.to_string(), "é…ç½®éŒ¯èª¤: æ¸¬è©¦é…ç½®éŒ¯èª¤");
    }

    #[test]
    fn test_subtitle_format_error_creation() {
        let error = SubXError::subtitle_format("SRT", "ç„¡æ•ˆæ ¼å¼");
        assert!(matches!(error, SubXError::SubtitleFormat { .. }));
        assert!(error.to_string().contains("SRT"));
        assert!(error.to_string().contains("ç„¡æ•ˆæ ¼å¼"));
    }

    #[test]
    fn test_audio_processing_error_creation() {
        let error = SubXError::audio_processing("éŸ³è¨Šè§£ç¢¼å¤±æ•—");
        assert!(matches!(error, SubXError::AudioProcessing { .. }));
        assert_eq!(error.to_string(), "éŸ³è¨Šè™•ç†éŒ¯èª¤: éŸ³è¨Šè§£ç¢¼å¤±æ•—");
    }

    #[test]
    fn test_file_matching_error_creation() {
        let error = SubXError::file_matching("åŒ¹é…å¤±æ•—");
        assert!(matches!(error, SubXError::FileMatching { .. }));
        assert_eq!(error.to_string(), "æ–‡ä»¶åŒ¹é…éŒ¯èª¤: åŒ¹é…å¤±æ•—");
    }

    #[test]
    fn test_io_error_conversion() {
        let io_error = io::Error::new(io::ErrorKind::NotFound, "æª”æ¡ˆä¸å­˜åœ¨");
        let subx_error: SubXError = io_error.into();
        assert!(matches!(subx_error, SubXError::Io(_)));
    }

    #[test]
    fn test_exit_codes() {
        assert_eq!(SubXError::config("test").exit_code(), 2);
        assert_eq!(SubXError::subtitle_format("SRT", "test").exit_code(), 4);
        assert_eq!(SubXError::audio_processing("test").exit_code(), 5);
        assert_eq!(SubXError::file_matching("test").exit_code(), 6);
    }

    #[test]
    fn test_user_friendly_messages() {
        let config_error = SubXError::config("API é‡‘é‘°æœªè¨­å®š");
        let message = config_error.user_friendly_message();
        assert!(message.contains("é…ç½®éŒ¯èª¤"));
        assert!(message.contains("subx config --help"));

        let ai_error = SubXError::ai_service("ç¶²è·¯é€£æ¥å¤±æ•—");
        let message = ai_error.user_friendly_message();
        assert!(message.contains("AI æœå‹™éŒ¯èª¤"));
        assert!(message.contains("æª¢æŸ¥ç¶²è·¯é€£æ¥"));
    }
}
```

### é…ç½®ç®¡ç†ç³»çµ±æ¸¬è©¦å¯¦ä½œ
```rust
// src/config.rs (æ¸¬è©¦æ¨¡çµ„)
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::env;

    #[test]
    fn test_default_config_creation() {
        let config = Config::default();
        assert_eq!(config.ai.provider, "openai");
        assert_eq!(config.ai.model, "gpt-4o-mini");
        assert_eq!(config.formats.default_output, "srt");
        assert_eq!(config.general.default_confidence, 80);
    }

    #[test]
    fn test_config_serialization() {
        let config = Config::default();
        let toml_str = toml::to_string(&config).unwrap();
        assert!(toml_str.contains("[ai]"));
        assert!(toml_str.contains("[formats]"));
        assert!(toml_str.contains("[sync]"));
        assert!(toml_str.contains("[general]"));
    }

    #[test]
    fn test_config_deserialization() {
        let toml_content = r#"
[ai]
provider = "openai"
model = "gpt-4"
max_sample_length = 1500

[formats]
default_output = "vtt"
preserve_styling = false

[sync]
max_offset_seconds = 60.0

[general]
backup_enabled = true
default_confidence = 90
"#;
        let config: Config = toml::from_str(toml_content).unwrap();
        assert_eq!(config.ai.model, "gpt-4");
        assert_eq!(config.formats.default_output, "vtt");
        assert!(!config.formats.preserve_styling);
        assert_eq!(config.sync.max_offset_seconds, 60.0);
        assert!(config.general.backup_enabled);
    }

    #[test]
    fn test_env_var_override() {
        env::set_var("OPENAI_API_KEY", "test-key-123");
        env::set_var("SUBX_AI_MODEL", "gpt-3.5-turbo");

        let mut config = Config::default();
        config.apply_env_vars();

        assert_eq!(config.ai.api_key, Some("test-key-123".to_string()));
        assert_eq!(config.ai.model, "gpt-3.5-turbo");

        env::remove_var("OPENAI_API_KEY");
        env::remove_var("SUBX_AI_MODEL");
    }

    #[test]
    fn test_config_validation_missing_api_key() {
        env::remove_var("OPENAI_API_KEY");
        let config = Config::default();
        // API Key é©—è­‰æ‡‰è©²åœ¨ç‰¹å®šå‘½ä»¤åŸ·è¡Œæ™‚é€²è¡Œï¼Œä¸åœ¨è¼‰å…¥æ™‚
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_config_validation_invalid_provider() {
        let mut config = Config::default();
        config.ai.provider = "invalid-provider".to_string();
        assert!(config.validate().is_err());
    }

    #[test]
    fn test_config_file_save_and_load() {
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("config.toml");

        let original_config = Config::default();
        
        // æ¨¡æ“¬å„²å­˜é…ç½®æª”æ¡ˆ
        let toml_content = toml::to_string_pretty(&original_config).unwrap();
        std::fs::write(&config_path, toml_content).unwrap();

        // æ¸¬è©¦è¼‰å…¥
        let file_content = std::fs::read_to_string(&config_path).unwrap();
        let loaded_config: Config = toml::from_str(&file_content).unwrap();

        assert_eq!(original_config.ai.model, loaded_config.ai.model);
        assert_eq!(original_config.formats.default_output, loaded_config.formats.default_output);
    }

    #[test]
    fn test_config_merge() {
        let mut base_config = Config::default();
        let mut override_config = Config::default();
        override_config.ai.model = "gpt-4".to_string();
        override_config.general.backup_enabled = true;

        base_config.merge(override_config);

        assert_eq!(base_config.ai.model, "gpt-4");
        assert!(base_config.general.backup_enabled);
    }
}
```

### å­—å¹•æ ¼å¼è§£æå¼•æ“æ¸¬è©¦å¯¦ä½œ
```rust
// src/core/formats/srt.rs (æ“´å±•æ¸¬è©¦æ¨¡çµ„)
#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::formats::{SubtitleFormat, SubtitleFormatType};

    const SAMPLE_SRT: &str = "1\n00:00:01,000 --> 00:00:03,000\nHello, World!\n\n2\n00:00:05,000 --> 00:00:08,000\nThis is a test subtitle.\nå¤šè¡Œæ¸¬è©¦\n\n";

    #[test]
    fn test_srt_parsing_basic() {
        let format = SrtFormat;
        let subtitle = format.parse(SAMPLE_SRT).unwrap();

        assert_eq!(subtitle.entries.len(), 2);
        assert_eq!(subtitle.format, SubtitleFormatType::Srt);

        let first_entry = &subtitle.entries[0];
        assert_eq!(first_entry.index, 1);
        assert_eq!(first_entry.start_time, Duration::from_millis(1000));
        assert_eq!(first_entry.end_time, Duration::from_millis(3000));
        assert_eq!(first_entry.text, "Hello, World!");

        let second_entry = &subtitle.entries[1];
        assert_eq!(second_entry.index, 2);
        assert_eq!(second_entry.start_time, Duration::from_millis(5000));
        assert_eq!(second_entry.end_time, Duration::from_millis(8000));
        assert_eq!(second_entry.text, "This is a test subtitle.\nå¤šè¡Œæ¸¬è©¦");
    }

    #[test]
    fn test_srt_serialization() {
        let format = SrtFormat;
        let subtitle = format.parse(SAMPLE_SRT).unwrap();
        let serialized = format.serialize(&subtitle).unwrap();

        // é‡æ–°è§£æåºåˆ—åŒ–çµæœ
        let reparsed = format.parse(&serialized).unwrap();
        assert_eq!(subtitle.entries.len(), reparsed.entries.len());

        for (original, reparsed) in subtitle.entries.iter().zip(reparsed.entries.iter()) {
            assert_eq!(original.start_time, reparsed.start_time);
            assert_eq!(original.end_time, reparsed.end_time);
            assert_eq!(original.text, reparsed.text);
        }
    }

    #[test]
    fn test_srt_detection() {
        let format = SrtFormat;
        assert!(format.detect(SAMPLE_SRT));
        assert!(!format.detect("This is not SRT content"));
        assert!(!format.detect("WEBVTT\n\n00:00:01.000 --> 00:00:03.000\nHello"));
    }

    #[test]
    fn test_srt_invalid_format() {
        let format = SrtFormat;
        
        // æ¸¬è©¦ç„¡æ•ˆæ™‚é–“æ ¼å¼
        let invalid_time = "1\n00:00:01 --> 00:00:03\nText\n\n";
        assert!(format.parse(invalid_time).is_err());

        // æ¸¬è©¦ç„¡æ•ˆåºåˆ—è™Ÿ
        let invalid_index = "invalid\n00:00:01,000 --> 00:00:03,000\nText\n\n";
        assert!(format.parse(invalid_index).is_err());
    }

    #[test]
    fn test_srt_empty_content() {
        let format = SrtFormat;
        let subtitle = format.parse("").unwrap();
        assert_eq!(subtitle.entries.len(), 0);

        let subtitle = format.parse("\n\n\n").unwrap();
        assert_eq!(subtitle.entries.len(), 0);
    }

    #[test]
    fn test_srt_malformed_blocks() {
        let format = SrtFormat;
        
        // æ¸¬è©¦ç¼ºå°‘æ–‡å­—å…§å®¹çš„å¡Š
        let malformed = "1\n00:00:01,000 --> 00:00:03,000\n\n";
        let subtitle = format.parse(malformed).unwrap();
        assert_eq!(subtitle.entries.len(), 0); // æ‡‰è©²è·³éæ ¼å¼éŒ¯èª¤çš„å¡Š
    }

    #[test]
    fn test_time_parsing_edge_cases() {
        let format = SrtFormat;
        
        // æ¸¬è©¦é‚Šç•Œæ™‚é–“å€¼
        let edge_case = "1\n23:59:59,999 --> 23:59:59,999\nEnd of day\n\n";
        let subtitle = format.parse(edge_case).unwrap();
        assert_eq!(subtitle.entries.len(), 1);
        
        let entry = &subtitle.entries[0];
        let expected_duration = Duration::from_millis(23 * 3600000 + 59 * 60000 + 59 * 1000 + 999);
        assert_eq!(entry.start_time, expected_duration);
        assert_eq!(entry.end_time, expected_duration);
    }

    #[test]
    fn test_file_extensions() {
        let format = SrtFormat;
        assert_eq!(format.file_extensions(), &["srt"]);
    }

    #[test]
    fn test_format_name() {
        let format = SrtFormat;
        assert_eq!(format.format_name(), "SRT");
    }
}
```

### AI æœå‹™æ•´åˆæ¨¡æ“¬æ¸¬è©¦å¯¦ä½œ
```rust
// src/services/ai/openai.rs (æ¨¡æ“¬æ¸¬è©¦æ¨¡çµ„)
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::{predicate::*, mock};
    use wiremock::{MockServer, Mock, ResponseTemplate};
    use wiremock::matchers::{method, path, header};
    use serde_json::json;

    // å»ºç«‹ AI Provider çš„æ¨¡æ“¬ç‰ˆæœ¬
    mock! {
        AIClient {}

        #[async_trait]
        impl AIProvider for AIClient {
            async fn analyze_content(&self, request: AnalysisRequest) -> crate::Result<MatchResult>;
            async fn verify_match(&self, verification: VerificationRequest) -> crate::Result<ConfidenceScore>;
        }
    }

    #[tokio::test]
    async fn test_openai_client_creation() {
        let client = OpenAIClient::new(
            "test-api-key".to_string(),
            "gpt-4o-mini".to_string(),
        );
        assert_eq!(client.api_key, "test-api-key");
        assert_eq!(client.model, "gpt-4o-mini");
    }

    #[tokio::test]
    async fn test_chat_completion_success() {
        let mock_server = MockServer::start().await;
        
        Mock::given(method("POST"))
            .and(path("/chat/completions"))
            .and(header("authorization", "Bearer test-api-key"))
            .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                "choices": [{
                    "message": {
                        "content": "æ¸¬è©¦å›æ‡‰å…§å®¹"
                    }
                }]
            })))
            .mount(&mock_server)
            .await;

        let mut client = OpenAIClient::new(
            "test-api-key".to_string(),
            "gpt-4o-mini".to_string(),
        );
        client.base_url = mock_server.uri();

        let messages = vec![
            json!({"role": "user", "content": "æ¸¬è©¦è¨Šæ¯"})
        ];

        let response = client.chat_completion(messages).await.unwrap();
        assert_eq!(response, "æ¸¬è©¦å›æ‡‰å…§å®¹");
    }

    #[tokio::test]
    async fn test_chat_completion_error() {
        let mock_server = MockServer::start().await;
        
        Mock::given(method("POST"))
            .and(path("/chat/completions"))
            .respond_with(ResponseTemplate::new(400).set_body_json(json!({
                "error": {
                    "message": "Invalid API key"
                }
            })))
            .mount(&mock_server)
            .await;

        let mut client = OpenAIClient::new(
            "invalid-key".to_string(),
            "gpt-4o-mini".to_string(),
        );
        client.base_url = mock_server.uri();

        let messages = vec![
            json!({"role": "user", "content": "æ¸¬è©¦è¨Šæ¯"})
        ];

        let result = client.chat_completion(messages).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_analyze_content() {
        let mut mock_client = MockAIClient::new();
        
        let expected_request = AnalysisRequest {
            video_files: vec!["video1.mp4".to_string()],
            subtitle_files: vec!["subtitle1.srt".to_string()],
            content_samples: vec![],
        };

        let expected_result = MatchResult {
            matches: vec![FileMatch {
                video_file: "video1.mp4".to_string(),
                subtitle_file: "subtitle1.srt".to_string(),
                confidence: 0.95,
                match_factors: vec!["æª”åç›¸ä¼¼".to_string()],
            }],
            confidence: 0.95,
            reasoning: "æª”åæ¨¡å¼åŒ¹é…".to_string(),
        };

        mock_client
            .expect_analyze_content()
            .with(eq(expected_request))
            .times(1)
            .returning(move |_| Ok(expected_result.clone()));

        let request = AnalysisRequest {
            video_files: vec!["video1.mp4".to_string()],
            subtitle_files: vec!["subtitle1.srt".to_string()],
            content_samples: vec![],
        };

        let result = mock_client.analyze_content(request).await.unwrap();
        assert_eq!(result.matches.len(), 1);
        assert_eq!(result.confidence, 0.95);
    }

    #[test]
    fn test_prompt_building() {
        let client = OpenAIClient::new(
            "test-key".to_string(),
            "gpt-4o-mini".to_string(),
        );

        let request = AnalysisRequest {
            video_files: vec!["Season 1 Episode 1.mp4".to_string()],
            subtitle_files: vec!["S01E01.srt".to_string()],
            content_samples: vec![ContentSample {
                filename: "S01E01.srt".to_string(),
                content_preview: "Hello, world!".to_string(),
                file_size: 1024,
                language_hint: Some("en".to_string()),
            }],
        };

        let prompt = client.build_analysis_prompt(&request);
        assert!(prompt.contains("Season 1 Episode 1.mp4"));
        assert!(prompt.contains("S01E01.srt"));
        assert!(prompt.contains("Hello, world!"));
        assert!(prompt.contains("JSON"));
    }

    #[test]
    fn test_match_result_parsing() {
        let client = OpenAIClient::new(
            "test-key".to_string(),
            "gpt-4o-mini".to_string(),
        );

        let json_response = r#"
        {
            "matches": [
                {
                    "video_file": "video.mp4",
                    "subtitle_file": "subtitle.srt",
                    "confidence": 0.9,
                    "match_factors": ["æª”åç›¸ä¼¼", "å…§å®¹åŒ¹é…"]
                }
            ],
            "confidence": 0.9,
            "reasoning": "é«˜åº¦åŒ¹é…"
        }
        "#;

        let result = client.parse_match_result(json_response).unwrap();
        assert_eq!(result.matches.len(), 1);
        assert_eq!(result.confidence, 0.9);
        assert_eq!(result.reasoning, "é«˜åº¦åŒ¹é…");
        
        let file_match = &result.matches[0];
        assert_eq!(file_match.video_file, "video.mp4");
        assert_eq!(file_match.subtitle_file, "subtitle.srt");
        assert_eq!(file_match.confidence, 0.9);
        assert_eq!(file_match.match_factors.len(), 2);
    }
}
```

### æª”æ¡ˆåŒ¹é…å¼•æ“æ¸¬è©¦å¯¦ä½œ
```rust
// src/core/matcher/discovery.rs (æ¸¬è©¦æ¨¡çµ„)
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::fs;

    fn create_test_files(dir: &Path) -> std::io::Result<()> {
        fs::write(dir.join("video1.mp4"), b"")?;
        fs::write(dir.join("video2.mkv"), b"")?;
        fs::write(dir.join("video3.avi"), b"")?;
        fs::write(dir.join("subtitle1.srt"), b"")?;
        fs::write(dir.join("subtitle2.ass"), b"")?;
        fs::write(dir.join("subtitle3.vtt"), b"")?;
        fs::write(dir.join("document.txt"), b"")?; // éåª’é«”æª”æ¡ˆ
        fs::write(dir.join("image.jpg"), b"")?; // éåª’é«”æª”æ¡ˆ
        
        // å»ºç«‹å­ç›®éŒ„
        let subdir = dir.join("season1");
        fs::create_dir(&subdir)?;
        fs::write(subdir.join("episode1.mp4"), b"")?;
        fs::write(subdir.join("episode1.srt"), b"")?;
        
        Ok(())
    }

    #[test]
    fn test_file_discovery_non_recursive() {
        let temp_dir = TempDir::new().unwrap();
        create_test_files(temp_dir.path()).unwrap();

        let discovery = FileDiscovery::new();
        let files = discovery.scan_directory(temp_dir.path(), false).unwrap();

        let video_files: Vec<_> = files.iter()
            .filter(|f| matches!(f.file_type, MediaFileType::Video))
            .collect();
        let subtitle_files: Vec<_> = files.iter()
            .filter(|f| matches!(f.file_type, MediaFileType::Subtitle))
            .collect();

        assert_eq!(video_files.len(), 3); // mp4, mkv, avi
        assert_eq!(subtitle_files.len(), 3); // srt, ass, vtt
        
        // ç¢ºèªæ²’æœ‰åŒ…å«å­ç›®éŒ„çš„æª”æ¡ˆ
        assert!(!files.iter().any(|f| f.name.contains("episode")));
    }

    #[test]
    fn test_file_discovery_recursive() {
        let temp_dir = TempDir::new().unwrap();
        create_test_files(temp_dir.path()).unwrap();

        let discovery = FileDiscovery::new();
        let files = discovery.scan_directory(temp_dir.path(), true).unwrap();

        let video_files: Vec<_> = files.iter()
            .filter(|f| matches!(f.file_type, MediaFileType::Video))
            .collect();
        let subtitle_files: Vec<_> = files.iter()
            .filter(|f| matches!(f.file_type, MediaFileType::Subtitle))
            .collect();

        assert_eq!(video_files.len(), 4); // åŒ…å«å­ç›®éŒ„çš„ episode1.mp4
        assert_eq!(subtitle_files.len(), 4); // åŒ…å«å­ç›®éŒ„çš„ episode1.srt
        
        // ç¢ºèªåŒ…å«å­ç›®éŒ„çš„æª”æ¡ˆ
        assert!(files.iter().any(|f| f.name == "episode1"));
    }

    #[test]
    fn test_file_classification() {
        let temp_dir = TempDir::new().unwrap();
        let video_path = temp_dir.path().join("test.mp4");
        let subtitle_path = temp_dir.path().join("test.srt");
        let unknown_path = temp_dir.path().join("test.txt");

        fs::write(&video_path, b"").unwrap();
        fs::write(&subtitle_path, b"").unwrap();
        fs::write(&unknown_path, b"").unwrap();

        let discovery = FileDiscovery::new();

        let video_file = discovery.classify_file(&video_path).unwrap().unwrap();
        assert!(matches!(video_file.file_type, MediaFileType::Video));
        assert_eq!(video_file.name, "test");
        assert_eq!(video_file.extension, "mp4");

        let subtitle_file = discovery.classify_file(&subtitle_path).unwrap().unwrap();
        assert!(matches!(subtitle_file.file_type, MediaFileType::Subtitle));
        assert_eq!(subtitle_file.name, "test");
        assert_eq!(subtitle_file.extension, "srt");

        let unknown_file = discovery.classify_file(&unknown_path).unwrap();
        assert!(unknown_file.is_none());
    }

    #[test]
    fn test_supported_extensions() {
        let discovery = FileDiscovery::new();
        
        // æ¸¬è©¦å½±ç‰‡å‰¯æª”å
        assert!(discovery.video_extensions.contains(&"mp4".to_string()));
        assert!(discovery.video_extensions.contains(&"mkv".to_string()));
        assert!(discovery.video_extensions.contains(&"avi".to_string()));
        
        // æ¸¬è©¦å­—å¹•å‰¯æª”å
        assert!(discovery.subtitle_extensions.contains(&"srt".to_string()));
        assert!(discovery.subtitle_extensions.contains(&"ass".to_string()));
        assert!(discovery.subtitle_extensions.contains(&"vtt".to_string()));
    }

    #[test]
    fn test_empty_directory() {
        let temp_dir = TempDir::new().unwrap();
        let discovery = FileDiscovery::new();
        let files = discovery.scan_directory(temp_dir.path(), false).unwrap();
        assert_eq!(files.len(), 0);
    }

    #[test]
    fn test_nonexistent_directory() {
        let discovery = FileDiscovery::new();
        let nonexistent = Path::new("/nonexistent/path");
        let result = discovery.scan_directory(nonexistent, false);
        assert!(result.is_err());
    }
}
```

### æ¸¬è©¦è¦†è“‹ç‡ CI/CD æ•´åˆ
```yaml
# .github/workflows/test-coverage.yml
name: Test Coverage

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust stable
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
        components: llvm-tools-preview
    
    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Install cargo-tarpaulin
      run: cargo install cargo-tarpaulin
    
    - name: Run tests with coverage
      run: |
        cargo tarpaulin \
          --verbose \
          --all-features \
          --workspace \
          --timeout 120 \
          --out Html \
          --out Lcov \
          --output-dir coverage/ \
          --fail-under 50
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: coverage/lcov.info
        fail_ci_if_error: true
        verbose: true
    
    - name: Archive coverage results
      uses: actions/upload-artifact@v3
      with:
        name: coverage-report
        path: coverage/
    
    - name: Comment coverage on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          try {
            const coverage = fs.readFileSync('coverage/tarpaulin-report.html', 'utf8');
            // è§£æè¦†è“‹ç‡ç™¾åˆ†æ¯”ä¸¦ç•™è¨€åˆ° PR
            const coverageMatch = coverage.match(/(\d+\.?\d*)%/);
            if (coverageMatch) {
              const percentage = parseFloat(coverageMatch[1]);
              const message = `## ğŸ§ª æ¸¬è©¦è¦†è“‹ç‡å ±å‘Š\n\nç•¶å‰è¦†è“‹ç‡: **${percentage}%**\n\n${percentage >= 50 ? 'âœ… é”æˆç›®æ¨™è¦†è“‹ç‡ (â‰¥50%)' : 'âŒ æœªé”æˆç›®æ¨™è¦†è“‹ç‡ (â‰¥50%)'}`;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: message
              });
            }
          } catch (error) {
            console.log('ç„¡æ³•è®€å–è¦†è“‹ç‡å ±å‘Š:', error);
          }
```

### æ¸¬è©¦å·¥å…·è¼”åŠ©å‡½å¼
```rust
// tests/common/mod.rs
use tempfile::TempDir;
use std::fs;
use std::path::Path;

/// æ¸¬è©¦ç”¨çš„åª’é«”æª”æ¡ˆç”Ÿæˆå™¨
pub struct TestMediaGenerator {
    pub temp_dir: TempDir,
}

impl TestMediaGenerator {
    pub fn new() -> Self {
        Self {
            temp_dir: TempDir::new().unwrap(),
        }
    }

    pub fn path(&self) -> &Path {
        self.temp_dir.path()
    }

    /// å»ºç«‹æ¸¬è©¦ç”¨çš„ SRT å­—å¹•æª”æ¡ˆ
    pub fn create_srt_file(&self, name: &str, entries: &[(&str, &str, &str)]) -> PathBuf {
        let mut content = String::new();
        for (i, (start, end, text)) in entries.iter().enumerate() {
            content.push_str(&format!("{}\n{} --> {}\n{}\n\n", i + 1, start, end, text));
        }
        
        let path = self.path().join(format!("{}.srt", name));
        fs::write(&path, content).unwrap();
        path
    }

    /// å»ºç«‹æ¸¬è©¦ç”¨çš„å½±ç‰‡æª”æ¡ˆï¼ˆç©ºæª”æ¡ˆï¼‰
    pub fn create_video_file(&self, name: &str, extension: &str) -> PathBuf {
        let path = self.path().join(format!("{}.{}", name, extension));
        fs::write(&path, b"").unwrap();
        path
    }

    /// å»ºç«‹æ¸¬è©¦ç”¨çš„é…ç½®æª”æ¡ˆ
    pub fn create_config_file(&self, config: &subx_cli::config::Config) -> PathBuf {
        let content = toml::to_string_pretty(config).unwrap();
        let path = self.path().join("config.toml");
        fs::write(&path, content).unwrap();
        path
    }
}

/// æ¸¬è©¦ç”¨çš„ AI å›æ‡‰æ¨¡æ“¬å™¨
pub struct MockAIResponses;

impl MockAIResponses {
    pub fn successful_match_response() -> serde_json::Value {
        serde_json::json!({
            "matches": [
                {
                    "video_file": "video.mp4",
                    "subtitle_file": "subtitle.srt",
                    "confidence": 0.95,
                    "match_factors": ["æª”åç›¸ä¼¼", "å…§å®¹åŒ¹é…"]
                }
            ],
            "confidence": 0.95,
            "reasoning": "æª”åæ¨¡å¼é«˜åº¦ç›¸ä¼¼"
        })
    }

    pub fn low_confidence_response() -> serde_json::Value {
        serde_json::json!({
            "matches": [
                {
                    "video_file": "video.mp4",
                    "subtitle_file": "subtitle.srt",
                    "confidence": 0.3,
                    "match_factors": ["éƒ¨åˆ†æª”åç›¸ä¼¼"]
                }
            ],
            "confidence": 0.3,
            "reasoning": "åŒ¹é…åº¦è¼ƒä½"
        })
    }

    pub fn no_match_response() -> serde_json::Value {
        serde_json::json!({
            "matches": [],
            "confidence": 0.0,
            "reasoning": "æ‰¾ä¸åˆ°åˆé©çš„åŒ¹é…"
        })
    }
}

/// æ–·è¨€è¼”åŠ©å·¨é›†
#[macro_export]
macro_rules! assert_subtitle_entry {
    ($entry:expr, $index:expr, $start:expr, $end:expr, $text:expr) => {
        assert_eq!($entry.index, $index);
        assert_eq!($entry.start_time, std::time::Duration::from_millis($start));
        assert_eq!($entry.end_time, std::time::Duration::from_millis($end));
        assert_eq!($entry.text, $text);
    };
}
```

### æ•´åˆæ¸¬è©¦æ“´å±•
```rust
// tests/integration_tests.rs (æ“´å±•)
mod common;

use common::TestMediaGenerator;
use assert_cmd::Command;
use predicates::prelude::*;
use std::env;

#[test]
fn test_config_command_integration() {
    let test_gen = TestMediaGenerator::new();
    
    // æ¸¬è©¦è¨­å®šé…ç½®å€¼
    let mut cmd = Command::cargo_bin("subx-cli").unwrap();
    cmd.env("SUBX_CONFIG_PATH", test_gen.path().join("config.toml"))
        .arg("config")
        .arg("set")
        .arg("ai.model")
        .arg("gpt-4")
        .assert()
        .success()
        .stdout(predicate::str::contains("gpt-4"));

    // æ¸¬è©¦è®€å–é…ç½®å€¼
    let mut cmd = Command::cargo_bin("subx-cli").unwrap();
    cmd.env("SUBX_CONFIG_PATH", test_gen.path().join("config.toml"))
        .arg("config")
        .arg("get")
        .arg("ai.model")
        .assert()
        .success()
        .stdout(predicate::str::contains("gpt-4"));
}

#[test]
fn test_convert_command_integration() {
    let test_gen = TestMediaGenerator::new();
    let srt_file = test_gen.create_srt_file("test", &[
        ("00:00:01,000", "00:00:03,000", "Hello"),
        ("00:00:05,000", "00:00:07,000", "World"),
    ]);

    // æ¸¬è©¦è½‰æ›ç‚º VTT
    let mut cmd = Command::cargo_bin("subx-cli").unwrap();
    cmd.arg("convert")
        .arg(&srt_file)
        .arg("--format")
        .arg("vtt")
        .assert()
        .success();

    // æª¢æŸ¥è¼¸å‡ºæª”æ¡ˆ
    let vtt_file = srt_file.with_extension("vtt");
    assert!(vtt_file.exists());
    
    let content = std::fs::read_to_string(vtt_file).unwrap();
    assert!(content.contains("WEBVTT"));
}

#[test]
fn test_error_handling() {
    // æ¸¬è©¦ä¸å­˜åœ¨çš„è·¯å¾‘
    let mut cmd = Command::cargo_bin("subx-cli").unwrap();
    cmd.arg("match")
        .arg("/nonexistent/path")
        .assert()
        .failure()
        .stderr(predicate::str::contains("æŒ‡å®šè·¯å¾‘ä¸å­˜åœ¨"));

    // æ¸¬è©¦ç„¡æ•ˆçš„æ ¼å¼
    let mut cmd = Command::cargo_bin("subx-cli").unwrap();
    cmd.arg("convert")
        .arg("nonexistent.srt")
        .arg("--format")
        .arg("invalid")
        .assert()
        .failure();
}

#[test] 
fn test_help_messages() {
    let mut cmd = Command::cargo_bin("subx-cli").unwrap();
    cmd.arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("æ™ºæ…§å­—å¹•è™•ç† CLI å·¥å…·"));

    let mut cmd = Command::cargo_bin("subx-cli").unwrap();
    cmd.arg("match")
        .arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("AI åŒ¹é…é‡å‘½åå­—å¹•æ–‡ä»¶"));
}
```

## é©—æ”¶æ¨™æº–

### 1. æ¸¬è©¦è¦†è“‹ç‡ç›®æ¨™
- [ ] **æ•´é«”æ¸¬è©¦è¦†è“‹ç‡é”æˆ 50% ä»¥ä¸Š**
- [ ] **æ ¸å¿ƒæ¨¡çµ„æ¸¬è©¦è¦†è“‹ç‡é”æˆ 70% ä»¥ä¸Šï¼š**
  - éŒ¯èª¤è™•ç†æ¨¡çµ„ (error.rs)
  - é…ç½®ç®¡ç†æ¨¡çµ„ (config.rs)  
  - å­—å¹•æ ¼å¼è§£æå¼•æ“ (core/formats/)
  - æª”æ¡ˆåŒ¹é…å¼•æ“ (core/matcher/)
- [ ] **æœå‹™æ¨¡çµ„æ¸¬è©¦è¦†è“‹ç‡é”æˆ 60% ä»¥ä¸Šï¼š**
  - AI æœå‹™æ•´åˆ (services/ai/)
  - éŸ³è¨Šè™•ç†æœå‹™ (services/audio/)

### 2. æ¸¬è©¦å“è³ªè¦æ±‚
- [ ] **æ‰€æœ‰å–®å…ƒæ¸¬è©¦å¿…é ˆç¨ç«‹åŸ·è¡Œ**
- [ ] **æ¸¬è©¦å¿…é ˆå…·æœ‰ç¢ºå®šæ€§ï¼ˆä¸ä¾è³´å¤–éƒ¨æœå‹™ï¼‰**
- [ ] **æ¨¡æ“¬æ¸¬è©¦æ­£ç¢ºä½¿ç”¨ mockall æ¡†æ¶**
- [ ] **æ¸¬è©¦è³‡æ–™ä½¿ç”¨ tempfile é€²è¡Œéš”é›¢**
- [ ] **æ¯å€‹æ¸¬è©¦éƒ½æœ‰æ¸…æ¥šçš„æ–·è¨€å’ŒéŒ¯èª¤è¨Šæ¯**

### 3. æ¸¬è©¦åŸ·è¡Œè¦æ±‚
- [ ] **cargo test åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦ç„¡éŒ¯èª¤**
- [ ] **cargo clippy -- -D warnings ç„¡è­¦å‘Š**
- [ ] **æ¸¬è©¦åŸ·è¡Œæ™‚é–“ < 60 ç§’**
- [ ] **ä¸¦è¡Œæ¸¬è©¦åŸ·è¡Œç„¡è¡çª**

### 4. CI/CD æ•´åˆè¦æ±‚
- [ ] **GitHub Actions è‡ªå‹•åŸ·è¡Œè¦†è“‹ç‡æª¢æŸ¥**
- [ ] **PR è‡ªå‹•ç•™è¨€è¦†è“‹ç‡å ±å‘Š**
- [ ] **è¦†è“‹ç‡ä½æ–¼ 50% æ™‚ CI å¤±æ•—**
- [ ] **è¦†è“‹ç‡å ±å‘Šä¸Šå‚³è‡³ Codecov**

### 5. æ–‡ä»¶å’Œç¶­è­·æ€§
- [ ] **æ¸¬è©¦ç¨‹å¼ç¢¼æœ‰é©ç•¶çš„è¨»é‡‹èªªæ˜**
- [ ] **æ¸¬è©¦è¼”åŠ©å‡½å¼æ–‡ä»¶å®Œæ•´**
- [ ] **æ¸¬è©¦è³‡æ–™ç”Ÿæˆå™¨æ˜“æ–¼ä½¿ç”¨**
- [ ] **æ¨¡æ“¬ç‰©ä»¶è¨­å®šæ¸…æ¥šæ˜ç¢º**

## ä¼°è¨ˆå·¥æ™‚
**6-8 å¤©**

### å·¥æ™‚åˆ†é…ï¼š
- æ¸¬è©¦åŸºç¤è¨­æ–½å»ºç«‹ï¼š1 å¤©
- æ ¸å¿ƒæ¨¡çµ„æ¸¬è©¦å¯¦ä½œï¼š2-3 å¤©
- æœå‹™æ¨¡çµ„æ¨¡æ“¬æ¸¬è©¦ï¼š2 å¤©
- CI/CD æ•´åˆå’Œå„ªåŒ–ï¼š1 å¤©
- æ¸¬è©¦è¦†è“‹ç‡é”æ¨™èª¿æ•´ï¼š1-2 å¤©

## ç›¸ä¾æ€§
- ä¾è³´ Backlog #01-11 (æ‰€æœ‰åŠŸèƒ½æ¨¡çµ„å·²å¯¦ä½œå®Œæˆ)

## é¢¨éšªè©•ä¼°
- **ä¸­é¢¨éšªï¼š** æ¸¬è©¦è¦†è“‹ç‡ç›®æ¨™å¯èƒ½éœ€è¦å¤šæ¬¡èª¿æ•´
- **æ³¨æ„äº‹é …ï¼š**
  - æ¨¡æ“¬å¤–éƒ¨æœå‹™ï¼ˆOpenAI APIï¼‰çš„è¤‡é›œåº¦
  - éŸ³è¨Šè™•ç†æ¸¬è©¦çš„è³‡æºéœ€æ±‚
  - ä¸¦è¡Œæ¸¬è©¦çš„åŒæ­¥å•é¡Œ
  - æ¸¬è©¦è³‡æ–™çš„ç®¡ç†å’Œæ¸…ç†

## æˆåŠŸæŒ‡æ¨™
1. **æ•´é«”æ¸¬è©¦è¦†è“‹ç‡ â‰¥ 50%**
2. **æ ¸å¿ƒæ¨¡çµ„è¦†è“‹ç‡ â‰¥ 70%**
3. **æ‰€æœ‰æ¸¬è©¦ç©©å®šé€šé**
4. **CI/CD è‡ªå‹•åŒ–è¦†è“‹ç‡æª¢æŸ¥æ­£å¸¸é‹ä½œ**
5. **æ¸¬è©¦ç¶­è­·æˆæœ¬åˆç†**
