# Bug #11.4: 實作同步配置中的 auto_detect_sample_rate 功能

## 關聯問題
- **主議題**: [Bug #11: 配置項目整合問題](11-config-integration-issues.md)
- **前置依賴**: Bug #11.1-11.3（確保其他配置正確整合後再進行此功能實作）

## 問題描述

`SyncConfig` 中的 `auto_detect_sample_rate` 配置項目已經定義並可以設定，但對應的功能尚未實作。目前同步命令始終使用配置檔案中的 `audio_sample_rate` 固定值，無法根據輸入音訊檔案自動檢測採樣率。

### 目前狀況
- `auto_detect_sample_rate` 配置已在 `SyncConfig` 中定義 (預設值: `true`)
- 配置可正常載入和設定，但功能未整合到同步流程中
- 同步命令硬編碼使用 `config.sync.audio_sample_rate`，忽略自動檢測設定

### 需要實作的功能
- 整合 `aus` crate 的採樣率檢測能力到同步命令
- 根據 `auto_detect_sample_rate` 配置決定是否自動檢測
- 提供適當的錯誤處理和 fallback 機制

## 技術分析

### 1. 目前實作狀況
**SyncConfig 結構**: `auto_detect_sample_rate` 已正確定義並可設定
```rust
pub struct SyncConfig {
    pub max_offset_seconds: f32,
    pub audio_sample_rate: u32,           // 目前硬編碼使用
    pub correlation_threshold: f32,
    pub dialogue_detection_threshold: f32,
    pub min_dialogue_duration_ms: u64,
    pub dialogue_merge_gap_ms: u64,
    pub enable_dialogue_detection: bool,
    pub resample_quality: String,
    pub auto_detect_sample_rate: bool,    // ← 需要實作此功能
    pub enable_smart_resampling: bool,
}
```

**同步命令現狀**: 只使用固定採樣率，未檢查 `auto_detect_sample_rate` 設定
```rust
// src/commands/sync_command.rs (目前實作)
let dialogue_detector = DialogueDetector::new(
    config.sync.dialogue_detection_threshold,
    config.sync.min_dialogue_duration_ms,
    config.sync.audio_sample_rate,  // ← 硬編碼，忽略自動檢測設定
    config.sync.dialogue_merge_gap_ms,
);
```

### 2. aus crate 能力評估
**已確認支援**:
- 音訊檔案讀取: `aus::read()` 函式
- 採樣率檢測: `AudioFile.sample_rate` 欄位可直接存取
- 多種音訊格式支援: WAV, AIFF 等

**實作可行性**: 高 - aus crate 提供直接的採樣率檢測能力，無需複雜演算法

## 實作計畫

### 階段 1: 建立採樣率檢測器
**目標**: 建立使用 aus crate 的採樣率檢測器

#### 步驟 1.1: 實作 AusSampleRateDetector
```rust
// src/services/audio/resampler/detector.rs (新增或擴展)
use aus::{read, AudioFile};
use std::path::Path;
use crate::error::Result;

pub struct AusSampleRateDetector;

impl AusSampleRateDetector {
    pub fn new() -> Self {
        Self
    }
    
    pub fn detect_sample_rate(&self, audio_path: &Path) -> Result<u32> {
        let audio_file = read(audio_path.to_str().unwrap())?;
        Ok(audio_file.sample_rate)
    }
    
    pub fn auto_detect_if_enabled(&self, audio_path: &Path, config: &SyncConfig) -> Result<u32> {
        if config.auto_detect_sample_rate {
            self.detect_sample_rate(audio_path)
        } else {
            Ok(config.audio_sample_rate)
        }
    }
}
```

### 階段 2: 整合到同步命令
**目標**: 修改同步命令使用自動檢測功能

#### 步驟 2.1: 更新 SyncCommand
```rust
// src/commands/sync_command.rs
impl SyncCommand {
    pub fn execute(&self) -> Result<()> {
        let config = load_config()?;
        
        // 使用自動檢測器決定採樣率
        let detector = AusSampleRateDetector::new();
        let sample_rate = detector.auto_detect_if_enabled(&self.audio_file, &config.sync)?;
        
        // 使用檢測到的採樣率建立對話檢測器
        let dialogue_detector = DialogueDetector::new(
            config.sync.dialogue_detection_threshold,
            config.sync.min_dialogue_duration_ms,
            sample_rate,  // 使用檢測到的採樣率
            config.sync.dialogue_merge_gap_ms,
        );
        
        // ...existing sync logic...
    }
}
```

#### 步驟 2.2: 錯誤處理與 fallback
- 當檔案讀取失敗時，回退到配置中的預設採樣率
- 提供清楚的錯誤訊息和除錯資訊
- 記錄採樣率檢測結果

### 階段 3: 配置驗證與測試
**目標**: 確保功能正確運作並建立測試

#### 步驟 3.1: 配置驗證更新
```rust
// src/config/validator.rs
impl SyncConfigValidator {
    pub fn validate(&self, config: &SyncConfig) -> ValidationResult {
        let mut errors = Vec::new();
        
        // 驗證 fallback 採樣率有效性
        if config.audio_sample_rate < 8000 || config.audio_sample_rate > 192000 {
            errors.push("fallback 採樣率必須在 8000-192000 Hz 範圍內".to_string());
        }
        
        // 如果啟用自動檢測，警告可能的效能影響
        if config.auto_detect_sample_rate {
            // 這是資訊性警告，不是錯誤
        }
        
        ValidationResult::new(errors)
    }
}
```

#### 步驟 3.2: 整合測試建立
- 建立不同採樣率音訊檔案的測試案例
- 測試自動檢測開啟/關閉的行為
- 測試錯誤處理和 fallback 機制

## 技術實作細節

### 自動採樣率檢測實作
```rust
// src/services/audio/resampler/detector.rs
use aus::{read, AudioFile};
use std::path::Path;
use crate::error::{Result, SubXError};
use crate::config::SyncConfig;

pub struct AusSampleRateDetector;

impl AusSampleRateDetector {
    pub fn new() -> Self {
        Self
    }
    
    pub fn detect_sample_rate(&self, audio_path: &Path) -> Result<u32> {
        let audio_file = read(audio_path.to_str().unwrap())
            .map_err(|e| SubXError::AudioProcessing(format!("讀取音訊檔案失敗: {}", e)))?;
        
        Ok(audio_file.sample_rate)
    }
    
    pub fn auto_detect_if_enabled(&self, audio_path: &Path, config: &SyncConfig) -> Result<u32> {
        if config.auto_detect_sample_rate {
            match self.detect_sample_rate(audio_path) {
                Ok(detected_rate) => {
                    log::info!("自動檢測到採樣率: {}Hz", detected_rate);
                    Ok(detected_rate)
                }
                Err(e) => {
                    log::warn!("採樣率自動檢測失敗，使用預設值 {}Hz: {}", config.audio_sample_rate, e);
                    Ok(config.audio_sample_rate)
                }
            }
        } else {
            log::debug!("使用配置採樣率: {}Hz", config.audio_sample_rate);
            Ok(config.audio_sample_rate)
        }
    }
}
```

### 同步命令整合
```rust
// src/commands/sync_command.rs 更新
use crate::services::audio::resampler::detector::AusSampleRateDetector;

impl SyncCommand {
    pub fn execute(&self) -> Result<()> {
        let config = load_config()?;
        
        // 使用自動檢測器決定採樣率
        let detector = AusSampleRateDetector::new();
        let sample_rate = detector.auto_detect_if_enabled(&self.audio_file, &config.sync)?;
        
        // 使用檢測到的採樣率建立對話檢測器
        let dialogue_detector = DialogueDetector::new(
            config.sync.dialogue_detection_threshold,
            config.sync.min_dialogue_duration_ms,
            sample_rate,
            config.sync.dialogue_merge_gap_ms,
        );
        
        // ...existing sync logic...
    }
}
```

## 實作順序

### 第一階段：建立採樣率檢測器（1 個工作日）
1. 建立 `AusSampleRateDetector` 結構體
2. 實作基本的採樣率檢測功能
3. 實作帶配置判斷的自動檢測方法
4. 新增適當的錯誤處理和日誌記錄

### 第二階段：整合到同步命令（1-2 個工作日）
1. 修改 `SyncCommand::execute()` 使用採樣率檢測器
2. 確保採樣率傳遞到 `DialogueDetector` 建立
3. 測試同步命令在不同採樣率檔案上的行為
4. 驗證配置開關正確運作

### 第三階段：測試與文件（1-2 個工作日）
1. 建立自動採樣率檢測的單元測試
2. 建立同步命令的整合測試
3. 更新配置驗證邏輯
4. 撰寫功能文件和使用範例

## 測試策略

### 單元測試
```
tests/unit/
├── auto_sample_rate_detection_tests.rs   # 自動採樣率檢測測試
└── sync_config_validation_tests.rs       # 配置驗證測試
```

### 整合測試
```
tests/integration/
├── sync_auto_detection_tests.rs          # 同步命令自動檢測整合測試
└── audio_processing_tests.rs             # 音訊處理整合測試
```

### 測試資料
```
tests/fixtures/audio/
├── different_sample_rates/               # 不同採樣率的測試檔案
│   ├── 8khz_test.wav
│   ├── 16khz_test.wav
│   ├── 44khz_test.wav
│   └── 48khz_test.wav
└── problematic_files/                    # 問題檔案測試
    ├── corrupted.wav
    └── unsupported_format.mp3
```

## 驗收標準

### 功能驗收
- [ ] `AusSampleRateDetector` 能正確檢測常見音訊格式的採樣率
- [ ] `auto_detect_sample_rate` 配置在同步命令中正確運作
- [ ] 當啟用自動檢測時，能正確檢測並使用檔案的實際採樣率
- [ ] 當停用自動檢測時，使用配置檔案中的 `audio_sample_rate`
- [ ] 檢測失敗時能正確 fallback 到配置採樣率
- [ ] 提供適當的日誌記錄和錯誤訊息

### 效能驗收
- [ ] 採樣率檢測耗時 < 100ms（小於 10MB 的檔案）
- [ ] 自動檢測不顯著增加同步命令的整體處理時間（< 5% 增量）
- [ ] 記憶體使用量不因啟用自動檢測而顯著增加

### 準確度驗收
- [ ] 採樣率檢測準確度 > 98%（支援的音訊格式）
- [ ] 正確處理不支援格式的 fallback 邏輯
- [ ] 錯誤處理完善，提供清楚的錯誤訊息
- [ ] 同步結果品質不因採樣率檢測而降低

## 風險評估

### 技術風險
- **低等**: 採樣率檢測功能簡單，aus crate 提供直接的 API 支援
- **低等**: 整合點清楚，只需修改同步命令的採樣率獲取邏輯
- **低等**: fallback 機制確保功能安全性

### 相容性風險
- **極低**: 新功能為可選項目，預設行為保持不變
- **極低**: 不影響現有的同步工作流程和配置
- **極低**: 向後相容，現有配置檔案無需修改

### 維護風險
- **低等**: 程式碼變更範圍小，易於維護
- **低等**: aus crate 為穩定外部依賴，維護負擔低
- **低等**: 清楚的錯誤處理減少除錯難度

## 預期工作量
- **檢測器建立階段**: 1 個工作日
- **同步命令整合階段**: 1-2 個工作日
- **測試階段**: 1-2 個工作日
- **文件更新階段**: 0.5 個工作日
- **總計**: 3.5-5.5 個工作日

## 後續步驟
1. 建立 `AusSampleRateDetector` 採樣率檢測器
2. 修改 `SyncCommand` 整合自動檢測功能
3. 建立針對自動採樣率檢測的測試案例
4. 更新相關文件和使用範例
5. 進行整合測試確保功能正確運作

## 預期效益
- **實用功能**: 提供真正有用的自動採樣率檢測功能，提升使用者體驗
- **提高準確性**: 根據實際音訊檔案採樣率進行同步，提升同步品質
- **配置完整性**: 完成已定義配置的功能實作，確保配置系統完整性
- **靈活性**: 使用者可選擇自動檢測或手動指定採樣率
