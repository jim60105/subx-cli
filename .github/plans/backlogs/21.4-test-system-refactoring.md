# Backlog #21.4: 測試系統重構

## 概述

本子任務負責全面重構測試系統，移除對全域配置管理器的依賴，消除測試競態條件，實現真正的測試隔離。這是確保系統穩定性和可維護性的關鍵步驟。

## 與其他 Backlog 的依賴關係

### 前置依賴
- **Backlog #21.2**: config crate 整合與基礎實作 (已完成)
- **Backlog #21.3**: 配置服務系統實作 (需要 `ConfigService`, `TestConfigService`, `TestConfigBuilder`)
- **Backlog #19.4**: 測試基礎設施最佳化 (需要測試輔助工具)

### 與 Backlog #19.4 的協調關係

本 backlog 需要與 [Backlog #19.4: 測試基礎設施最佳化](../19.4-test-infrastructure-optimization.md) 密切協調：

#### 依賴的 #19.4 工具：
1. **`CLITestHelper`** - 用於 CLI 整合測試重構
2. **`TestFileManager`** - 提供測試隔離的檔案管理
3. **`OutputValidator`** - 驗證測試輸出
4. **`AudioMockGenerator`** - 音訊相關測試的模擬器
5. **`SubtitleGenerator`** - 字幕檔案產生器
6. **並行測試穩定性驗證腳本** - 驗證重構後的測試穩定性

#### 協調執行策略：
```
Timeline:
├── #21.3 (Days 1-2): 提供配置服務介面
├── #19.4 (Days 3-4): 建立測試輔助工具 (並行開始)
└── #21.4 (Days 5-7): 使用 #19.4 工具重構測試系統
```

#### 具體使用場景：
- **CLI 測試重構**: 使用 `CLITestHelper` 取代手動命令執行
- **檔案隔離**: 使用 `TestFileManager` 確保測試間完全隔離
- **並行測試驗證**: 使用 #19.4 的驗證腳本確保重構成功

## 重構計劃

### 階段 1：識別和分析待重構測試 (0.5 天)

#### 1.1 識別需要重構的測試檔案

基於搜尋結果，需要重構的檔案：
- `tests/config_integration_tests.rs` (41 處 `init_config_manager` 使用)
- `tests/encoding_integration_tests.rs`
- `tests/sync/integration_tests.rs`
- `tests/parallel_processing_integration_tests.rs`
- `src/core/sync/dialogue/detector.rs` 測試
- 所有包含 `init_config_manager()`, `reset_global_config_manager()` 的測試

#### 1.2 測試依賴模式分析

**當前測試問題模式**：
```rust
// 當前有問題的測試模式
#[serial]
#[test]
fn test_something() {
    reset_global_config_manager();
    init_config_manager().unwrap();
    let config = load_config().unwrap();
    // 測試邏輯
}
```

**需要移除的元素**：
- `#[serial]` 註解
- `reset_global_config_manager()` 調用  
- `init_config_manager()` 調用 (在測試中)
- `use serial_test::serial;` 匯入
- `load_config()` 直接調用

### 階段 2：重構配置相關測試 (2 天)

#### 2.1 重構 `tests/config_integration_tests.rs`

**重構前的測試**：
```rust
#[serial]
#[test]
fn test_config_file_loading() {
    reset_global_config_manager();
    assert!(init_config_manager().is_ok());
    let config = load_config().unwrap();
    assert_eq!(config.ai.provider, "openai");
}

#[serial]
#[test]
fn test_environment_variable_override() {
    reset_global_config_manager();
    std::env::set_var("SUBX_AI_PROVIDER", "anthropic");
    assert!(init_config_manager().is_ok());
    let config = load_config().unwrap();
    assert_eq!(config.ai.provider, "anthropic");
    std::env::remove_var("SUBX_AI_PROVIDER");
}
```

**重構後的測試**：
```rust
use subx_cli::config::{TestConfigBuilder, ProductionConfigService, ConfigService};
// 從 #19.4 引入測試輔助工具
use tests::common::{CLITestHelper, TestFileManager, OutputValidator};

#[test]  // 移除 #[serial]
fn test_config_file_loading() {
    let config = TestConfigBuilder::new()
        .with_ai_provider("openai")
        .build_config();
    assert_eq!(config.ai.provider, "openai");
}

#[test]  // 可以並行執行
fn test_environment_variable_override() {
    let config = TestConfigBuilder::new()
        .with_ai_provider("anthropic")
        .build_config();
    assert_eq!(config.ai.provider, "anthropic");
}

#[test]
fn test_production_config_service() {
    let service = ProductionConfigService::new().unwrap();
    let config = service.get_config().unwrap();
    // 驗證預設配置載入
    assert!(!config.ai.provider.is_empty());
}

#[test]
fn test_config_service_interface() {
    let service = TestConfigBuilder::new()
        .with_ai_provider("test_provider")
        .with_ai_model("test_model")
        .build_service();
    
    let config = service.get_config().unwrap();
    assert_eq!(config.ai.provider, "test_provider");
    assert_eq!(config.ai.model, "test_model");
    
    // 測試重載功能
    assert!(service.reload().is_ok());
}

#[test]
fn test_cli_integration_with_helper() {
    // 使用 #19.4 的 CLITestHelper
    let mut helper = CLITestHelper::new();
    let workspace = helper.create_isolated_test_workspace().await;
    
    let result = helper.run_command_with_config(&["match", "--help"]).await;
    helper.assert_command_success(&result);
    
    let validator = OutputValidator::new()
        .expect_pattern("Usage:")
        .expect_pattern("match");
    
    assert!(validator.validate(&result.stdout).is_ok());
}
```

#### 2.2 重構同步功能測試

**重構 `tests/sync/integration_tests.rs`**：
```rust
// 使用 #19.4 的測試工具
use tests::common::{TestFileManager, AudioMockGenerator};

// 重構前
#[serial]
#[test]
fn test_dialogue_detection() {
    reset_global_config_manager();
    init_config_manager().unwrap();
    let config = load_config().unwrap();
    let detector = DialogueDetector::new();
    // 測試邏輯...
}

// 重構後
#[test]
fn test_dialogue_detection() {
    let config = TestConfigBuilder::new()
        .with_dialogue_detection(true)
        .with_sync_threshold(0.6)
        .build_config();
    
    let detector = DialogueDetector::new(&config.sync);
    // 測試邏輯完全隔離
}

#[test]
fn test_dialogue_detection_with_audio_mock() {
    // 使用 #19.4 的音訊模擬器
    let mut file_manager = TestFileManager::new();
    let test_dir = file_manager.create_isolated_test_directory("dialogue_test").await;
    
    let audio_mock = AudioMockGenerator::new(44100)
        .with_duration(10.0);
    let audio_path = test_dir.join("test_audio.wav");
    let audio_metadata = audio_mock.generate_dialogue_audio(&audio_path).await.unwrap();
    
    let config = TestConfigBuilder::new()
        .with_dialogue_detection(true)
        .build_config();
    
    let detector = DialogueDetector::new(&config.sync);
    let detected = detector.detect_dialogue(&audio_path).await.unwrap();
    
    // 驗證檢測結果與模擬的對話段落一致
    assert_eq!(detected.len(), audio_metadata.dialogue_segments.len());
}

#[test]
fn test_dialogue_detection_disabled() {
    let config = TestConfigBuilder::new()
        .with_dialogue_detection(false)
        .build_config();
    
    let detector = DialogueDetector::new(&config.sync);
    // 測試不同配置的行為
}

#[test]
fn test_sync_with_different_thresholds() {
    let configs = vec![
        TestConfigBuilder::new().with_sync_threshold(0.5).build_config(),
        TestConfigBuilder::new().with_sync_threshold(0.8).build_config(),
        TestConfigBuilder::new().with_sync_threshold(0.9).build_config(),
    ];
    
    for config in configs {
        let detector = DialogueDetector::new(&config.sync);
        // 測試不同閾值的行為
    }
}
```

#### 2.3 重構編碼檢測測試

**重構 `tests/encoding_integration_tests.rs`**：
```rust
// 使用 #19.4 的測試工具
use tests::common::{TestFileManager, SubtitleGenerator};

// 重構前
#[serial]
#[test]
fn test_encoding_detection() {
    reset_global_config_manager();
    init_config_manager().unwrap();
    // 測試邏輯
}

// 重構後
#[test]
fn test_encoding_detection() {
    let config = TestConfigBuilder::new()
        .build_config();
    
    // 直接傳遞配置到編碼檢測函式
    let result = detect_encoding_with_config(&test_file_path, &config);
    assert!(result.is_ok());
}

#[test]
fn test_encoding_detection_with_generated_files() {
    // 使用 #19.4 的字幕產生器
    let mut file_manager = TestFileManager::new();
    let test_dir = file_manager.create_isolated_test_directory("encoding_test").await;
    
    // 產生不同編碼的測試檔案
    let generators = vec![
        SubtitleGenerator::new(SubtitleFormat::Srt)
            .with_encoding(Charset::Utf8)
            .add_entry(1.0, 3.0, "UTF-8 編碼測試"),
        SubtitleGenerator::new(SubtitleFormat::Srt)
            .with_encoding(Charset::Gbk)
            .add_entry(1.0, 3.0, "GBK 編碼測試"),
    ];
    
    for (i, generator) in generators.iter().enumerate() {
        let file_path = test_dir.join(format!("test_{}.srt", i));
        generator.save_to_file(&file_path).await.unwrap();
        
        let config = TestConfigBuilder::new()
            .with_ai_provider("openai")
            .build_config();
        
        let result = detect_encoding_with_config(&file_path, &config);
        assert!(result.is_ok());
    }
}

#[test]
fn test_encoding_detection_with_custom_settings() {
    let config = TestConfigBuilder::new()
        .with_ai_provider("openai")
        .with_max_sample_length(2000)
        .build_config();
    
    let result = detect_encoding_with_config(&test_file_path, &config);
    // 測試自訂設定的行為
}
```

### 階段 3：重構核心模組測試 (1.5 天)

#### 3.1 重構 DialogueDetector 測試

**更新 `src/core/sync/dialogue/detector.rs` 測試**：
```rust
// src/core/sync/dialogue/detector.rs 測試重構前
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dialogue_detection() {
        crate::config::init_config_manager().unwrap();
        let detector = DialogueDetector::new();
        // 測試邏輯...
    }
}

// src/core/sync/dialogue/detector.rs 測試重構後
#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::TestConfigBuilder;

    #[test]
    fn test_dialogue_detection_enabled() {
        let config = TestConfigBuilder::new()
            .with_dialogue_detection(true)
            .with_sync_threshold(0.7)
            .build_config();
        
        let detector = DialogueDetector::new(&config.sync);
        assert!(detector.config.enable_dialogue_detection);
        assert_eq!(detector.config.correlation_threshold, 0.7);
    }

    #[test]
    fn test_dialogue_detection_disabled() {
        let config = TestConfigBuilder::new()
            .with_dialogue_detection(false)
            .build_config();
        
        let detector = DialogueDetector::new(&config.sync);
        assert!(!detector.config.enable_dialogue_detection);
    }
    
    #[test]
    fn test_different_threshold_values() {
        let thresholds = vec![0.5, 0.7, 0.9];
        
        for threshold in thresholds {
            let config = TestConfigBuilder::new()
                .with_sync_threshold(threshold)
                .build_config();
            
            let detector = DialogueDetector::new(&config.sync);
            assert_eq!(detector.config.correlation_threshold, threshold);
        }
    }
}
```

#### 3.2 重構並行處理測試

**更新 `tests/parallel_processing_integration_tests.rs`**：
```rust
// 重構前
#[serial]
#[test]
fn test_parallel_processing() {
    reset_global_config_manager();
    init_config_manager().unwrap();
    // 測試邏輯
}

// 重構後
#[test]
fn test_parallel_processing_default_workers() {
    let config = TestConfigBuilder::new()
        .with_parallel_workers(4)
        .build_config();
    
    // 測試並行處理邏輯，配置隔離
}

#[test]
fn test_parallel_processing_single_worker() {
    let config = TestConfigBuilder::new()
        .with_parallel_workers(1)
        .build_config();
    
    // 測試單工作者模式
}

#[test]
fn test_parallel_processing_many_workers() {
    let config = TestConfigBuilder::new()
        .with_parallel_workers(16)
        .build_config();
    
    // 測試多工作者模式
}
```

### 階段 4：建立測試輔助函式 (0.5 天)

#### 4.1 建立通用測試輔助
```rust
// tests/common/config_helpers.rs
use subx_cli::config::{TestConfigBuilder, Config};

pub fn create_test_config_for_ai_testing() -> Config {
    TestConfigBuilder::new()
        .with_ai_provider("openai")
        .with_ai_model("gpt-4o-mini")
        .with_max_sample_length(3000)
        .build_config()
}

pub fn create_test_config_for_sync_testing() -> Config {
    TestConfigBuilder::new()
        .with_sync_threshold(0.8)
        .with_max_offset(10.0)
        .with_dialogue_detection(true)
        .build_config()
}

pub fn create_test_config_for_encoding_testing() -> Config {
    TestConfigBuilder::new()
        .with_ai_provider("openai")
        .with_max_sample_length(2000)
        .build_config()
}

pub fn create_minimal_test_config() -> Config {
    TestConfigBuilder::new().build_config()
}
```

#### 4.2 建立測試資料夾結構輔助
```rust
// tests/common/fixtures.rs
use std::path::PathBuf;
use tempfile::TempDir;

pub struct TestEnvironment {
    pub temp_dir: TempDir,
    pub config: subx_cli::config::Config,
}

impl TestEnvironment {
    pub fn new() -> Self {
        let temp_dir = TempDir::new().unwrap();
        let config = subx_cli::config::TestConfigBuilder::new()
            .build_config();
        
        Self { temp_dir, config }
    }
    
    pub fn with_config(config: subx_cli::config::Config) -> Self {
        let temp_dir = TempDir::new().unwrap();
        Self { temp_dir, config }
    }
    
    pub fn temp_path(&self) -> PathBuf {
        self.temp_dir.path().to_path_buf()
    }
    
    pub fn create_test_file(&self, name: &str, content: &str) -> PathBuf {
        let file_path = self.temp_path().join(name);
        std::fs::write(&file_path, content).unwrap();
        file_path
    }
}
```

### 階段 5：移除全域測試依賴 (1 天)

#### 5.1 移除序列化測試註解
```bash
# 搜尋並移除這些模式：
# - #[serial] 註解
# - use serial_test::serial; 匯入

# 需要檢查的檔案模式：
find tests/ -name "*.rs" -exec grep -l "#\[serial\]" {} \;
find src/ -name "*.rs" -exec grep -l "#\[serial\]" {} \;
```

#### 5.2 移除全域狀態函式調用
```bash
# 移除這些函式調用：
# - reset_global_config_manager()
# - init_config_manager() (在測試中)

# 搜尋並替換模式
grep -r "reset_global_config_manager" tests/
grep -r "init_config_manager" tests/
```

#### 5.3 更新 Cargo.toml 依賴
```toml
# Cargo.toml - 移除不再需要的測試依賴
[dev-dependencies]
# 移除：serial_test = "3.0"
tempfile = "3.0"
tokio-test = "0.4"
```

### 階段 6：並行測試驗證 (0.5 天)

#### 6.1 建立並行測試驗證腳本
```bash
#!/bin/bash
# scripts/test_parallel_stability.sh

echo "開始並行測試穩定性驗證..."

# 高並行度測試
echo "執行高並行度測試..."
cargo test --workspace --all-features -- --test-threads=16 || exit 1

# 重複執行確認穩定性
echo "重複執行測試確認穩定性..."
for i in {1..50}; do
    echo "測試執行 $i/50"
    cargo test --workspace --all-features -- --test-threads=8 || {
        echo "測試在第 $i 次執行時失敗"
        exit 1
    }
done

echo "所有並行測試通過！"
```

#### 6.2 效能基準測試
```rust
// tests/performance/test_performance.rs
use std::time::Instant;
use subx_cli::config::TestConfigBuilder;

#[test]
fn test_config_creation_performance() {
    let start = Instant::now();
    
    for _ in 0..1000 {
        let _config = TestConfigBuilder::new()
            .with_ai_provider("openai")
            .with_sync_threshold(0.8)
            .build_config();
    }
    
    let duration = start.elapsed();
    assert!(duration < std::time::Duration::from_millis(100));
    println!("1000 config creations took: {:?}", duration);
}

#[test]
fn test_parallel_config_creation() {
    use std::sync::Arc;
    use std::thread;
    
    let start = Instant::now();
    let handles: Vec<_> = (0..10).map(|i| {
        thread::spawn(move || {
            for _ in 0..100 {
                let _config = TestConfigBuilder::new()
                    .with_ai_provider(&format!("provider_{}", i))
                    .build_config();
            }
        })
    }).collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    let duration = start.elapsed();
    assert!(duration < std::time::Duration::from_millis(200));
    println!("Parallel config creation took: {:?}", duration);
}
```

## 具體測試檔案遷移清單

### 需要完全重構的檔案

| 檔案路徑 | 預估工作量 | 主要變更 |
|---------|-----------|----------|
| `tests/config_integration_tests.rs` | 4 小時 | 移除全域狀態，使用配置建構器 |
| `tests/sync/integration_tests.rs` | 3 小時 | 重構同步測試，移除序列化 |
| `tests/encoding_integration_tests.rs` | 2 小時 | 更新編碼檢測測試 |
| `tests/parallel_processing_integration_tests.rs` | 2 小時 | 重構並行處理測試 |
| `src/core/sync/dialogue/detector.rs` 測試 | 1 小時 | 更新單元測試 |

### 需要部分更新的檔案

| 檔案路徑 | 預估工作量 | 主要變更 |
|---------|-----------|----------|
| `tests/cli_integration_tests.rs` | 1 小時 | 更新 CLI 測試以使用配置服務 |
| `tests/commands/` 下的測試檔案 | 2 小時 | 更新命令測試以接受配置參數 |

## 遷移驗證腳本

### 建立遷移完成度檢查腳本
```bash
#!/bin/bash
# scripts/check_migration_completeness.sh

echo "檢查測試系統遷移完成度..."

# 檢查是否還有 unsafe 相關程式碼
echo "檢查 unsafe 程式碼..."
if grep -r "reset_global_config_manager" src/ tests/; then
    echo "❌ 仍有 reset_global_config_manager 調用"
    exit 1
fi

# 檢查是否還有 serial 註解
echo "檢查序列化測試註解..."
if grep -r "#\[serial\]" src/ tests/; then
    echo "❌ 仍有 #[serial] 註解"
    exit 1
fi

# 檢查是否還有全域配置載入
echo "檢查全域配置載入..."
if grep -r "init_config_manager()" tests/; then
    echo "❌ 測試中仍有 init_config_manager() 調用"
    exit 1
fi

echo "✅ 遷移檢查通過"
```

## 驗證標準

### 功能驗證
- [ ] 所有測試成功移除 `#[serial]` 註解
- [ ] 移除所有 `reset_global_config_manager()` 調用
- [ ] 移除所有測試中的 `init_config_manager()` 調用
- [ ] 所有測試使用隔離的配置實例
- [ ] 測試輔助函式正常工作

### 並行測試驗證
- [ ] 測試可以在高並行度下穩定執行 (--test-threads=16)
- [ ] 重複執行 50 次無失敗
- [ ] 不同測試間無狀態污染
- [ ] 測試執行時間顯著改善

### 效能驗證
- [ ] 配置建立效能令人滿意
- [ ] 測試執行總時間減少
- [ ] 記憶體使用合理
- [ ] 無明顯效能倒退

### 程式碼品質驗證
- [ ] 通過 `cargo clippy -- -D warnings` 檢查
- [ ] 測試程式碼更簡潔易讀
- [ ] 移除不必要的測試依賴
- [ ] 測試邏輯更清晰

## 下一步行動

完成此測試系統重構後，將進入：
- [Backlog #21.5: 命令模組和核心模組遷移](21.5-command-core-module-migration.md)

## 相關資源

### 測試重構參考
- [Rust 測試最佳實踐](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)
- [並行測試策略](https://doc.rust-lang.org/book/ch11-02-running-tests.html)
- [依賴注入測試模式](https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md)

### 工具和命令
```bash
# 執行高並行度測試
cargo test --workspace --all-features -- --test-threads=16

# 檢查測試覆蓋率
cargo llvm-cov --all-features --workspace --html

# 效能分析
cargo test --release -- --nocapture
```
