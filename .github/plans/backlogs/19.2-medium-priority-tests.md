# Product Backlog #19.2: 中期優先級測試實作

## 領域範圍
中期優先級測試缺口解決 (3-5 天) - 音訊服務測試重建、編碼檢測功能測試建立、AI 重試機制測試完善

## 背景脈絡

本 backlog 是 [Product Backlog #19: 關鍵測試缺口解決方案](19-critical-test-gaps-resolution.md) 的第二階段實作，專注於中期優先級模組的測試覆蓋率提升，預期可提升整體覆蓋率 +2%。

### 當前覆蓋率狀態
- **audio/analyzer.rs**: 6.93% → 目標 60%
- **encoding/analyzer.rs**: 0% → 目標 70%
- **encoding/detector.rs**: 0% → 目標 70%
- **ai/retry.rs**: 0% → 目標 80%

## 第二階段實作項目

### ⚡ 2.1 音訊服務測試重建 (目標覆蓋率: 60%)

#### 2.1.1 audio/analyzer.rs 測試實作 (當前 6.93% → 60%)

基於現有的 `AusAudioAnalyzer` 結構，實作以下測試：

```rust
// tests/audio_analyzer_tests.rs

use subx_cli::services::audio::{AusAudioAnalyzer, AudioData, AudioEnvelope};
use tempfile::TempDir;
use std::fs;
use tokio_test;

#[cfg(test)]
mod audio_analyzer_tests {
    use super::*;

    /// 測試音訊檔案載入功能
    #[tokio::test]
    async fn test_load_audio_file_success() {
        let analyzer = AusAudioAnalyzer::new(44100);
        let temp_dir = TempDir::new().unwrap();
        
        // 建立模擬 WAV 檔案 (最小有效 WAV 檔頭)
        let wav_data = create_minimal_wav_file(44100, 1, 1.0);
        let wav_path = temp_dir.path().join("test.wav");
        fs::write(&wav_path, wav_data).unwrap();
        
        let result = analyzer.load_audio_file(&wav_path).await;
        assert!(result.is_ok());
        
        let audio_file = result.unwrap();
        assert_eq!(audio_file.sample_rate, 44100);
        assert!(audio_file.duration > 0.0);
        assert_eq!(audio_file.num_channels, 1);
    }

    /// 測試不存在檔案的錯誤處理
    #[tokio::test]
    async fn test_load_audio_file_not_exists() {
        let analyzer = AusAudioAnalyzer::new(44100);
        let result = analyzer.load_audio_file("non_existent.wav").await;
        assert!(result.is_err());
    }

    /// 測試音訊資料格式轉換
    #[tokio::test]
    async fn test_load_audio_data_conversion() {
        let analyzer = AusAudioAnalyzer::new(16000);
        let temp_dir = TempDir::new().unwrap();
        
        let wav_data = create_minimal_wav_file(16000, 1, 2.0);
        let wav_path = temp_dir.path().join("test.wav");
        fs::write(&wav_path, wav_data).unwrap();
        
        let audio_data = analyzer.load_audio_data(&wav_path).await.unwrap();
        
        assert_eq!(audio_data.sample_rate, 16000);
        assert_eq!(audio_data.channels, 1);
        assert!(audio_data.duration > 1.9 && audio_data.duration < 2.1);
        assert!(!audio_data.samples.is_empty());
    }

    /// 測試音訊能量包絡提取
    #[tokio::test]
    async fn test_extract_envelope_features() {
        let analyzer = AusAudioAnalyzer::new(44100);
        let temp_dir = TempDir::new().unwrap();
        
        // 建立包含變化能量的音訊檔案
        let wav_data = create_varying_energy_wav(44100, 2.0);
        let wav_path = temp_dir.path().join("varying.wav");
        fs::write(&wav_path, wav_data).unwrap();
        
        let envelope = analyzer.extract_envelope(&wav_path).await.unwrap();
        
        assert!(!envelope.samples.is_empty());
        assert_eq!(envelope.sample_rate, analyzer.sample_rate);
        assert!(envelope.duration > 1.9);
        
        // 驗證能量值合理範圍
        for &energy in &envelope.samples {
            assert!(energy >= 0.0);
            assert!(energy <= 1.0);
        }
    }

    /// 測試對話檢測功能
    #[tokio::test]
    async fn test_detect_dialogue_segments() {
        let analyzer = AusAudioAnalyzer::new(16000);
        
        // 建立模擬音訊包絡 (包含語音和靜音段)
        let envelope = AudioEnvelope {
            samples: vec![
                0.1, 0.8, 0.9, 0.7, 0.2,  // 語音段
                0.05, 0.03, 0.02, 0.04,    // 靜音段
                0.6, 0.8, 0.7, 0.9, 0.5,  // 語音段
            ],
            sample_rate: 16000,
            duration: 2.0,
        };
        
        let segments = analyzer.detect_dialogue(&envelope, 0.3);
        
        assert!(!segments.is_empty());
        
        // 驗證檢測到的語音段落
        let speech_segments: Vec<_> = segments.iter()
            .filter(|s| s.intensity > 0.3)
            .collect();
        assert!(speech_segments.len() >= 2);
    }

    /// 測試音訊特徵分析
    #[tokio::test]
    async fn test_audio_features_analysis() {
        let analyzer = AusAudioAnalyzer::new(44100);
        let temp_dir = TempDir::new().unwrap();
        
        let wav_data = create_spectral_rich_wav(44100, 1.0);
        let wav_path = temp_dir.path().join("rich.wav");
        fs::write(&wav_path, wav_data).unwrap();
        
        let audio_file = analyzer.load_audio_file(&wav_path).await.unwrap();
        let features = analyzer.analyze_audio_features(&audio_file).await.unwrap();
        
        assert!(!features.frames.is_empty());
        
        for frame in &features.frames {
            // 驗證光譜重心在合理範圍內 (0 到奈奎斯特頻率)
            assert!(frame.spectral_centroid >= 0.0);
            assert!(frame.spectral_centroid <= 22050.0);
            
            // 驗證光譜熵
            assert!(frame.spectral_entropy >= 0.0);
            assert!(frame.spectral_entropy <= 1.0);
            
            // 驗證過零率
            assert!(frame.zero_crossing_rate >= 0.0);
            assert!(frame.zero_crossing_rate <= 1.0);
        }
    }

    /// 測試無效檔案格式處理
    #[tokio::test]
    async fn test_invalid_audio_format() {
        let analyzer = AusAudioAnalyzer::new(44100);
        let temp_dir = TempDir::new().unwrap();
        
        // 建立無效的音訊檔案
        let invalid_path = temp_dir.path().join("invalid.wav");
        fs::write(&invalid_path, b"This is not audio data").unwrap();
        
        let result = analyzer.load_audio_file(&invalid_path).await;
        assert!(result.is_err());
    }

    /// 測試大檔案處理和記憶體管理
    #[tokio::test]
    async fn test_large_file_memory_management() {
        let analyzer = AusAudioAnalyzer::new(44100);
        let temp_dir = TempDir::new().unwrap();
        
        // 建立較大的音訊檔案 (10 秒)
        let wav_data = create_minimal_wav_file(44100, 1, 10.0);
        let wav_path = temp_dir.path().join("large.wav");
        fs::write(&wav_path, wav_data).unwrap();
        
        let start_memory = get_memory_usage();
        let _audio_data = analyzer.load_audio_data(&wav_path).await.unwrap();
        let end_memory = get_memory_usage();
        
        // 驗證記憶體使用量在合理範圍內 (< 100MB 增長)
        assert!((end_memory - start_memory) < 100_000_000);
    }

    // 輔助函式用於建立測試音訊檔案
    fn create_minimal_wav_file(sample_rate: u32, channels: u16, duration: f32) -> Vec<u8> {
        let samples_per_channel = (sample_rate as f32 * duration) as u32;
        let total_samples = samples_per_channel * channels as u32;
        let data_size = total_samples * 2; // 16-bit samples
        
        let mut wav_data = Vec::new();
        
        // WAV 檔頭
        wav_data.extend_from_slice(b"RIFF");
        wav_data.extend_from_slice(&(36 + data_size).to_le_bytes());
        wav_data.extend_from_slice(b"WAVE");
        wav_data.extend_from_slice(b"fmt ");
        wav_data.extend_from_slice(&16u32.to_le_bytes());
        wav_data.extend_from_slice(&1u16.to_le_bytes()); // PCM
        wav_data.extend_from_slice(&channels.to_le_bytes());
        wav_data.extend_from_slice(&sample_rate.to_le_bytes());
        wav_data.extend_from_slice(&(sample_rate * channels as u32 * 2).to_le_bytes());
        wav_data.extend_from_slice(&(channels * 2).to_le_bytes());
        wav_data.extend_from_slice(&16u16.to_le_bytes());
        wav_data.extend_from_slice(b"data");
        wav_data.extend_from_slice(&data_size.to_le_bytes());
        
        // 音訊資料 (簡單正弦波)
        for i in 0..total_samples {
            let t = i as f32 / sample_rate as f32;
            let amplitude = (2.0 * std::f32::consts::PI * 440.0 * t).sin();
            let sample = (amplitude * 32767.0) as i16;
            wav_data.extend_from_slice(&sample.to_le_bytes());
        }
        
        wav_data
    }

    fn create_varying_energy_wav(sample_rate: u32, duration: f32) -> Vec<u8> {
        // 實作建立變化能量的音訊檔案
        create_minimal_wav_file(sample_rate, 1, duration)
    }

    fn create_spectral_rich_wav(sample_rate: u32, duration: f32) -> Vec<u8> {
        // 實作建立頻譜豐富的音訊檔案
        create_minimal_wav_file(sample_rate, 1, duration)
    }

    fn get_memory_usage() -> usize {
        // 簡化的記憶體使用量檢測
        0 // 實際實作可使用 procfs 或其他系統工具
    }
}
```

#### 2.1.2 audio/extractor.rs 測試補充

```rust
// 擴充現有的 extractor 測試
#[cfg(test)]
mod audio_extractor_tests {
    use super::*;
    
    /// 測試音訊資料提取精確度
    #[tokio::test]
    async fn test_precise_audio_data_extraction() {
        // 實作精確的音訊資料提取測試
    }

    /// 測試時間戳記對應正確性
    #[test]
    fn test_timestamp_mapping_accuracy() {
        // 實作時間戳記映射測試
    }

    /// 測試音訊轉換品質
    #[test]
    fn test_audio_conversion_quality() {
        // 實作音訊轉換品質測試
    }

    /// 測試批量處理效能
    #[tokio::test]
    async fn test_batch_processing_performance() {
        // 實作批量處理效能測試
    }
}
```

### ⚡ 2.2 編碼檢測功能測試建立 (目標覆蓋率: 70%)

#### 2.2.1 encoding/analyzer.rs 測試實作 (當前 0% → 70%)

基於現有的 `ByteAnalyzer` 和 `StatisticalAnalyzer` 結構：

```rust
// tests/encoding_analyzer_tests.rs

use subx_cli::core::formats::encoding::{
    ByteAnalyzer, StatisticalAnalyzer, AnalysisResult, Charset
};
use std::collections::HashMap;

#[cfg(test)]
mod encoding_analyzer_tests {
    use super::*;

    /// 測試位元組分析器基本功能
    #[test]
    fn test_byte_analyzer_basic_analysis() {
        let mut analyzer = ByteAnalyzer::new();
        let test_data = b"Hello, World! 123";
        
        let result = analyzer.analyze(test_data).unwrap();
        
        // 驗證 ASCII 比例
        assert!(result.ascii_ratio > 0.9);
        assert!(result.ascii_ratio <= 1.0);
        
        // 驗證熵值合理範圍
        assert!(result.entropy > 0.0);
        assert!(result.entropy < 8.0);
        
        // 驗證控制字元比例
        assert!(result.control_char_ratio < 0.1);
        
        // 驗證編碼建議
        assert!(result.likely_encodings.contains(&Charset::Utf8));
    }

    /// 測試中文文字編碼分析
    #[test]
    fn test_chinese_text_analysis() {
        let mut analyzer = ByteAnalyzer::new();
        let chinese_text = "你好，世界！測試中文編碼檢測。".as_bytes();
        
        let result = analyzer.analyze(chinese_text).unwrap();
        
        // 中文文字應該有較低的 ASCII 比例
        assert!(result.ascii_ratio < 0.5);
        
        // 熵值應該較高
        assert!(result.entropy > 5.0);
        
        // 應該建議 UTF-8 或其他中文編碼
        let has_unicode_encoding = result.likely_encodings.iter()
            .any(|&charset| matches!(charset, Charset::Utf8 | Charset::Gbk | Charset::Big5));
        assert!(has_unicode_encoding);
    }

    /// 測試二進位資料分析
    #[test]
    fn test_binary_data_analysis() {
        let mut analyzer = ByteAnalyzer::new();
        let binary_data: Vec<u8> = (0..=255).cycle().take(1000).collect();
        
        let result = analyzer.analyze(&binary_data).unwrap();
        
        // 二進位資料應該有高熵值
        assert!(result.entropy > 7.0);
        
        // ASCII 比例應該約為 50%
        assert!(result.ascii_ratio > 0.4);
        assert!(result.ascii_ratio < 0.6);
    }

    /// 測試熵值計算精確度
    #[test]
    fn test_entropy_calculation_accuracy() {
        let mut analyzer = ByteAnalyzer::new();
        
        // 完全均勻分布應該有最大熵值
        let uniform_data: Vec<u8> = (0..=255).collect();
        let uniform_result = analyzer.analyze(&uniform_data).unwrap();
        
        // 重置分析器
        analyzer = ByteAnalyzer::new();
        
        // 單一字元應該有最小熵值
        let single_char_data = vec![b'A'; 100];
        let single_result = analyzer.analyze(&single_char_data).unwrap();
        
        assert!(uniform_result.entropy > single_result.entropy);
        assert!(single_result.entropy < 1.0);
    }

    /// 測試控制字元檢測
    #[test]
    fn test_control_character_detection() {
        let mut analyzer = ByteAnalyzer::new();
        
        // 建立包含控制字元的資料
        let mut data_with_control = Vec::new();
        data_with_control.extend_from_slice(b"Normal text ");
        data_with_control.push(0x01); // SOH
        data_with_control.push(0x02); // STX
        data_with_control.push(0x1F); // US
        data_with_control.extend_from_slice(b" more text");
        
        let result = analyzer.analyze(&data_with_control).unwrap();
        
        // 應該檢測到控制字元
        assert!(result.control_char_ratio > 0.0);
        assert!(result.control_char_ratio < 0.5);
        
        // 可能建議 Windows-1252 編碼
        assert!(result.likely_encodings.contains(&Charset::Windows1252));
    }

    /// 測試統計分析器語言模型
    #[test]
    fn test_statistical_analyzer_language_models() {
        let analyzer = StatisticalAnalyzer::new();
        
        // 測試 UTF-8 中文文字
        let utf8_chinese = "这是一个测试文本。".as_bytes();
        let utf8_scores = analyzer.analyze_with_models(utf8_chinese).unwrap();
        
        // UTF-8 應該有較高分數
        assert!(utf8_scores.get(&Charset::Utf8).unwrap_or(&0.0) > &0.5);
        
        // 測試 GBK 模式文字
        let gbk_pattern = vec![0xB0, 0xA1, 0xC4, 0xE3, 0xBA, 0xC3]; // 模擬 GBK 編碼
        let gbk_scores = analyzer.analyze_with_models(&gbk_pattern).unwrap();
        
        // GBK 應該有合理分數
        assert!(gbk_scores.get(&Charset::Gbk).unwrap_or(&0.0) > &0.0);
    }

    /// 測試位元組頻率分布分析
    #[test]
    fn test_byte_frequency_distribution() {
        let mut analyzer = ByteAnalyzer::new();
        let repeated_data = b"aaabbbccc";
        
        let result = analyzer.analyze(repeated_data).unwrap();
        
        // 驗證位元組分布被正確記錄
        assert!(result.byte_distribution.len() > 0);
        assert_eq!(*result.byte_distribution.get(&b'a').unwrap(), 3);
        assert_eq!(*result.byte_distribution.get(&b'b').unwrap(), 3);
        assert_eq!(*result.byte_distribution.get(&b'c').unwrap(), 3);
    }

    /// 測試空資料處理
    #[test]
    fn test_empty_data_handling() {
        let mut analyzer = ByteAnalyzer::new();
        let empty_data = b"";
        
        let result = analyzer.analyze(empty_data).unwrap();
        
        // 空資料應該回傳預設值
        assert_eq!(result.ascii_ratio, 0.0);
        assert_eq!(result.entropy, 0.0);
        assert_eq!(result.control_char_ratio, 0.0);
        assert!(!result.likely_encodings.is_empty());
    }

    /// 測試編碼建議邏輯
    #[test]
    fn test_encoding_suggestion_logic() {
        let mut analyzer = ByteAnalyzer::new();
        
        // 高 ASCII 比例應該建議 UTF-8
        let ascii_heavy = b"Hello World! 123 ABC";
        let ascii_result = analyzer.analyze(ascii_heavy).unwrap();
        assert!(ascii_result.likely_encodings.contains(&Charset::Utf8));
        
        // 重設分析器
        analyzer = ByteAnalyzer::new();
        
        // 高熵值和低 ASCII 比例應該建議多位元組編碼
        let multibyte_pattern: Vec<u8> = (0x80..=0xFF).cycle().take(100).collect();
        let multibyte_result = analyzer.analyze(&multibyte_pattern).unwrap();
        
        let has_multibyte_encoding = multibyte_result.likely_encodings.iter()
            .any(|&charset| matches!(charset, Charset::Gbk | Charset::Big5 | Charset::ShiftJis));
        assert!(has_multibyte_encoding);
    }

    /// 測試雙字元組模式分析
    #[test]
    fn test_bigram_pattern_analysis() {
        let mut analyzer = ByteAnalyzer::new();
        
        // 建立具有明顯雙字元組模式的資料
        let pattern_data = b"abcabcabcabc";
        let _result = analyzer.analyze(pattern_data).unwrap();
        
        // 注意：目前的實作收集雙字元組頻率但未在結果中使用
        // 這裡可以擴展測試以驗證雙字元組分析邏輯
    }
}
```

#### 2.2.2 encoding/detector.rs 測試實作

```rust
// tests/encoding_detector_tests.rs

use subx_cli::core::formats::encoding::{EncodingDetector, Charset, EncodingInfo};
use tempfile::TempDir;
use std::fs;

#[cfg(test)]
mod encoding_detector_tests {
    use super::*;

    /// 測試 UTF-8 編碼檢測
    #[test]
    fn test_utf8_detection_accuracy() {
        let detector = EncodingDetector::new().unwrap();
        let utf8_text = "Hello, 世界! Bonjour, monde! 🌍";
        
        let result = detector.detect_encoding(utf8_text.as_bytes()).unwrap();
        
        assert_eq!(result.charset, Charset::Utf8);
        assert!(result.confidence > 0.8);
        assert!(!result.bom_detected);
        assert!(result.sample_text.contains("Hello"));
    }

    /// 測試 UTF-8 BOM 檢測
    #[test]
    fn test_utf8_bom_detection() {
        let detector = EncodingDetector::new().unwrap();
        let mut bom_data = vec![0xEF, 0xBB, 0xBF]; // UTF-8 BOM
        bom_data.extend_from_slice("Hello, World!".as_bytes());
        
        let result = detector.detect_encoding(&bom_data).unwrap();
        
        assert_eq!(result.charset, Charset::Utf8);
        assert_eq!(result.confidence, 1.0);
        assert!(result.bom_detected);
        assert_eq!(result.sample_text, "UTF-8 with BOM");
    }

    /// 測試 UTF-16 BOM 檢測
    #[test]
    fn test_utf16_bom_detection() {
        let detector = EncodingDetector::new().unwrap();
        
        // UTF-16 LE BOM
        let utf16le_data = vec![0xFF, 0xFE, 0x48, 0x00, 0x65, 0x00]; // "He" in UTF-16 LE
        let result = detector.detect_encoding(&utf16le_data).unwrap();
        assert_eq!(result.charset, Charset::Utf16Le);
        assert!(result.bom_detected);
        
        // UTF-16 BE BOM
        let utf16be_data = vec![0xFE, 0xFF, 0x00, 0x48, 0x00, 0x65]; // "He" in UTF-16 BE
        let result = detector.detect_encoding(&utf16be_data).unwrap();
        assert_eq!(result.charset, Charset::Utf16Be);
        assert!(result.bom_detected);
    }

    /// 測試檔案編碼檢測
    #[test]
    fn test_file_encoding_detection() {
        let detector = EncodingDetector::new().unwrap();
        let temp_dir = TempDir::new().unwrap();
        
        // 建立 UTF-8 檔案
        let utf8_path = temp_dir.path().join("utf8.txt");
        fs::write(&utf8_path, "測試檔案編碼檢測功能。").unwrap();
        
        let result = detector.detect_file_encoding(utf8_path.to_str().unwrap()).unwrap();
        
        assert_eq!(result.charset, Charset::Utf8);
        assert!(result.confidence > 0.7);
    }

    /// 測試不存在檔案錯誤處理
    #[test]
    fn test_nonexistent_file_error() {
        let detector = EncodingDetector::new().unwrap();
        let result = detector.detect_file_encoding("nonexistent.txt");
        
        assert!(result.is_err());
    }

    /// 測試 GBK 編碼模式檢測
    #[test]
    fn test_gbk_pattern_detection() {
        let detector = EncodingDetector::new().unwrap();
        
        // 模擬 GBK 編碼模式 (高位元組範圍)
        let gbk_pattern = vec![
            0xC4, 0xE3, 0xBA, 0xC3, // 你好 (GBK)
            0xCA, 0xC0, 0xBD, 0xE7, // 世界 (GBK)
        ];
        
        let result = detector.detect_encoding(&gbk_pattern).unwrap();
        
        // 應該檢測為 GBK 或至少不是 UTF-8
        assert!(result.confidence > 0.3);
        if result.charset == Charset::Gbk {
            assert!(result.confidence > 0.5);
        }
    }

    /// 測試 Shift-JIS 編碼檢測
    #[test]
    fn test_shift_jis_detection() {
        let detector = EncodingDetector::new().unwrap();
        
        // 模擬 Shift-JIS 編碼模式
        let shift_jis_pattern = vec![
            0x82, 0xB1, 0x82, 0xF1, // こん (Shift-JIS)
            0x82, 0xC9, 0x82, 0xBF, // にち (Shift-JIS)
        ];
        
        let result = detector.detect_encoding(&shift_jis_pattern).unwrap();
        
        // 應該檢測為 Shift-JIS 或相關編碼
        assert!(result.confidence > 0.2);
    }

    /// 測試編碼信心值排序
    #[test]
    fn test_encoding_confidence_ranking() {
        let detector = EncodingDetector::new().unwrap();
        
        // 明確的 UTF-8 文字應該有最高信心值
        let clear_utf8 = "Clear English text with numbers 123.";
        let utf8_result = detector.detect_encoding(clear_utf8.as_bytes()).unwrap();
        
        // 模糊的資料應該有較低信心值
        let ambiguous_data: Vec<u8> = (0x80..=0xFF).cycle().take(50).collect();
        let ambiguous_result = detector.detect_encoding(&ambiguous_data).unwrap();
        
        assert!(utf8_result.confidence > ambiguous_result.confidence);
    }

    /// 測試最大取樣大小限制
    #[test]
    fn test_max_sample_size_limit() {
        let detector = EncodingDetector::new().unwrap();
        
        // 建立超過取樣大小限制的資料
        let large_data = vec![b'A'; 10000]; // 假設限制是 8192
        let result = detector.detect_encoding(&large_data).unwrap();
        
        // 應該成功檢測且不會因資料太大而失敗
        assert_eq!(result.charset, Charset::Utf8);
        assert!(result.confidence > 0.9);
    }

    /// 測試編碼候選者選擇邏輯
    #[test]
    fn test_encoding_candidate_selection() {
        let detector = EncodingDetector::new().unwrap();
        
        // 建立混合編碼特徵的資料
        let mixed_data = [
            b"English text ",
            &[0xC3, 0xA9], // é in UTF-8
            b" and more text"
        ].concat();
        
        let result = detector.detect_encoding(&mixed_data).unwrap();
        
        // 應該正確選擇 UTF-8
        assert_eq!(result.charset, Charset::Utf8);
        assert!(result.confidence > 0.7);
    }

    /// 測試未知編碼的後備機制
    #[test]
    fn test_unknown_encoding_fallback() {
        let detector = EncodingDetector::new().unwrap();
        
        // 建立完全隨機的資料
        let random_data: Vec<u8> = (0..100).map(|i| (i * 7 + 13) as u8).collect();
        let result = detector.detect_encoding(&random_data).unwrap();
        
        // 應該有一個後備編碼選擇
        assert!(result.confidence >= 0.0);
        assert!(result.confidence <= 1.0);
    }

    /// 測試編碼檢測效能
    #[test]
    fn test_detection_performance() {
        let detector = EncodingDetector::new().unwrap();
        
        // 建立中等大小的文字檔案
        let large_text = "Hello, World! ".repeat(500);
        
        let start = std::time::Instant::now();
        let _result = detector.detect_encoding(large_text.as_bytes()).unwrap();
        let duration = start.elapsed();
        
        // 檢測應該在合理時間內完成 (< 100ms)
        assert!(duration.as_millis() < 100);
    }
}
```

### ⚡ 2.3 AI 重試機制測試完善 (目標覆蓋率: 80%)

#### 2.3.1 ai/retry.rs 測試實作 (當前 0% → 80%)

基於現有的 `retry_with_backoff` 函式和 `RetryConfig` 結構，實作以下測試：

```rust
// tests/ai_retry_tests.rs

use subx_cli::services::ai::retry::{retry_with_backoff, RetryConfig, RetryError};
use std::time::{Duration, Instant};
use tokio::time::sleep;
use std::sync::{Arc, Mutex};

#[cfg(test)]
mod ai_retry_tests {
    use super::*;

    /// 測試基本重試機制
    #[tokio::test]
    async fn test_retry_success_on_second_attempt() {
        let config = RetryConfig {
            max_attempts: 3,
            initial_delay: Duration::from_millis(10),
            max_delay: Duration::from_secs(1),
            backoff_multiplier: 2.0,
        };

        let attempt_count = Arc::new(Mutex::new(0));
        let attempt_count_clone = attempt_count.clone();

        let operation = || async {
            let mut count = attempt_count_clone.lock().unwrap();
            *count += 1;
            if *count == 1 {
                Err(RetryError::Temporary("First attempt fails".to_string()))
            } else {
                Ok("Success on second attempt".to_string())
            }
        };

        let result = retry_with_backoff(&config, operation).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "Success on second attempt");
        assert_eq!(*attempt_count.lock().unwrap(), 2);
    }

    /// 測試最大重試次數限制
    #[tokio::test]
    async fn test_retry_exhaust_max_attempts() {
        let config = RetryConfig {
            max_attempts: 2,
            initial_delay: Duration::from_millis(10),
            max_delay: Duration::from_secs(1),
            backoff_multiplier: 2.0,
        };

        let attempt_count = Arc::new(Mutex::new(0));
        let attempt_count_clone = attempt_count.clone();

        let operation = || async {
            let mut count = attempt_count_clone.lock().unwrap();
            *count += 1;
            Err(RetryError::Temporary("Always fails".to_string()))
        };

        let result = retry_with_backoff(&config, operation).await;
        assert!(result.is_err());
        assert_eq!(*attempt_count.lock().unwrap(), 2);
    }

    /// 測試指數退避延遲
    #[tokio::test]
    async fn test_exponential_backoff_timing() {
        let config = RetryConfig {
            max_attempts: 3,
            initial_delay: Duration::from_millis(50),
            max_delay: Duration::from_millis(200),
            backoff_multiplier: 2.0,
        };

        let attempt_times = Arc::new(Mutex::new(Vec::new()));
        let attempt_times_clone = attempt_times.clone();

        let operation = || async {
            let start_time = Instant::now();
            attempt_times_clone.lock().unwrap().push(start_time);
            Err(RetryError::Temporary("Always fails for timing test".to_string()))
        };

        let overall_start = Instant::now();
        let _result = retry_with_backoff(&config, operation).await;
        
        let times = attempt_times.lock().unwrap();
        assert_eq!(times.len(), 3);
        
        // 驗證延遲時間遞增 (考慮執行時間誤差)
        if times.len() >= 2 {
            let delay1 = times[1].duration_since(times[0]);
            // 第一次延遲應該約為 50ms (±20ms 誤差)
            assert!(delay1 >= Duration::from_millis(30));
            assert!(delay1 <= Duration::from_millis(100));
        }
    }

    /// 測試永久錯誤立即失敗
    #[tokio::test]
    async fn test_permanent_error_no_retry() {
        let config = RetryConfig {
            max_attempts: 3,
            initial_delay: Duration::from_millis(10),
            max_delay: Duration::from_secs(1),
            backoff_multiplier: 2.0,
        };

        let attempt_count = Arc::new(Mutex::new(0));
        let attempt_count_clone = attempt_count.clone();

        let operation = || async {
            let mut count = attempt_count_clone.lock().unwrap();
            *count += 1;
            Err(RetryError::Permanent("Permanent failure".to_string()))
        };

        let result = retry_with_backoff(&config, operation).await;
        assert!(result.is_err());
        assert_eq!(*attempt_count.lock().unwrap(), 1); // 只應嘗試一次
    }

    /// 測試延遲上限限制
    #[tokio::test]
    async fn test_max_delay_cap() {
        let config = RetryConfig {
            max_attempts: 5,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_millis(200), // 低上限
            backoff_multiplier: 3.0, // 高倍數
        };

        let attempt_times = Arc::new(Mutex::new(Vec::new()));
        let attempt_times_clone = attempt_times.clone();

        let operation = || async {
            attempt_times_clone.lock().unwrap().push(Instant::now());
            Err(RetryError::Temporary("Always fails".to_string()))
        };

        let _result = retry_with_backoff(&config, operation).await;
        
        let times = attempt_times.lock().unwrap();
        
        // 驗證後續延遲不會超過 max_delay
        if times.len() >= 3 {
            let delay2 = times[2].duration_since(times[1]);
            // 第二次延遲應該被限制在 max_delay 範圍內 (±50ms 誤差)
            assert!(delay2 <= Duration::from_millis(250));
        }
    }

    /// 測試配置有效性驗證
    #[test]
    fn test_retry_config_validation() {
        // 有效配置
        let valid_config = RetryConfig {
            max_attempts: 3,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(1),
            backoff_multiplier: 2.0,
        };
        assert!(valid_config.initial_delay <= valid_config.max_delay);
        assert!(valid_config.max_attempts > 0);
        assert!(valid_config.backoff_multiplier > 1.0);
    }

    /// 測試與 AI 服務整合的模擬場景
    #[tokio::test]
    async fn test_ai_service_integration_simulation() {
        let config = RetryConfig {
            max_attempts: 3,
            initial_delay: Duration::from_millis(10),
            max_delay: Duration::from_secs(1),
            backoff_multiplier: 2.0,
        };

        // 模擬 AI 服務呼叫
        let request_count = Arc::new(Mutex::new(0));
        let request_count_clone = request_count.clone();

        let mock_ai_request = || async {
            let mut count = request_count_clone.lock().unwrap();
            *count += 1;
            
            match *count {
                1 => Err(RetryError::Temporary("Network timeout".to_string())),
                2 => Err(RetryError::Temporary("Rate limit exceeded".to_string())),
                3 => Ok("AI analysis complete".to_string()),
                _ => unreachable!(),
            }
        };

        let result = retry_with_backoff(&config, mock_ai_request).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "AI analysis complete");
        assert_eq!(*request_count.lock().unwrap(), 3);
    }
}
```

#### 2.3.2 重試機制效能基準測試

```rust
// benches/retry_performance.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion};
use subx_cli::services::ai::retry::{retry_with_backoff, RetryConfig, RetryError};
use std::time::Duration;
use tokio::runtime::Runtime;

fn bench_retry_immediate_success(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    c.bench_function("retry_immediate_success", |b| {
        b.iter(|| {
            rt.block_on(async {
                let config = RetryConfig {
                    max_attempts: 3,
                    initial_delay: Duration::from_millis(1),
                    max_delay: Duration::from_secs(1),
                    backoff_multiplier: 2.0,
                };
                
                let operation = || async { Ok::<String, RetryError>("Success".to_string()) };
                let result = retry_with_backoff(&config, operation).await;
                black_box(result)
            })
        })
    });
}

fn bench_retry_with_failures(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    c.bench_function("retry_with_two_failures", |b| {
        b.iter(|| {
            rt.block_on(async {
                let config = RetryConfig {
                    max_attempts: 3,
                    initial_delay: Duration::from_millis(1),
                    max_delay: Duration::from_secs(1),
                    backoff_multiplier: 2.0,
                };
                
                let mut attempt = 0;
                let operation = || async {
                    attempt += 1;
                    if attempt <= 2 {
                        Err(RetryError::Temporary("Failure".to_string()))
                    } else {
                        Ok("Success".to_string())
                    }
                };
                
                let result = retry_with_backoff(&config, operation).await;
                black_box(result)
            })
        })
    });
}

criterion_group!(benches, bench_retry_immediate_success, bench_retry_with_failures);
criterion_main!(benches);
```

### ⚡ 2.4 Semantic Search 實作參考 (新增：具體程式碼範例)

基於專案中現有的語義搜尋和相似度計算模式，提供具體實作參考：

#### 2.4.1 現有相似度計算模式

**語言檢測相似度** (參考 `src/core/language.rs`):
```rust
#[derive(Debug, Clone)]
pub struct LanguageInfo {
    pub code: String,
    pub source: LanguageSource,
    pub confidence: f32,  // 0.0-1.0 相似度分數
}

impl LanguageDetector {
    fn detect_from_filename(&self, path: &Path) -> Option<LanguageInfo> {
        // 基於檔名模式匹配的相似度計算
        for re in &self.filename_patterns {
            if let Some(cap) = re.captures(name) {
                return Some(LanguageInfo {
                    code: code.clone(),
                    source: LanguageSource::Filename,
                    confidence: 0.8,  // 靜態信心度
                });
            }
        }
        None
    }
}
```

**音訊特徵相似度** (參考 `src/services/audio/analyzer.rs`):
```rust
use spectrum::{rstft, complex_to_polar_rfft, rfftfreq};
use analysis::{spectral_centroid, spectral_entropy, zero_crossing_rate};

impl AusAudioAnalyzer {
    pub async fn analyze_audio_features(&self, audio_file: &AudioFile) -> Result<AudioFeatures> {
        let samples = &audio_file.samples[0];
        let stft_result = spectrum::rstft(samples, self.window_size, self.hop_size, WindowType::Hanning);

        for frame in stft_result.iter() {
            let (magnitude_spectrum, _) = spectrum::complex_to_polar_rfft(frame);
            let frequencies = spectrum::rfftfreq(self.window_size, audio_file.sample_rate);

            // 計算特徵向量 - 可用於語義相似度
            let spectral_centroid = analysis::spectral_centroid(&magnitude_spectrum, &frequencies);
            let spectral_entropy = analysis::spectral_entropy(&magnitude_spectrum);
            let zero_crossing_rate = analysis::zero_crossing_rate(samples, audio_file.sample_rate);

            features.push(FrameFeatures {
                spectral_centroid: spectral_centroid as f32,
                spectral_entropy: spectral_entropy as f32,
                zero_crossing_rate: zero_crossing_rate as f32,
            });
        }
        Ok(AudioFeatures { frames: features })
    }
}
```

**相關性計算模式** (參考 `src/core/sync/engine.rs`):
```rust
impl SyncEngine {
    fn calculate_cross_correlation(&self, audio_envelope: &AudioEnvelope, subtitle_signal: &[f32]) -> Result<SyncResult> {
        let max_offset_samples = (self.config.max_offset_seconds * audio_envelope.sample_rate as f32) as i32;
        let mut best_correlation = 0.0;

        for offset in -max_offset_samples..=max_offset_samples {
            let corr = self.calculate_correlation_at_offset(&audio_envelope.samples, subtitle_signal, offset);
            if corr > best_correlation {
                best_correlation = corr;
            }
        }

        // 正規化相關性分數
        let confidence = if best_correlation > self.config.correlation_threshold {
            best_correlation
        } else {
            0.0
        };

        Ok(SyncResult { confidence, /* ... */ })
    }

    fn calculate_correlation_at_offset(&self, audio_signal: &[f32], subtitle_signal: &[f32], offset: i32) -> f32 {
        let mut sum_product = 0.0;
        let mut sum_audio_sq = 0.0;
        let mut sum_sub_sq = 0.0;
        let mut count = 0;

        for i in 0..audio_len {
            let j = i + offset;
            if j >= 0 && j < subtitle_len {
                let a = audio_signal[i as usize];
                let s = subtitle_signal[j as usize];
                sum_product += a * s;
                sum_audio_sq += a * a;
                sum_sub_sq += s * s;
                count += 1;
            }
        }

        if count == 0 || sum_audio_sq == 0.0 || sum_sub_sq == 0.0 {
            return 0.0;
        }

        // 皮爾遜相關係數計算
        sum_product / (sum_audio_sq.sqrt() * sum_sub_sq.sqrt())
    }
}
```

#### 2.4.2 雜湊與快取模式 (參考 `src/services/ai/cache.rs`)

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

impl AICache {
    pub fn generate_key(request: &AnalysisRequest) -> String {
        let mut hasher = DefaultHasher::new();
        request.video_files.hash(&mut hasher);
        request.subtitle_files.hash(&mut hasher);
        format!("{:x}", hasher.finish())
    }

    pub async fn get(&self, key: &str) -> Option<MatchResult> {
        let cache = self.cache.read().await;
        if let Some(entry) = cache.get(key) {
            if SystemTime::now().duration_since(entry.created_at).unwrap_or_default() < self.ttl {
                return Some(entry.result.clone());
            }
        }
        None
    }
}
```

#### 2.4.3 編碼檢測語義分析 (參考 `src/core/formats/encoding/analyzer.rs`)

```rust
impl StatisticalAnalyzer {
    pub fn analyze_with_models(&self, data: &[u8]) -> Result<HashMap<Charset, f32>> {
        let mut scores = HashMap::new();
        for (cs, model) in &self.language_models {
            let score = self.calculate_model_score(data, model)?;
            scores.insert(cs.clone(), score);
        }
        Ok(scores)
    }

    fn calculate_model_score(&self, data: &[u8], model: &LanguageModel) -> Result<f32> {
        let mut score = 0.0;
        for &b in data {
            // 正向匹配模式
            for &(pb, w) in &model.common_patterns {
                if b == pb {
                    score += w;
                }
            }
            // 負向匹配模式
            for &(ib, _) in &model.invalid_patterns {
                if b == ib {
                    score -= 0.1;
                }
            }
        }
        Ok(if !data.is_empty() {
            score / data.len() as f32
        } else {
            0.0
        })
    }
}
```

#### 2.4.4 匹配引擎整合測試建議

基於 `src/core/matcher/engine.rs` 的實作模式，建議測試：

```rust
#[cfg(test)]
mod semantic_search_tests {
    use super::*;

    #[tokio::test]
    async fn test_content_similarity_analysis() {
        let engine = MatchEngine::new(Box::new(MockAI), test_config());
        
        // 測試內容採樣和相似度計算
        let subtitles = vec![create_test_subtitle("test.srt", "test content")];
        let samples = engine.extract_content_samples(&subtitles).await.unwrap();
        
        assert!(!samples.is_empty());
        assert_eq!(samples[0].filename, "test");
        
        // 驗證內容預覽生成
        let preview = engine.create_content_preview("long content...");
        assert!(preview.len() <= engine.config.max_sample_length);
    }

    #[test]
    fn test_filename_language_detection() {
        let detector = LanguageDetector::new();
        
        // 測試語言檢測相似度
        let result = detector.detect_from_filename(Path::new("movie.tc.srt"));
        assert!(result.is_some());
        assert_eq!(result.unwrap().confidence, 0.8);
    }

    #[test]
    fn test_cache_key_generation() {
        let request = AnalysisRequest {
            video_files: vec!["video1.mp4".to_string()],
            subtitle_files: vec!["sub1.srt".to_string()],
            content_samples: vec![],
        };
        
        let key1 = AICache::generate_key(&request);
        let key2 = AICache::generate_key(&request);
        assert_eq!(key1, key2); // 同樣輸入應產生相同鍵值
        
        let mut different_request = request.clone();
        different_request.video_files.push("video2.mp4".to_string());
        let key3 = AICache::generate_key(&different_request);
        assert_ne!(key1, key3); // 不同輸入應產生不同鍵值
    }
}
```

#### 2.4.5 實作指導原則

1. **相似度計算標準化**: 所有相似度分數應標準化為 0.0-1.0 範圍
2. **快取策略**: 使用穩定的雜湊算法確保相同輸入產生相同鍵值
3. **閾值設定**: 基於專案現有模式，建議相似度閾值 >0.8 為高信心度
4. **效能考量**: 大型資料集使用分塊處理，避免記憶體溢出

這些程式碼範例為員工提供了具體的實作參考，確保語義搜尋功能與專案現有架構保持一致。
