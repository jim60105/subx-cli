# Product Backlog #19.4: æ¸¬è©¦åŸºç¤è¨­æ–½å„ªåŒ–

## é ˜åŸŸç¯„åœ
å„ªåŒ–æ¸¬è©¦åŸºç¤è¨­æ–½ã€æå‡æ¸¬è©¦å·¥å…·éˆçš„æ•ˆç‡èˆ‡å¯ç¶­è­·æ€§

## èƒŒæ™¯è„ˆçµ¡

éš¨è‘—æ¸¬è©¦è¦†è“‹ç‡çš„æå‡èˆ‡é…ç½®ç³»çµ±é‡æ§‹ï¼ˆBacklog #21ï¼‰ï¼Œéœ€è¦å¯¦ç”¨çš„æ¸¬è©¦å·¥å…·ä¾†æ”¯æ´ï¼š
- **æ¸¬è©¦å·¥å…·éˆå„ªåŒ–**: æå‡æ¸¬è©¦åŸ·è¡Œæ•ˆç‡ï¼Œæ”¯æ´ä¸¦è¡Œæ¸¬è©¦åŸ·è¡Œ
- **æ¸¬è©¦è³‡æ–™ç®¡ç†**: çµ±ä¸€æ¸¬è©¦è³‡æ–™ç”¢ç”Ÿèˆ‡ç®¡ç†ï¼Œæ”¯æ´ä¾è³´æ³¨å…¥é…ç½®
- **æ¸¬è©¦éš”é›¢æ©Ÿåˆ¶**: é…åˆæ–°é…ç½®ç³»çµ±å¯¦ç¾çœŸæ­£çš„æ¸¬è©¦éš”é›¢
- **CI/CD æ•´åˆ**: ç¢ºä¿å“è³ªé–€æª»

## èˆ‡ Backlog #21 çš„é—œè¯

æœ¬ backlog éœ€è¦èˆ‡ [Backlog #21: æ¶ˆé™¤ä¸å®‰å…¨é…ç½®ç®¡ç†å™¨é‡è¨­æ©Ÿåˆ¶](21-eliminate-unsafe-config-manager-backlog.md) å”èª¿åŸ·è¡Œï¼š

### ç›¸ä¾é—œä¿‚
- **é…ç½®ç³»çµ±é‡æ§‹**: #21 ç§»é™¤ `unsafe` ç¨‹å¼ç¢¼ä¸¦å¯¦ä½œä¾è³´æ³¨å…¥ï¼Œæœ¬ backlog çš„æ¸¬è©¦å·¥å…·éœ€è¦æ”¯æ´æ–°æ¶æ§‹
- **æ¸¬è©¦éš”é›¢æ©Ÿåˆ¶**: #21 å¯¦ç¾çœŸæ­£çš„æ¸¬è©¦éš”é›¢ï¼Œæœ¬ backlog çš„å·¥å…·éœ€è¦é…åˆé€™å€‹æ–°æ©Ÿåˆ¶
- **ä¸¦è¡Œæ¸¬è©¦èƒ½åŠ›**: #21 ç§»é™¤ `#[serial]` è¨»è§£ï¼Œæœ¬ backlog éœ€è¦é©—è­‰ä¸¦è¡Œæ¸¬è©¦çš„ç©©å®šæ€§

### å”èª¿åŸ·è¡Œå»ºè­°
1. **å„ªå…ˆå®Œæˆ #21.2-21.4**: ç¢ºä¿é…ç½®ç³»çµ±å’Œæ¸¬è©¦éš”é›¢æ©Ÿåˆ¶å°±ç·’
2. **åŒæ­¥é€²è¡Œæœ¬ backlog**: åœ¨ #21 æ¸¬è©¦é‡æ§‹éšæ®µåŒæ­¥é–‹ç™¼æ¸¬è©¦å·¥å…·
3. **æœ€çµ‚é©—è­‰**: ä½¿ç”¨æœ¬ backlog çš„å·¥å…·é©—è­‰ #21 çš„ä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§

## å®Œæˆé …ç›®

### ğŸ› ï¸ ç¬¬ä¸€éšæ®µï¼šæ¸¬è©¦å·¥å…·å¢å¼· (2-3 å¤©)

#### 1.1 CLI æ¸¬è©¦è¼”åŠ©å·¥å…·é–‹ç™¼
- [ ] **æŒ‡ä»¤åˆ—åƒæ•¸æ¸¬è©¦è¼”åŠ©å‡½å¼ï¼ˆæ”¯æ´ä¾è³´æ³¨å…¥é…ç½®ï¼‰**
  ```rust
  // tests/common/cli_helpers.rs
  use subx_cli::config::ConfigService;
  
  pub struct CLITestHelper {
      temp_dir: TempDir,
      test_files: Vec<PathBuf>,
      config_service: Box<dyn ConfigService>,
  }
  
  impl CLITestHelper {
      pub fn new() -> Self {
          Self {
              temp_dir: TempDir::new().unwrap(),
              test_files: Vec::new(),
              config_service: Box::new(TestConfigService::new()),
          }
      }
      
      pub fn with_config_service(mut self, config_service: Box<dyn ConfigService>) -> Self {
          self.config_service = config_service;
          self
      }
      
      pub async fn create_isolated_test_workspace(&mut self) -> &Path {
          let workspace = self.temp_dir.path();
          
          // å»ºç«‹æ¨™æº–æ¸¬è©¦æª”æ¡ˆçµæ§‹
          self.create_media_files(workspace).await;
          self.create_subtitle_files(workspace).await;
          self.create_config_file(workspace).await;
          
          // å»ºç«‹éš”é›¢çš„é…ç½®ç’°å¢ƒ
          self.setup_isolated_config(workspace).await;
          
          workspace
      }
      
      pub async fn run_command_with_config(&self, args: &[&str]) -> CommandResult {
          let mut cmd = Command::cargo_bin("subx-cli").unwrap();
          cmd.args(args);
          cmd.current_dir(&self.temp_dir);
          
          // è¨­å®šç’°å¢ƒè®Šæ•¸ä»¥ä½¿ç”¨æ¸¬è©¦é…ç½®
          cmd.env("SUBX_CONFIG_PATH", self.temp_dir.path().join("test_config.toml"));
          cmd.env("SUBX_TEST_MODE", "true");
          
          let output = cmd.output().unwrap();
          CommandResult {
              success: output.status.success(),
              stdout: String::from_utf8_lossy(&output.stdout).to_string(),
              stderr: String::from_utf8_lossy(&output.stderr).to_string(),
          }
      }
      
      pub fn assert_command_success(&self, result: &CommandResult) {
          if !result.success {
              panic!("Command failed:\nstdout: {}\nstderr: {}", 
                     result.stdout, result.stderr);
          }
      }
      
      async fn setup_isolated_config(&self, workspace: &Path) {
          // å»ºç«‹æ¸¬è©¦å°ˆç”¨é…ç½®æª”æ¡ˆ
          let config_content = format!(r#"
[general]
workspace = "{}"
log_level = "debug"

[test]
isolated = true
parallel_safe = true
"#, workspace.display());
          
          fs::write(workspace.join("test_config.toml"), config_content)
              .await
              .expect("Failed to create test config");
      }
  }
  
  /// æ¸¬è©¦å°ˆç”¨é…ç½®æœå‹™å¯¦ä½œ
  pub struct TestConfigService {
      config: TestConfig,
  }
  
  impl TestConfigService {
      pub fn new() -> Self {
          Self {
              config: TestConfig::default(),
          }
      }
      
      pub fn with_workspace(mut self, workspace: PathBuf) -> Self {
          self.config.workspace = workspace;
          self
      }
  }
  
  impl ConfigService for TestConfigService {
      fn get_workspace(&self) -> &Path {
          &self.config.workspace
      }
      
      fn is_parallel_safe(&self) -> bool {
          true // æ¸¬è©¦ç’°å¢ƒç¸½æ˜¯ä¸¦è¡Œå®‰å…¨çš„
      }
  }
  ```

- [ ] **è¼¸å‡ºæ•ç²èˆ‡é©—è­‰å·¥å…·**
  ```rust
  pub struct OutputValidator {
      patterns: Vec<regex::Regex>,
      anti_patterns: Vec<regex::Regex>,
  }
  
  impl OutputValidator {
      pub fn new() -> Self {
          Self {
              patterns: Vec::new(),
              anti_patterns: Vec::new(),
          }
      }
      
      pub fn expect_pattern(mut self, pattern: &str) -> Self {
          self.patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn reject_pattern(mut self, pattern: &str) -> Self {
          self.anti_patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn validate(&self, output: &str) -> ValidationResult {
          let mut result = ValidationResult::new();
          
          // æª¢æŸ¥æœŸæœ›æ¨¡å¼
          for pattern in &self.patterns {
              if !pattern.is_match(output) {
                  result.add_error(format!("Missing expected pattern: {}", pattern));
              }
          }
          
          // æª¢æŸ¥æ’é™¤æ¨¡å¼
          for pattern in &self.anti_patterns {
              if pattern.is_match(output) {
                  result.add_error(format!("Found rejected pattern: {}", pattern));
              }
          }
          
          result
      }
  }
  ```

- [ ] **è‡¨æ™‚æª”æ¡ˆç®¡ç†å·¥å…·ï¼ˆæ”¯æ´ä¸¦è¡Œæ¸¬è©¦éš”é›¢ï¼‰**
  ```rust
  pub struct TestFileManager {
      temp_dirs: Vec<TempDir>,
      cleanup_on_drop: bool,
      isolation_enabled: bool,
  }
  
  impl TestFileManager {
      pub fn new() -> Self {
          Self {
              temp_dirs: Vec::new(),
              cleanup_on_drop: true,
              isolation_enabled: true, // é è¨­å•Ÿç”¨éš”é›¢æ¨¡å¼
          }
      }
      
      pub fn preserve_on_failure(mut self) -> Self {
          self.cleanup_on_drop = false;
          self
      }
      
      pub fn enable_parallel_isolation(mut self) -> Self {
          self.isolation_enabled = true;
          self
      }
      
      pub async fn create_isolated_test_directory(&mut self, name: &str) -> &Path {
          let temp_dir = TempDir::new().unwrap();
          let path = temp_dir.path();
          
          if self.isolation_enabled {
              // ç‚ºæ¯å€‹æ¸¬è©¦å»ºç«‹å®Œå…¨éš”é›¢çš„ç’°å¢ƒ
              self.setup_isolated_environment(path, name).await;
          }
          
          // ç‚ºé™¤éŒ¯æ–¹ä¾¿ï¼Œå»ºç«‹ç¬¦è™Ÿé€£çµ
          if cfg!(debug_assertions) {
              let debug_path = format!("/tmp/subx_test_{}_{}", name, std::process::id());
              let _ = std::os::unix::fs::symlink(path, &debug_path);
              println!("Isolated test directory: {}", debug_path);
          }
          
          self.temp_dirs.push(temp_dir);
          path
      }
      
      async fn setup_isolated_environment(&self, path: &Path, test_name: &str) {
          // å»ºç«‹æ¸¬è©¦å°ˆç”¨é…ç½®ï¼Œç¢ºä¿æ²’æœ‰ç‹€æ…‹å…±äº«
          let config_content = format!(r#"
[general]
workspace = "{}"
log_level = "debug"

[test]
name = "{}"
isolated = true
parallel_safe = true
timestamp = "{}"
"#, 
              path.display(), 
              test_name,
              std::time::SystemTime::now()
                  .duration_since(std::time::UNIX_EPOCH)
                  .unwrap()
                  .as_millis()
          );
          
          fs::write(path.join("isolated_config.toml"), config_content)
              .await
              .expect("Failed to create isolated config");
      }
  }
  ```

#### 1.2 æ¨¡æ“¬æœå‹™æ“´å……
- [ ] **éŸ³è¨Šæª”æ¡ˆæ¨¡æ“¬å™¨**
  ```rust
  pub struct AudioMockGenerator {
      sample_rate: u32,
      duration: f64,
  }
  
  impl AudioMockGenerator {
      pub fn new(sample_rate: u32) -> Self {
          Self {
              sample_rate,
              duration: 5.0, // é è¨­ 5 ç§’
          }
      }
      
      pub fn with_duration(mut self, duration: f64) -> Self {
          self.duration = duration;
          self
      }
      
      pub async fn generate_dialogue_audio(&self, path: &Path) -> Result<AudioMetadata> {
          // ç”ŸæˆåŒ…å«å°è©±å’ŒéœéŸ³çš„éŸ³è¨Š
          let dialogue_segments = vec![
              DialogueSegment { start: 0.0, end: 1.0, is_speech: false },
              DialogueSegment { start: 1.0, end: 3.0, is_speech: true },
              DialogueSegment { start: 3.0, end: 3.5, is_speech: false },
              DialogueSegment { start: 3.5, end: 5.0, is_speech: true },
          ];
          
          let samples = self.generate_samples_from_segments(&dialogue_segments);
          self.write_wav_file(path, &samples).await?;
          
          Ok(AudioMetadata {
              duration: self.duration,
              sample_rate: self.sample_rate,
              channels: 1,
              dialogue_segments,
          })
      }
      
      pub async fn generate_music_audio(&self, path: &Path) -> Result<()> {
          // ç”Ÿæˆç´”éŸ³æ¨‚éŸ³è¨Šï¼ˆç„¡å°è©±ï¼‰
          let samples = self.generate_sine_wave(440.0); // A4 éŸ³ç¬¦
          self.write_wav_file(path, &samples).await
      }
  }
  ```

- [ ] **æª”æ¡ˆç³»çµ±æ¨¡æ“¬å™¨å¢å¼·**
  ```rust
  pub struct FileSystemMock {
      root: TempDir,
      permissions: HashMap<PathBuf, u32>,
      readonly_files: HashSet<PathBuf>,
  }
  
  impl FileSystemMock {
      pub fn new() -> Self {
          Self {
              root: TempDir::new().unwrap(),
              permissions: HashMap::new(),
              readonly_files: HashSet::new(),
          }
      }
      
      pub fn create_readonly_file(&mut self, path: &str, content: &str) -> Result<PathBuf> {
          let full_path = self.root.path().join(path);
          fs::write(&full_path, content)?;
          
          // è¨­å®šç‚ºå”¯è®€
          let mut perms = fs::metadata(&full_path)?.permissions();
          perms.set_readonly(true);
          fs::set_permissions(&full_path, perms)?;
          
          self.readonly_files.insert(full_path.clone());
          Ok(full_path)
      }
      
      pub fn simulate_permission_error(&mut self, path: &str) {
          let full_path = self.root.path().join(path);
          self.permissions.insert(full_path, 0o000); // ç„¡ä»»ä½•æ¬Šé™
      }
  }
  ```

#### 1.3 æ¸¬è©¦è³‡æ–™ç”¢ç”Ÿå™¨å‡ç´š
- [ ] **å„ç¨®æ ¼å¼å­—å¹•æª”æ¡ˆç”¢ç”Ÿå™¨**
  ```rust
  pub struct SubtitleGenerator {
      encoding: Charset,
      format: SubtitleFormat,
      entries: Vec<SubtitleEntry>,
  }
  
  impl SubtitleGenerator {
      pub fn new(format: SubtitleFormat) -> Self {
          Self {
              encoding: Charset::Utf8,
              format,
              entries: Vec::new(),
          }
      }
      
      pub fn with_encoding(mut self, encoding: Charset) -> Self {
          self.encoding = encoding;
          self
      }
      
      pub fn add_entry(mut self, start: f64, end: f64, text: &str) -> Self {
          self.entries.push(SubtitleEntry {
              start_time: Duration::from_secs_f64(start),
              end_time: Duration::from_secs_f64(end),
              text: text.to_string(),
              ..Default::default()
          });
          self
      }
      
      pub fn generate_typical_movie(mut self) -> Self {
          // ç”Ÿæˆå…¸å‹é›»å½±å­—å¹•æ¨¡å¼
          let dialogues = vec![
              (5.0, 8.0, "é›»å½±é–‹å§‹äº†"),
              (10.0, 15.0, "é€™æ˜¯ç¬¬ä¸€æ®µå°è©±ï¼Œæ¯”è¼ƒé•·ä¸€é»çš„å…§å®¹"),
              (18.0, 20.0, "çŸ­å°è©±"),
              (25.0, 30.0, "å¦ä¸€å€‹è§’è‰²çš„å›æ‡‰"),
          ];
          
          for (start, end, text) in dialogues {
              self = self.add_entry(start, end, text);
          }
          
          self
      }
      
      pub async fn save_to_file(&self, path: &Path) -> Result<()> {
          let content = match self.format {
              SubtitleFormat::Srt => self.generate_srt_content(),
              SubtitleFormat::Ass => self.generate_ass_content(),
              SubtitleFormat::Vtt => self.generate_vtt_content(),
          };
          
          let encoded_content = self.encode_content(&content)?;
          fs::write(path, encoded_content).await
      }
  }
  ```

### ï¿½ ç¬¬äºŒéšæ®µï¼šCI/CD æ•´åˆå¼·åŒ– (1-2 å¤©)

#### 2.1 æ•´åˆè‡³ç¾æœ‰ GitHub Actions å·¥ä½œæµç¨‹
- [ ] **æ•´åˆè¦†è“‹ç‡é–€æª»æª¢æŸ¥è‡³ç¾æœ‰å·¥ä½œæµç¨‹**
  > åœ¨ç¾æœ‰çš„ `.github/workflows/build-test-audit-coverage.yml` ä¸­çš„ `coverage` job æ·»åŠ è¦†è“‹ç‡é–€æª»æª¢æŸ¥
  
  ```yaml
  # åœ¨ coverage job çš„æœ€å¾Œæ·»åŠ 
  - name: Check coverage threshold with standard script
    run: ./scripts/check_coverage.sh
    
  # å¯é¸ï¼šè©³ç´°è¦†è“‹ç‡å ±å‘Š
  - name: Generate detailed coverage report (if needed)
    run: cargo llvm-cov --all-features --workspace --json --summary-only -q
  ```

- [ ] **ä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§é©—è­‰**
  > åœ¨ç¾æœ‰çš„ `test` job ä¸­æ·»åŠ ä¸¦è¡Œæ¸¬è©¦é©—è­‰æ­¥é©Ÿï¼Œç¢ºä¿é…ç½®ç³»çµ±é‡æ§‹å¾Œçš„æ¸¬è©¦éš”é›¢
  
  ```yaml
  # åœ¨ test job ä¸­æ·»åŠ 
  - name: Run parallel test stability validation
    run: |
      # å¤šæ¬¡åŸ·è¡Œä¸¦è¡Œæ¸¬è©¦ä»¥é©—è­‰ç©©å®šæ€§
      for i in {1..5}; do
        echo "Parallel test run $i/5"
        cargo test --all-features --workspace -- --test-threads=0
      done
    
  - name: Run test infrastructure validation
    run: cargo test --test test_infrastructure_validation --verbose
  ```

#### 2.2 ä½¿ç”¨ç¾æœ‰å·¥å…·èˆ‡å·¥ä½œæµç¨‹
- [x] **è¦†è“‹ç‡æª¢æŸ¥**: ä½¿ç”¨ç¾æœ‰çš„ `scripts/check_coverage.sh`
- [x] **ç¾æœ‰ CI/CD**: å·²æœ‰å®Œæ•´çš„ `build-test-audit-coverage.yml` å·¥ä½œæµç¨‹
- [ ] **æ•´åˆæ¸¬è©¦åŸºç¤è¨­æ–½**: å°‡æ–°çš„æ¸¬è©¦å·¥å…·æ•´åˆè‡³ç¾æœ‰å·¥ä½œæµç¨‹ä¸­
- [ ] **ä¸¦è¡Œæ¸¬è©¦é©—è­‰**: ç¢ºä¿é…ç½®ç³»çµ±é‡æ§‹ï¼ˆBacklog #21ï¼‰å¾Œçš„æ¸¬è©¦ç©©å®šæ€§

## ğŸ“Š å¯¦ä½œæŒ‡å—

### ç°¡åŒ–çš„æª”æ¡ˆçµæ§‹
```
tests/common/
â”œâ”€â”€ cli_helpers.rs              # CLI æ¸¬è©¦è¼”åŠ©ï¼ˆæ”¯æ´ä¾è³´æ³¨å…¥ï¼‰
â”œâ”€â”€ mock_generators.rs          # æ¨¡æ“¬è³‡æ–™ç”Ÿæˆ  
â”œâ”€â”€ file_generators.rs          # æª”æ¡ˆç”Ÿæˆå™¨ï¼ˆæ”¯æ´éš”é›¢é…ç½®ï¼‰
â”œâ”€â”€ validators.rs               # æ¸¬è©¦é©—è­‰å·¥å…·
â””â”€â”€ config_services.rs          # æ¸¬è©¦é…ç½®æœå‹™å¯¦ä½œ

scripts/
â”œâ”€â”€ check_coverage.sh           # è¦†è“‹ç‡æª¢æŸ¥è…³æœ¬ (å·²å­˜åœ¨)
â””â”€â”€ setup_test_env.sh          # æ¸¬è©¦ç’°å¢ƒè¨­å®š (å¦‚éœ€è¦)
```

### é…ç½®æª”æ¡ˆ
```toml
# Cargo.toml æ¸¬è©¦é…ç½®
[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"  
tempfile = "3.0"
regex = "1.10"
config = "0.14"                 # æ”¯æ´æ–°é…ç½®ç³»çµ±
```

## ğŸ“ˆ é æœŸæˆæœ

### åŸºç¤è¨­æ–½æ”¹å–„
- **æ¸¬è©¦åŸ·è¡Œæ•ˆç‡**: æå‡ 30%ï¼ˆå—ç›Šæ–¼ä¸¦è¡Œæ¸¬è©¦ï¼‰
- **æ¸¬è©¦å¯ç¶­è­·æ€§**: çµ±ä¸€æ¸¬è©¦å·¥å…·èˆ‡æ¨¡å¼ï¼Œæ”¯æ´ä¾è³´æ³¨å…¥
- **æ¸¬è©¦éš”é›¢**: çœŸæ­£çš„æ¸¬è©¦éš”é›¢ï¼Œç„¡ç‹€æ…‹å…±äº«
- **CI/CD æ•´åˆ**: åŸºæœ¬å“è³ªé–€æª»èˆ‡ä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§é©—è­‰

### é–‹ç™¼é«”é©—æå‡
- **æ¸¬è©¦ç·¨å¯«æ•ˆç‡**: æå‡ 40%ï¼ˆç„¡éœ€ `#[serial]` è¨»è§£ï¼‰
- **é™¤éŒ¯ä¾¿åˆ©æ€§**: æ¸…æ™°çš„æ¸¬è©¦è¼”åŠ©å·¥å…·èˆ‡éš”é›¢ç’°å¢ƒ
- **ä¸¦è¡ŒåŸ·è¡Œ**: æ¸¬è©¦å¯å®Œå…¨ä¸¦è¡ŒåŸ·è¡Œï¼Œå¤§å¹…ç¸®çŸ­åŸ·è¡Œæ™‚é–“
- **å“è³ªä¿è­‰**: åŸºæœ¬çš„è‡ªå‹•åŒ–æª¢æŸ¥èˆ‡ç©©å®šæ€§é©—è­‰

### è¦†è“‹ç‡ç›£æ§
ä½¿ç”¨ `scripts/check_coverage.sh` ä½œç‚ºä¸»è¦è¦†è“‹ç‡æª¢æŸ¥å·¥å…·ï¼š
```bash
# å¿«é€Ÿè¦†è“‹ç‡æª¢æŸ¥ (æ¨è–¦)
./scripts/check_coverage.sh

# è©³ç´°è¦†è“‹ç‡åˆ†æ (é€²éšä½¿ç”¨)
cargo llvm-cov --all-features --workspace --json --summary-only -q
```

## ğŸ¯ æˆåŠŸæ¨™æº–

1. **æ¸¬è©¦å·¥å…·éˆå¯¦ç”¨æ€§**: æ¶µè“‹ CLIã€æ¨¡æ“¬ã€é©—è­‰çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œæ”¯æ´ä¾è³´æ³¨å…¥é…ç½®
2. **CI/CD åŸºæœ¬æ•´åˆ**: è¦†è“‹ç‡æª¢æŸ¥ã€ç¨‹å¼ç¢¼å“è³ªæª¢æŸ¥èˆ‡ä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§é©—è­‰
3. **æ¸¬è©¦å¯ç¶­è­·æ€§**: çµ±ä¸€ä¸”ç°¡æ½”çš„æ¸¬è©¦å·¥å…·ï¼Œæ”¯æ´å®Œå…¨æ¸¬è©¦éš”é›¢
4. **è¦†è“‹ç‡ç›£æ§**: `scripts/check_coverage.sh` æ•´åˆåˆ°æ¨™æº–å·¥ä½œæµç¨‹
5. **ä¸¦è¡Œæ¸¬è©¦æ”¯æ´**: é…åˆ Backlog #21 å¯¦ç¾çš„é…ç½®ç³»çµ±ï¼Œç¢ºä¿æ¸¬è©¦å¯å®‰å…¨ä¸¦è¡ŒåŸ·è¡Œ

---

**å»ºç«‹æ—¥æœŸ**: 2025-06-09  
**é æœŸå®Œæˆ**: 2025-06-15 (6 å¤©)  
**å‰ç½®æ¢ä»¶**: [#19.3 åŒæ­¥èˆ‡ä¸¦è¡Œæ¸¬è©¦](19.3-sync-parallel-testing.md) å®Œæˆ  
**å¾ŒçºŒå·¥ä½œ**: æŒçºŒæ¸¬è©¦ç¶­è­·èˆ‡å„ªåŒ–
