# Product Backlog #19.4: 測試基礎設施優化

## 領域範圍
優化測試基礎設施、提升測試工具鏈的效率與可維護性

## 背景脈絡

隨著測試覆蓋率的提升與配置系統重構（Backlog #21），需要實用的測試工具來支援：
- **測試工具鏈優化**: 提升測試執行效率，支援並行測試執行
- **測試資料管理**: 統一測試資料產生與管理，支援依賴注入配置
- **測試隔離機制**: 配合新配置系統實現真正的測試隔離
- **CI/CD 整合**: 確保品質門檻

## 與 Backlog #21 的關聯

本 backlog 需要與 [Backlog #21: 消除不安全配置管理器重設機制](21-eliminate-unsafe-config-manager-backlog.md) 協調執行：

### 相依關係
- **配置系統重構**: #21 移除 `unsafe` 程式碼並實作依賴注入，本 backlog 的測試工具需要支援新架構
- **測試隔離機制**: #21 實現真正的測試隔離，本 backlog 的工具需要配合這個新機制
- **並行測試能力**: #21 移除 `#[serial]` 註解，本 backlog 需要驗證並行測試的穩定性

### 協調執行建議
1. **優先完成 #21.2-21.4**: 確保配置系統和測試隔離機制就緒
2. **同步進行本 backlog**: 在 #21 測試重構階段同步開發測試工具
3. **最終驗證**: 使用本 backlog 的工具驗證 #21 的並行測試穩定性

## 完成項目

### 🛠️ 第一階段：測試工具增強 (2-3 天)

#### 1.1 CLI 測試輔助工具開發
- [ ] **指令列參數測試輔助函式（支援依賴注入配置）**
  ```rust
  // tests/common/cli_helpers.rs
  use subx_cli::config::ConfigService;
  
  pub struct CLITestHelper {
      temp_dir: TempDir,
      test_files: Vec<PathBuf>,
      config_service: Box<dyn ConfigService>,
  }
  
  impl CLITestHelper {
      pub fn new() -> Self {
          Self {
              temp_dir: TempDir::new().unwrap(),
              test_files: Vec::new(),
              config_service: Box::new(TestConfigService::new()),
          }
      }
      
      pub fn with_config_service(mut self, config_service: Box<dyn ConfigService>) -> Self {
          self.config_service = config_service;
          self
      }
      
      pub async fn create_isolated_test_workspace(&mut self) -> &Path {
          let workspace = self.temp_dir.path();
          
          // 建立標準測試檔案結構
          self.create_media_files(workspace).await;
          self.create_subtitle_files(workspace).await;
          self.create_config_file(workspace).await;
          
          // 建立隔離的配置環境
          self.setup_isolated_config(workspace).await;
          
          workspace
      }
      
      pub async fn run_command_with_config(&self, args: &[&str]) -> CommandResult {
          let mut cmd = Command::cargo_bin("subx-cli").unwrap();
          cmd.args(args);
          cmd.current_dir(&self.temp_dir);
          
          // 設定環境變數以使用測試配置
          cmd.env("SUBX_CONFIG_PATH", self.temp_dir.path().join("test_config.toml"));
          cmd.env("SUBX_TEST_MODE", "true");
          
          let output = cmd.output().unwrap();
          CommandResult {
              success: output.status.success(),
              stdout: String::from_utf8_lossy(&output.stdout).to_string(),
              stderr: String::from_utf8_lossy(&output.stderr).to_string(),
          }
      }
      
      pub fn assert_command_success(&self, result: &CommandResult) {
          if !result.success {
              panic!("Command failed:\nstdout: {}\nstderr: {}", 
                     result.stdout, result.stderr);
          }
      }
      
      async fn setup_isolated_config(&self, workspace: &Path) {
          // 建立測試專用配置檔案
          let config_content = format!(r#"
[general]
workspace = "{}"
log_level = "debug"

[test]
isolated = true
parallel_safe = true
"#, workspace.display());
          
          fs::write(workspace.join("test_config.toml"), config_content)
              .await
              .expect("Failed to create test config");
      }
  }
  
  /// 測試專用配置服務實作
  pub struct TestConfigService {
      config: TestConfig,
  }
  
  impl TestConfigService {
      pub fn new() -> Self {
          Self {
              config: TestConfig::default(),
          }
      }
      
      pub fn with_workspace(mut self, workspace: PathBuf) -> Self {
          self.config.workspace = workspace;
          self
      }
  }
  
  impl ConfigService for TestConfigService {
      fn get_workspace(&self) -> &Path {
          &self.config.workspace
      }
      
      fn is_parallel_safe(&self) -> bool {
          true // 測試環境總是並行安全的
      }
  }
  ```

- [ ] **輸出捕獲與驗證工具**
  ```rust
  pub struct OutputValidator {
      patterns: Vec<regex::Regex>,
      anti_patterns: Vec<regex::Regex>,
  }
  
  impl OutputValidator {
      pub fn new() -> Self {
          Self {
              patterns: Vec::new(),
              anti_patterns: Vec::new(),
          }
      }
      
      pub fn expect_pattern(mut self, pattern: &str) -> Self {
          self.patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn reject_pattern(mut self, pattern: &str) -> Self {
          self.anti_patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn validate(&self, output: &str) -> ValidationResult {
          let mut result = ValidationResult::new();
          
          // 檢查期望模式
          for pattern in &self.patterns {
              if !pattern.is_match(output) {
                  result.add_error(format!("Missing expected pattern: {}", pattern));
              }
          }
          
          // 檢查排除模式
          for pattern in &self.anti_patterns {
              if pattern.is_match(output) {
                  result.add_error(format!("Found rejected pattern: {}", pattern));
              }
          }
          
          result
      }
  }
  ```

- [ ] **臨時檔案管理工具（支援並行測試隔離）**
  ```rust
  pub struct TestFileManager {
      temp_dirs: Vec<TempDir>,
      cleanup_on_drop: bool,
      isolation_enabled: bool,
  }
  
  impl TestFileManager {
      pub fn new() -> Self {
          Self {
              temp_dirs: Vec::new(),
              cleanup_on_drop: true,
              isolation_enabled: true, // 預設啟用隔離模式
          }
      }
      
      pub fn preserve_on_failure(mut self) -> Self {
          self.cleanup_on_drop = false;
          self
      }
      
      pub fn enable_parallel_isolation(mut self) -> Self {
          self.isolation_enabled = true;
          self
      }
      
      pub async fn create_isolated_test_directory(&mut self, name: &str) -> &Path {
          let temp_dir = TempDir::new().unwrap();
          let path = temp_dir.path();
          
          if self.isolation_enabled {
              // 為每個測試建立完全隔離的環境
              self.setup_isolated_environment(path, name).await;
          }
          
          // 為除錯方便，建立符號連結
          if cfg!(debug_assertions) {
              let debug_path = format!("/tmp/subx_test_{}_{}", name, std::process::id());
              let _ = std::os::unix::fs::symlink(path, &debug_path);
              println!("Isolated test directory: {}", debug_path);
          }
          
          self.temp_dirs.push(temp_dir);
          path
      }
      
      async fn setup_isolated_environment(&self, path: &Path, test_name: &str) {
          // 建立測試專用配置，確保沒有狀態共享
          let config_content = format!(r#"
[general]
workspace = "{}"
log_level = "debug"

[test]
name = "{}"
isolated = true
parallel_safe = true
timestamp = "{}"
"#, 
              path.display(), 
              test_name,
              std::time::SystemTime::now()
                  .duration_since(std::time::UNIX_EPOCH)
                  .unwrap()
                  .as_millis()
          );
          
          fs::write(path.join("isolated_config.toml"), config_content)
              .await
              .expect("Failed to create isolated config");
      }
  }
  ```

#### 1.2 模擬服務擴充
- [ ] **音訊檔案模擬器**
  ```rust
  pub struct AudioMockGenerator {
      sample_rate: u32,
      duration: f64,
  }
  
  impl AudioMockGenerator {
      pub fn new(sample_rate: u32) -> Self {
          Self {
              sample_rate,
              duration: 5.0, // 預設 5 秒
          }
      }
      
      pub fn with_duration(mut self, duration: f64) -> Self {
          self.duration = duration;
          self
      }
      
      pub async fn generate_dialogue_audio(&self, path: &Path) -> Result<AudioMetadata> {
          // 生成包含對話和靜音的音訊
          let dialogue_segments = vec![
              DialogueSegment { start: 0.0, end: 1.0, is_speech: false },
              DialogueSegment { start: 1.0, end: 3.0, is_speech: true },
              DialogueSegment { start: 3.0, end: 3.5, is_speech: false },
              DialogueSegment { start: 3.5, end: 5.0, is_speech: true },
          ];
          
          let samples = self.generate_samples_from_segments(&dialogue_segments);
          self.write_wav_file(path, &samples).await?;
          
          Ok(AudioMetadata {
              duration: self.duration,
              sample_rate: self.sample_rate,
              channels: 1,
              dialogue_segments,
          })
      }
      
      pub async fn generate_music_audio(&self, path: &Path) -> Result<()> {
          // 生成純音樂音訊（無對話）
          let samples = self.generate_sine_wave(440.0); // A4 音符
          self.write_wav_file(path, &samples).await
      }
  }
  ```

- [ ] **檔案系統模擬器增強**
  ```rust
  pub struct FileSystemMock {
      root: TempDir,
      permissions: HashMap<PathBuf, u32>,
      readonly_files: HashSet<PathBuf>,
  }
  
  impl FileSystemMock {
      pub fn new() -> Self {
          Self {
              root: TempDir::new().unwrap(),
              permissions: HashMap::new(),
              readonly_files: HashSet::new(),
          }
      }
      
      pub fn create_readonly_file(&mut self, path: &str, content: &str) -> Result<PathBuf> {
          let full_path = self.root.path().join(path);
          fs::write(&full_path, content)?;
          
          // 設定為唯讀
          let mut perms = fs::metadata(&full_path)?.permissions();
          perms.set_readonly(true);
          fs::set_permissions(&full_path, perms)?;
          
          self.readonly_files.insert(full_path.clone());
          Ok(full_path)
      }
      
      pub fn simulate_permission_error(&mut self, path: &str) {
          let full_path = self.root.path().join(path);
          self.permissions.insert(full_path, 0o000); // 無任何權限
      }
  }
  ```

#### 1.3 測試資料產生器升級
- [ ] **各種格式字幕檔案產生器**
  ```rust
  pub struct SubtitleGenerator {
      encoding: Charset,
      format: SubtitleFormat,
      entries: Vec<SubtitleEntry>,
  }
  
  impl SubtitleGenerator {
      pub fn new(format: SubtitleFormat) -> Self {
          Self {
              encoding: Charset::Utf8,
              format,
              entries: Vec::new(),
          }
      }
      
      pub fn with_encoding(mut self, encoding: Charset) -> Self {
          self.encoding = encoding;
          self
      }
      
      pub fn add_entry(mut self, start: f64, end: f64, text: &str) -> Self {
          self.entries.push(SubtitleEntry {
              start_time: Duration::from_secs_f64(start),
              end_time: Duration::from_secs_f64(end),
              text: text.to_string(),
              ..Default::default()
          });
          self
      }
      
      pub fn generate_typical_movie(mut self) -> Self {
          // 生成典型電影字幕模式
          let dialogues = vec![
              (5.0, 8.0, "電影開始了"),
              (10.0, 15.0, "這是第一段對話，比較長一點的內容"),
              (18.0, 20.0, "短對話"),
              (25.0, 30.0, "另一個角色的回應"),
          ];
          
          for (start, end, text) in dialogues {
              self = self.add_entry(start, end, text);
          }
          
          self
      }
      
      pub async fn save_to_file(&self, path: &Path) -> Result<()> {
          let content = match self.format {
              SubtitleFormat::Srt => self.generate_srt_content(),
              SubtitleFormat::Ass => self.generate_ass_content(),
              SubtitleFormat::Vtt => self.generate_vtt_content(),
          };
          
          let encoded_content = self.encode_content(&content)?;
          fs::write(path, encoded_content).await
      }
  }
  ```

### � 第二階段：CI/CD 整合強化 (1-2 天)

#### 2.1 整合至現有 GitHub Actions 工作流程
- [ ] **整合覆蓋率門檻檢查至現有工作流程**
  > 在現有的 `.github/workflows/build-test-audit-coverage.yml` 中的 `coverage` job 添加覆蓋率門檻檢查
  
  ```yaml
  # 在 coverage job 的最後添加
  - name: Check coverage threshold with standard script
    run: ./scripts/check_coverage.sh
    
  # 可選：詳細覆蓋率報告
  - name: Generate detailed coverage report (if needed)
    run: cargo llvm-cov --all-features --workspace --json --summary-only -q
  ```

- [ ] **並行測試穩定性驗證**
  > 在現有的 `test` job 中添加並行測試驗證步驟，確保配置系統重構後的測試隔離
  
  ```yaml
  # 在 test job 中添加
  - name: Run parallel test stability validation
    run: |
      # 多次執行並行測試以驗證穩定性
      for i in {1..5}; do
        echo "Parallel test run $i/5"
        cargo test --all-features --workspace -- --test-threads=0
      done
    
  - name: Run test infrastructure validation
    run: cargo test --test test_infrastructure_validation --verbose
  ```

#### 2.2 使用現有工具與工作流程
- [x] **覆蓋率檢查**: 使用現有的 `scripts/check_coverage.sh`
- [x] **現有 CI/CD**: 已有完整的 `build-test-audit-coverage.yml` 工作流程
- [ ] **整合測試基礎設施**: 將新的測試工具整合至現有工作流程中
- [ ] **並行測試驗證**: 確保配置系統重構（Backlog #21）後的測試穩定性

## 📊 實作指南

### 簡化的檔案結構
```
tests/common/
├── cli_helpers.rs              # CLI 測試輔助（支援依賴注入）
├── mock_generators.rs          # 模擬資料生成  
├── file_generators.rs          # 檔案生成器（支援隔離配置）
├── validators.rs               # 測試驗證工具
└── config_services.rs          # 測試配置服務實作

scripts/
├── check_coverage.sh           # 覆蓋率檢查腳本 (已存在)
└── setup_test_env.sh          # 測試環境設定 (如需要)
```

### 配置檔案
```toml
# Cargo.toml 測試配置
[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"  
tempfile = "3.0"
regex = "1.10"
config = "0.14"                 # 支援新配置系統
```

## 📈 預期成果

### 基礎設施改善
- **測試執行效率**: 提升 30%（受益於並行測試）
- **測試可維護性**: 統一測試工具與模式，支援依賴注入
- **測試隔離**: 真正的測試隔離，無狀態共享
- **CI/CD 整合**: 基本品質門檻與並行測試穩定性驗證

### 開發體驗提升
- **測試編寫效率**: 提升 40%（無需 `#[serial]` 註解）
- **除錯便利性**: 清晰的測試輔助工具與隔離環境
- **並行執行**: 測試可完全並行執行，大幅縮短執行時間
- **品質保證**: 基本的自動化檢查與穩定性驗證

### 覆蓋率監控
使用 `scripts/check_coverage.sh` 作為主要覆蓋率檢查工具：
```bash
# 快速覆蓋率檢查 (推薦)
./scripts/check_coverage.sh

# 詳細覆蓋率分析 (進階使用)
cargo llvm-cov --all-features --workspace --json --summary-only -q
```

## 🎯 成功標準

1. **測試工具鏈實用性**: 涵蓋 CLI、模擬、驗證的核心功能，支援依賴注入配置
2. **CI/CD 基本整合**: 覆蓋率檢查、程式碼品質檢查與並行測試穩定性驗證
3. **測試可維護性**: 統一且簡潔的測試工具，支援完全測試隔離
4. **覆蓋率監控**: `scripts/check_coverage.sh` 整合到標準工作流程
5. **並行測試支援**: 配合 Backlog #21 實現的配置系統，確保測試可安全並行執行

---

**建立日期**: 2025-06-09  
**預期完成**: 2025-06-15 (6 天)  
**前置條件**: [#19.3 同步與並行測試](19.3-sync-parallel-testing.md) 完成  
**後續工作**: 持續測試維護與優化
