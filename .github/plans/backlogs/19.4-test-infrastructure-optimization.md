# Product Backlog #19.4: 測試基礎設施優化

## 領域範圍
優化測試基礎設施、建立自動化監控系統、提升測試工具鏈的效率與可維護性

## 背景脈絡

隨著測試覆蓋率的提升，需要對應的基礎設施來支援：
- **測試工具鏈優化**: 提升測試執行效率
- **自動化監控**: 覆蓋率趨勢追蹤與預警
- **測試資料管理**: 統一測試資料產生與管理
- **CI/CD 整合**: 確保品質門檻

## 完成項目

### 🛠️ 第一階段：測試工具增強 (2-3 天)

#### 1.1 CLI 測試輔助工具開發
- [ ] **指令列參數測試輔助函式**
  ```rust
  // tests/common/cli_helpers.rs
  pub struct CLITestHelper {
      temp_dir: TempDir,
      test_files: Vec<PathBuf>,
  }
  
  impl CLITestHelper {
      pub fn new() -> Self {
          Self {
              temp_dir: TempDir::new().unwrap(),
              test_files: Vec::new(),
          }
      }
      
      pub async fn create_test_workspace(&mut self) -> &Path {
          let workspace = self.temp_dir.path();
          
          // 建立標準測試檔案結構
          self.create_media_files(workspace).await;
          self.create_subtitle_files(workspace).await;
          self.create_config_file(workspace).await;
          
          workspace
      }
      
      pub async fn run_command(&self, args: &[&str]) -> CommandResult {
          let mut cmd = Command::cargo_bin("subx-cli").unwrap();
          cmd.args(args);
          cmd.current_dir(&self.temp_dir);
          
          let output = cmd.output().unwrap();
          CommandResult {
              success: output.status.success(),
              stdout: String::from_utf8_lossy(&output.stdout).to_string(),
              stderr: String::from_utf8_lossy(&output.stderr).to_string(),
          }
      }
      
      pub fn assert_command_success(&self, result: &CommandResult) {
          if !result.success {
              panic!("Command failed:\nstdout: {}\nstderr: {}", 
                     result.stdout, result.stderr);
          }
      }
  }
  ```

- [ ] **輸出捕獲與驗證工具**
  ```rust
  pub struct OutputValidator {
      patterns: Vec<regex::Regex>,
      anti_patterns: Vec<regex::Regex>,
  }
  
  impl OutputValidator {
      pub fn new() -> Self {
          Self {
              patterns: Vec::new(),
              anti_patterns: Vec::new(),
          }
      }
      
      pub fn expect_pattern(mut self, pattern: &str) -> Self {
          self.patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn reject_pattern(mut self, pattern: &str) -> Self {
          self.anti_patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn validate(&self, output: &str) -> ValidationResult {
          let mut result = ValidationResult::new();
          
          // 檢查期望模式
          for pattern in &self.patterns {
              if !pattern.is_match(output) {
                  result.add_error(format!("Missing expected pattern: {}", pattern));
              }
          }
          
          // 檢查排除模式
          for pattern in &self.anti_patterns {
              if pattern.is_match(output) {
                  result.add_error(format!("Found rejected pattern: {}", pattern));
              }
          }
          
          result
      }
  }
  ```

- [ ] **臨時檔案管理工具**
  ```rust
  pub struct TestFileManager {
      temp_dirs: Vec<TempDir>,
      cleanup_on_drop: bool,
  }
  
  impl TestFileManager {
      pub fn new() -> Self {
          Self {
              temp_dirs: Vec::new(),
              cleanup_on_drop: true,
          }
      }
      
      pub fn preserve_on_failure(mut self) -> Self {
          self.cleanup_on_drop = false;
          self
      }
      
      pub async fn create_test_directory(&mut self, name: &str) -> &Path {
          let temp_dir = TempDir::new().unwrap();
          let path = temp_dir.path();
          
          // 為除錯方便，建立符號連結
          if cfg!(debug_assertions) {
              let debug_path = format!("/tmp/subx_test_{}", name);
              let _ = std::os::unix::fs::symlink(path, &debug_path);
              println!("Test directory: {}", debug_path);
          }
          
          self.temp_dirs.push(temp_dir);
          path
      }
  }
  ```

#### 1.2 模擬服務擴充
- [ ] **音訊檔案模擬器**
  ```rust
  pub struct AudioMockGenerator {
      sample_rate: u32,
      duration: f64,
  }
  
  impl AudioMockGenerator {
      pub fn new(sample_rate: u32) -> Self {
          Self {
              sample_rate,
              duration: 5.0, // 預設 5 秒
          }
      }
      
      pub fn with_duration(mut self, duration: f64) -> Self {
          self.duration = duration;
          self
      }
      
      pub async fn generate_dialogue_audio(&self, path: &Path) -> Result<AudioMetadata> {
          // 生成包含對話和靜音的音訊
          let dialogue_segments = vec![
              DialogueSegment { start: 0.0, end: 1.0, is_speech: false },
              DialogueSegment { start: 1.0, end: 3.0, is_speech: true },
              DialogueSegment { start: 3.0, end: 3.5, is_speech: false },
              DialogueSegment { start: 3.5, end: 5.0, is_speech: true },
          ];
          
          let samples = self.generate_samples_from_segments(&dialogue_segments);
          self.write_wav_file(path, &samples).await?;
          
          Ok(AudioMetadata {
              duration: self.duration,
              sample_rate: self.sample_rate,
              channels: 1,
              dialogue_segments,
          })
      }
      
      pub async fn generate_music_audio(&self, path: &Path) -> Result<()> {
          // 生成純音樂音訊（無對話）
          let samples = self.generate_sine_wave(440.0); // A4 音符
          self.write_wav_file(path, &samples).await
      }
  }
  ```

- [ ] **檔案系統模擬器增強**
  ```rust
  pub struct FileSystemMock {
      root: TempDir,
      permissions: HashMap<PathBuf, u32>,
      readonly_files: HashSet<PathBuf>,
  }
  
  impl FileSystemMock {
      pub fn new() -> Self {
          Self {
              root: TempDir::new().unwrap(),
              permissions: HashMap::new(),
              readonly_files: HashSet::new(),
          }
      }
      
      pub fn create_readonly_file(&mut self, path: &str, content: &str) -> Result<PathBuf> {
          let full_path = self.root.path().join(path);
          fs::write(&full_path, content)?;
          
          // 設定為唯讀
          let mut perms = fs::metadata(&full_path)?.permissions();
          perms.set_readonly(true);
          fs::set_permissions(&full_path, perms)?;
          
          self.readonly_files.insert(full_path.clone());
          Ok(full_path)
      }
      
      pub fn simulate_permission_error(&mut self, path: &str) {
          let full_path = self.root.path().join(path);
          self.permissions.insert(full_path, 0o000); // 無任何權限
      }
  }
  ```

#### 1.3 測試資料產生器升級
- [ ] **各種格式字幕檔案產生器**
  ```rust
  pub struct SubtitleGenerator {
      encoding: Charset,
      format: SubtitleFormat,
      entries: Vec<SubtitleEntry>,
  }
  
  impl SubtitleGenerator {
      pub fn new(format: SubtitleFormat) -> Self {
          Self {
              encoding: Charset::Utf8,
              format,
              entries: Vec::new(),
          }
      }
      
      pub fn with_encoding(mut self, encoding: Charset) -> Self {
          self.encoding = encoding;
          self
      }
      
      pub fn add_entry(mut self, start: f64, end: f64, text: &str) -> Self {
          self.entries.push(SubtitleEntry {
              start_time: Duration::from_secs_f64(start),
              end_time: Duration::from_secs_f64(end),
              text: text.to_string(),
              ..Default::default()
          });
          self
      }
      
      pub fn generate_typical_movie(mut self) -> Self {
          // 生成典型電影字幕模式
          let dialogues = vec![
              (5.0, 8.0, "電影開始了"),
              (10.0, 15.0, "這是第一段對話，比較長一點的內容"),
              (18.0, 20.0, "短對話"),
              (25.0, 30.0, "另一個角色的回應"),
          ];
          
          for (start, end, text) in dialogues {
              self = self.add_entry(start, end, text);
          }
          
          self
      }
      
      pub async fn save_to_file(&self, path: &Path) -> Result<()> {
          let content = match self.format {
              SubtitleFormat::Srt => self.generate_srt_content(),
              SubtitleFormat::Ass => self.generate_ass_content(),
              SubtitleFormat::Vtt => self.generate_vtt_content(),
          };
          
          let encoded_content = self.encode_content(&content)?;
          fs::write(path, encoded_content).await
      }
  }
  ```

### 📊 第二階段：覆蓋率監控與報告 (2 天)

#### 2.1 自動化覆蓋率檢查
- [ ] **CI/CD 覆蓋率門檻檢查**
  ```bash
  # scripts/check_coverage.sh
  #!/bin/bash
  
  COVERAGE_THRESHOLD=75.0
  CURRENT_COVERAGE=$(cargo llvm-cov --all-features --workspace --json --summary-only -q | \
                     jq -r '.data[0].totals.lines.percent')
  
  echo "Current coverage: ${CURRENT_COVERAGE}%"
  echo "Required threshold: ${COVERAGE_THRESHOLD}%"
  
  if (( $(echo "${CURRENT_COVERAGE} < ${COVERAGE_THRESHOLD}" | bc -l) )); then
      echo "❌ Coverage ${CURRENT_COVERAGE}% is below threshold ${COVERAGE_THRESHOLD}%"
      exit 1
  else
      echo "✅ Coverage ${CURRENT_COVERAGE}% meets threshold ${COVERAGE_THRESHOLD}%"
      exit 0
  fi
  ```

- [ ] **覆蓋率趨勢追蹤**
  ```rust
  // tools/coverage_tracker.rs
  use serde::{Serialize, Deserialize};
  use std::collections::HashMap;
  
  #[derive(Serialize, Deserialize)]
  pub struct CoverageReport {
      pub timestamp: String,
      pub commit_hash: String,
      pub overall_coverage: f64,
      pub module_coverage: HashMap<String, f64>,
      pub test_count: usize,
      pub execution_time: f64,
  }
  
  pub struct CoverageTracker {
      history: Vec<CoverageReport>,
      trend_window: usize,
  }
  
  impl CoverageTracker {
      pub fn new() -> Self {
          Self {
              history: Vec::new(),
              trend_window: 10,
          }
      }
      
      pub fn add_report(&mut self, report: CoverageReport) {
          self.history.push(report);
          
          // 保持歷史記錄在合理範圍內
          if self.history.len() > 100 {
              self.history = self.history.split_off(50);
          }
      }
      
      pub fn detect_regression(&self) -> Option<RegressionAlert> {
          if self.history.len() < 2 {
              return None;
          }
          
          let latest = self.history.last().unwrap();
          let previous = &self.history[self.history.len() - 2];
          
          let coverage_drop = previous.overall_coverage - latest.overall_coverage;
          
          if coverage_drop > 2.0 { // 覆蓋率下降超過 2%
              Some(RegressionAlert {
                  severity: AlertSeverity::High,
                  message: format!("Coverage dropped by {:.2}%", coverage_drop),
                  affected_modules: self.find_affected_modules(latest, previous),
              })
          } else {
              None
          }
      }
  }
  ```

- [ ] **覆蓋率回歸警告**
  ```rust
  pub struct CoverageAlert {
      pub severity: AlertSeverity,
      pub module: String,
      pub current_coverage: f64,
      pub previous_coverage: f64,
      pub suggestions: Vec<String>,
  }
  
  impl CoverageAlert {
      pub fn generate_suggestions(&self) -> Vec<String> {
          let mut suggestions = Vec::new();
          
          let drop = self.previous_coverage - self.current_coverage;
          
          if drop > 5.0 {
              suggestions.push("考慮檢查是否有未測試的新程式碼".to_string());
              suggestions.push("確認測試是否因為重構而失效".to_string());
          }
          
          if self.current_coverage < 50.0 {
              suggestions.push("這個模組需要優先建立基礎測試".to_string());
          }
          
          suggestions
      }
  }
  ```

#### 2.2 詳細覆蓋率報告
- [ ] **模組層級覆蓋率報告**
  ```rust
  pub struct DetailedCoverageReporter {
      report_path: PathBuf,
  }
  
  impl DetailedCoverageReporter {
      pub async fn generate_html_report(&self) -> Result<()> {
          let coverage_data = self.collect_coverage_data().await?;
          let html_content = self.generate_html_content(&coverage_data);
          
          fs::write(&self.report_path, html_content).await?;
          println!("Coverage report saved to: {}", self.report_path.display());
          
          Ok(())
      }
      
      fn generate_html_content(&self, data: &CoverageData) -> String {
          format!(r#"
          <!DOCTYPE html>
          <html>
          <head>
              <title>SubX Coverage Report</title>
              <style>
                  .high-coverage {{ background-color: #d4edda; }}
                  .medium-coverage {{ background-color: #fff3cd; }}
                  .low-coverage {{ background-color: #f8d7da; }}
              </style>
          </head>
          <body>
              <h1>SubX Test Coverage Report</h1>
              <h2>Overall: {:.2}%</h2>
              
              <h3>Module Coverage</h3>
              <table>
                  <tr><th>Module</th><th>Coverage</th><th>Status</th></tr>
                  {}
              </table>
          </body>
          </html>
          "#,
          data.overall_coverage,
          self.generate_module_rows(&data.modules)
          )
      }
  }
  ```

### 🚀 第三階段：CI/CD 整合強化 (1-2 天)

#### 3.1 GitHub Actions 工作流程優化
- [ ] **測試矩陣優化**
  ```yaml
  # .github/workflows/comprehensive-testing.yml
  name: Comprehensive Testing
  
  on: [push, pull_request]
  
  jobs:
    test-matrix:
      strategy:
        matrix:
          os: [ubuntu-latest, windows-latest, macos-latest]
          rust: [stable, beta]
          features: [default, all-features, minimal]
      
      runs-on: ${{ matrix.os }}
      
      steps:
        - uses: actions/checkout@v4
        
        - name: Install Rust ${{ matrix.rust }}
          uses: dtolnay/rust-toolchain@master
          with:
            toolchain: ${{ matrix.rust }}
            components: llvm-tools-preview
        
        - name: Cache dependencies
          uses: actions/cache@v3
          with:
            path: |
              ~/.cargo/registry
              ~/.cargo/git
              target/
            key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        
        - name: Run tests with coverage
          run: |
            cargo install cargo-llvm-cov
            cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
        
        - name: Upload coverage to Codecov
          uses: codecov/codecov-action@v3
          with:
            file: lcov.info
            flags: ${{ matrix.os }}-${{ matrix.rust }}-${{ matrix.features }}
  ```

- [ ] **品質門檻檢查**
  ```yaml
  quality-gates:
    runs-on: ubuntu-latest
    needs: test-matrix
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Check coverage threshold
        run: ./scripts/check_coverage.sh
      
      - name: Check code quality
        run: |
          cargo clippy --all-targets --all-features -- -D warnings
          cargo fmt --all -- --check
      
      - name: Security audit
        run: |
          cargo install cargo-audit
          cargo audit
      
      - name: Performance regression check
        run: |
          cargo bench --bench core_benchmarks
          python scripts/check_performance_regression.py
  ```

#### 3.2 自動化報告生成
- [ ] **每日覆蓋率報告**
- [ ] **PR 覆蓋率變化摘要**
- [ ] **測試執行時間追蹤**

## 📊 實作指南

### 工具檔案結構
```
tools/
├── coverage/
│   ├── tracker.rs              # 覆蓋率追蹤
│   ├── reporter.rs             # 報告生成
│   └── alerts.rs               # 回歸預警
├── testing/
│   ├── cli_helpers.rs          # CLI 測試輔助
│   ├── mock_generators.rs      # 模擬資料生成
│   └── validators.rs           # 輸出驗證
└── ci/
    ├── quality_gates.rs        # 品質門檻檢查
    └── performance_tracker.rs  # 效能追蹤

scripts/
├── check_coverage.sh           # 覆蓋率檢查腳本
├── generate_test_report.py     # 測試報告生成
└── setup_test_env.sh          # 測試環境設定

tests/common/
├── cli_helpers.rs              # CLI 測試輔助
├── mock_services.rs            # 模擬服務
├── file_generators.rs          # 檔案生成器
└── validators.rs               # 測試驗證工具
```

### 配置檔案
```toml
# Cargo.toml 測試配置
[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"
tempfile = "3.0"
regex = "1.10"

[[bin]]
name = "coverage_tracker"
path = "tools/coverage/tracker.rs"

[[bin]]
name = "test_reporter"
path = "tools/testing/reporter.rs"

[package.metadata.coverage]
threshold = 75.0
exclude = ["tests/*", "benches/*"]
```

## 📈 預期成果

### 基礎設施改善
- **測試執行效率**: 提升 20%
- **測試可維護性**: 統一測試工具與模式
- **覆蓋率監控**: 自動化追蹤與預警
- **CI/CD 整合**: 完整品質門檻

### 開發體驗提升
- **測試編寫效率**: 提升 30%
- **除錯便利性**: 詳細的測試報告
- **品質保證**: 自動化品質檢查
- **團隊協作**: 統一的測試標準

## 🎯 成功標準

1. **測試工具鏈完整性**: 涵蓋 CLI、模擬、驗證
2. **自動化監控系統**: 覆蓋率趨勢與預警
3. **CI/CD 整合完善**: 品質門檻與自動化檢查
4. **測試可維護性**: 統一工具與標準

---

**建立日期**: 2025-06-09  
**預期完成**: 2025-06-23 (14 天)  
**前置條件**: [#19.3 同步與並行測試](19.3-sync-parallel-testing.md) 完成  
**後續工作**: 測試基礎設施持續優化
