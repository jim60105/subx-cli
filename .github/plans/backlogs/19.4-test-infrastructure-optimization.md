# Product Backlog #19.4: æ¸¬è©¦åŸºç¤è¨­æ–½å„ªåŒ–

## é ˜åŸŸç¯„åœ
å„ªåŒ–æ¸¬è©¦åŸºç¤è¨­æ–½ã€æå‡æ¸¬è©¦å·¥å…·éˆçš„æ•ˆç‡èˆ‡å¯ç¶­è­·æ€§

## èƒŒæ™¯è„ˆçµ¡

éš¨è‘—æ¸¬è©¦è¦†è“‹ç‡çš„æå‡ï¼Œéœ€è¦å¯¦ç”¨çš„æ¸¬è©¦å·¥å…·ä¾†æ”¯æ´ï¼š
- **æ¸¬è©¦å·¥å…·éˆå„ªåŒ–**: æå‡æ¸¬è©¦åŸ·è¡Œæ•ˆç‡
- **æ¸¬è©¦è³‡æ–™ç®¡ç†**: çµ±ä¸€æ¸¬è©¦è³‡æ–™ç”¢ç”Ÿèˆ‡ç®¡ç†
- **CI/CD æ•´åˆ**: ç¢ºä¿å“è³ªé–€æª»

## å®Œæˆé …ç›®

### ğŸ› ï¸ ç¬¬ä¸€éšæ®µï¼šæ¸¬è©¦å·¥å…·å¢å¼· (2-3 å¤©)

#### 1.1 CLI æ¸¬è©¦è¼”åŠ©å·¥å…·é–‹ç™¼
- [ ] **æŒ‡ä»¤åˆ—åƒæ•¸æ¸¬è©¦è¼”åŠ©å‡½å¼**
  ```rust
  // tests/common/cli_helpers### ğŸš€ ç¬¬äºŒéšæ®µï¼šCI/CD æ•´åˆå¼·åŒ– (1 å¤©)rs
  pub struct CLITestHelper {
      temp_dir: TempDir,
      test_files: Vec<PathBuf>,
  }
  
  impl CLITestHelper {
      pub fn new() -> Self {
          Self {
              temp_dir: TempDir::new().unwrap(),
              test_files: Vec::new(),
          }
      }
      
      pub async fn create_test_workspace(&mut self) -> &Path {
          let workspace = self.temp_dir.path();
          
          // å»ºç«‹æ¨™æº–æ¸¬è©¦æª”æ¡ˆçµæ§‹
          self.create_media_files(workspace).await;
          self.create_subtitle_files(workspace).await;
          self.create_config_file(workspace).await;
          
          workspace
      }
      
      pub async fn run_command(&self, args: &[&str]) -> CommandResult {
          let mut cmd = Command::cargo_bin("subx-cli").unwrap();
          cmd.args(args);
          cmd.current_dir(&self.temp_dir);
          
          let output = cmd.output().unwrap();
          CommandResult {
              success: output.status.success(),
              stdout: String::from_utf8_lossy(&output.stdout).to_string(),
              stderr: String::from_utf8_lossy(&output.stderr).to_string(),
          }
      }
      
      pub fn assert_command_success(&self, result: &CommandResult) {
          if !result.success {
              panic!("Command failed:\nstdout: {}\nstderr: {}", 
                     result.stdout, result.stderr);
          }
      }
  }
  ```

- [ ] **è¼¸å‡ºæ•ç²èˆ‡é©—è­‰å·¥å…·**
  ```rust
  pub struct OutputValidator {
      patterns: Vec<regex::Regex>,
      anti_patterns: Vec<regex::Regex>,
  }
  
  impl OutputValidator {
      pub fn new() -> Self {
          Self {
              patterns: Vec::new(),
              anti_patterns: Vec::new(),
          }
      }
      
      pub fn expect_pattern(mut self, pattern: &str) -> Self {
          self.patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn reject_pattern(mut self, pattern: &str) -> Self {
          self.anti_patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn validate(&self, output: &str) -> ValidationResult {
          let mut result = ValidationResult::new();
          
          // æª¢æŸ¥æœŸæœ›æ¨¡å¼
          for pattern in &self.patterns {
              if !pattern.is_match(output) {
                  result.add_error(format!("Missing expected pattern: {}", pattern));
              }
          }
          
          // æª¢æŸ¥æ’é™¤æ¨¡å¼
          for pattern in &self.anti_patterns {
              if pattern.is_match(output) {
                  result.add_error(format!("Found rejected pattern: {}", pattern));
              }
          }
          
          result
      }
  }
  ```

- [ ] **è‡¨æ™‚æª”æ¡ˆç®¡ç†å·¥å…·**
  ```rust
  pub struct TestFileManager {
      temp_dirs: Vec<TempDir>,
      cleanup_on_drop: bool,
  }
  
  impl TestFileManager {
      pub fn new() -> Self {
          Self {
              temp_dirs: Vec::new(),
              cleanup_on_drop: true,
          }
      }
      
      pub fn preserve_on_failure(mut self) -> Self {
          self.cleanup_on_drop = false;
          self
      }
      
      pub async fn create_test_directory(&mut self, name: &str) -> &Path {
          let temp_dir = TempDir::new().unwrap();
          let path = temp_dir.path();
          
          // ç‚ºé™¤éŒ¯æ–¹ä¾¿ï¼Œå»ºç«‹ç¬¦è™Ÿé€£çµ
          if cfg!(debug_assertions) {
              let debug_path = format!("/tmp/subx_test_{}", name);
              let _ = std::os::unix::fs::symlink(path, &debug_path);
              println!("Test directory: {}", debug_path);
          }
          
          self.temp_dirs.push(temp_dir);
          path
      }
  }
  ```

#### 1.2 æ¨¡æ“¬æœå‹™æ“´å……
- [ ] **éŸ³è¨Šæª”æ¡ˆæ¨¡æ“¬å™¨**
  ```rust
  pub struct AudioMockGenerator {
      sample_rate: u32,
      duration: f64,
  }
  
  impl AudioMockGenerator {
      pub fn new(sample_rate: u32) -> Self {
          Self {
              sample_rate,
              duration: 5.0, // é è¨­ 5 ç§’
          }
      }
      
      pub fn with_duration(mut self, duration: f64) -> Self {
          self.duration = duration;
          self
      }
      
      pub async fn generate_dialogue_audio(&self, path: &Path) -> Result<AudioMetadata> {
          // ç”ŸæˆåŒ…å«å°è©±å’ŒéœéŸ³çš„éŸ³è¨Š
          let dialogue_segments = vec![
              DialogueSegment { start: 0.0, end: 1.0, is_speech: false },
              DialogueSegment { start: 1.0, end: 3.0, is_speech: true },
              DialogueSegment { start: 3.0, end: 3.5, is_speech: false },
              DialogueSegment { start: 3.5, end: 5.0, is_speech: true },
          ];
          
          let samples = self.generate_samples_from_segments(&dialogue_segments);
          self.write_wav_file(path, &samples).await?;
          
          Ok(AudioMetadata {
              duration: self.duration,
              sample_rate: self.sample_rate,
              channels: 1,
              dialogue_segments,
          })
      }
      
      pub async fn generate_music_audio(&self, path: &Path) -> Result<()> {
          // ç”Ÿæˆç´”éŸ³æ¨‚éŸ³è¨Šï¼ˆç„¡å°è©±ï¼‰
          let samples = self.generate_sine_wave(440.0); // A4 éŸ³ç¬¦
          self.write_wav_file(path, &samples).await
      }
  }
  ```

- [ ] **æª”æ¡ˆç³»çµ±æ¨¡æ“¬å™¨å¢å¼·**
  ```rust
  pub struct FileSystemMock {
      root: TempDir,
      permissions: HashMap<PathBuf, u32>,
      readonly_files: HashSet<PathBuf>,
  }
  
  impl FileSystemMock {
      pub fn new() -> Self {
          Self {
              root: TempDir::new().unwrap(),
              permissions: HashMap::new(),
              readonly_files: HashSet::new(),
          }
      }
      
      pub fn create_readonly_file(&mut self, path: &str, content: &str) -> Result<PathBuf> {
          let full_path = self.root.path().join(path);
          fs::write(&full_path, content)?;
          
          // è¨­å®šç‚ºå”¯è®€
          let mut perms = fs::metadata(&full_path)?.permissions();
          perms.set_readonly(true);
          fs::set_permissions(&full_path, perms)?;
          
          self.readonly_files.insert(full_path.clone());
          Ok(full_path)
      }
      
      pub fn simulate_permission_error(&mut self, path: &str) {
          let full_path = self.root.path().join(path);
          self.permissions.insert(full_path, 0o000); // ç„¡ä»»ä½•æ¬Šé™
      }
  }
  ```

#### 1.3 æ¸¬è©¦è³‡æ–™ç”¢ç”Ÿå™¨å‡ç´š
- [ ] **å„ç¨®æ ¼å¼å­—å¹•æª”æ¡ˆç”¢ç”Ÿå™¨**
  ```rust
  pub struct SubtitleGenerator {
      encoding: Charset,
      format: SubtitleFormat,
      entries: Vec<SubtitleEntry>,
  }
  
  impl SubtitleGenerator {
      pub fn new(format: SubtitleFormat) -> Self {
          Self {
              encoding: Charset::Utf8,
              format,
              entries: Vec::new(),
          }
      }
      
      pub fn with_encoding(mut self, encoding: Charset) -> Self {
          self.encoding = encoding;
          self
      }
      
      pub fn add_entry(mut self, start: f64, end: f64, text: &str) -> Self {
          self.entries.push(SubtitleEntry {
              start_time: Duration::from_secs_f64(start),
              end_time: Duration::from_secs_f64(end),
              text: text.to_string(),
              ..Default::default()
          });
          self
      }
      
      pub fn generate_typical_movie(mut self) -> Self {
          // ç”Ÿæˆå…¸å‹é›»å½±å­—å¹•æ¨¡å¼
          let dialogues = vec![
              (5.0, 8.0, "é›»å½±é–‹å§‹äº†"),
              (10.0, 15.0, "é€™æ˜¯ç¬¬ä¸€æ®µå°è©±ï¼Œæ¯”è¼ƒé•·ä¸€é»çš„å…§å®¹"),
              (18.0, 20.0, "çŸ­å°è©±"),
              (25.0, 30.0, "å¦ä¸€å€‹è§’è‰²çš„å›æ‡‰"),
          ];
          
          for (start, end, text) in dialogues {
              self = self.add_entry(start, end, text);
          }
          
          self
      }
      
      pub async fn save_to_file(&self, path: &Path) -> Result<()> {
          let content = match self.format {
              SubtitleFormat::Srt => self.generate_srt_content(),
              SubtitleFormat::Ass => self.generate_ass_content(),
              SubtitleFormat::Vtt => self.generate_vtt_content(),
          };
          
          let encoded_content = self.encode_content(&content)?;
          fs::write(path, encoded_content).await
      }
  }
  ```

### ï¿½ ç¬¬äºŒéšæ®µï¼šCI/CD æ•´åˆå¼·åŒ– (1-2 å¤©)

#### 2.1 æ•´åˆè‡³ç¾æœ‰ GitHub Actions å·¥ä½œæµç¨‹
- [ ] **æ•´åˆè¦†è“‹ç‡é–€æª»æª¢æŸ¥è‡³ç¾æœ‰å·¥ä½œæµç¨‹**
  > åœ¨ç¾æœ‰çš„ `.github/workflows/build-test-audit-coverage.yml` ä¸­çš„ `coverage` job æ·»åŠ è¦†è“‹ç‡é–€æª»æª¢æŸ¥
  
  ```yaml
  # åœ¨ coverage job çš„æœ€å¾Œæ·»åŠ 
  - name: Check coverage threshold with standard script
    run: ./scripts/check_coverage.sh
    
  # å¯é¸ï¼šè©³ç´°è¦†è“‹ç‡å ±å‘Š
  - name: Generate detailed coverage report (if needed)
    run: cargo llvm-cov --all-features --workspace --json --summary-only -q
  ```

- [ ] **æ¸¬è©¦å·¥å…·é©—è­‰**
  > åœ¨ç¾æœ‰çš„ `test` job ä¸­æ·»åŠ æ¸¬è©¦å·¥å…·çš„é©—è­‰æ­¥é©Ÿ
  
  ```yaml
  # åœ¨ test job ä¸­æ·»åŠ 
  - name: Run test infrastructure validation
    run: cargo test --test test_infrastructure_validation --verbose
  ```

#### 2.2 ä½¿ç”¨ç¾æœ‰å·¥å…·èˆ‡å·¥ä½œæµç¨‹
- [x] **è¦†è“‹ç‡æª¢æŸ¥**: ä½¿ç”¨ç¾æœ‰çš„ `scripts/check_coverage.sh`
- [x] **ç¾æœ‰ CI/CD**: å·²æœ‰å®Œæ•´çš„ `build-test-audit-coverage.yml` å·¥ä½œæµç¨‹
- [ ] **æ•´åˆæ¸¬è©¦åŸºç¤è¨­æ–½**: å°‡æ–°çš„æ¸¬è©¦å·¥å…·æ•´åˆè‡³ç¾æœ‰å·¥ä½œæµç¨‹ä¸­

## ğŸ“Š å¯¦ä½œæŒ‡å—

### ç°¡åŒ–çš„æª”æ¡ˆçµæ§‹
```
tests/common/
â”œâ”€â”€ cli_helpers.rs              # CLI æ¸¬è©¦è¼”åŠ©
â”œâ”€â”€ mock_generators.rs          # æ¨¡æ“¬è³‡æ–™ç”Ÿæˆ  
â”œâ”€â”€ file_generators.rs          # æª”æ¡ˆç”Ÿæˆå™¨
â””â”€â”€ validators.rs               # æ¸¬è©¦é©—è­‰å·¥å…·

scripts/
â”œâ”€â”€ check_coverage.sh           # è¦†è“‹ç‡æª¢æŸ¥è…³æœ¬ (å·²å­˜åœ¨)
â””â”€â”€ setup_test_env.sh          # æ¸¬è©¦ç’°å¢ƒè¨­å®š (å¦‚éœ€è¦)
```

### é…ç½®æª”æ¡ˆ
```toml
# Cargo.toml æ¸¬è©¦é…ç½®
[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"  
tempfile = "3.0"
regex = "1.10"
```

## ğŸ“ˆ é æœŸæˆæœ

### åŸºç¤è¨­æ–½æ”¹å–„
- **æ¸¬è©¦åŸ·è¡Œæ•ˆç‡**: æå‡ 20%
- **æ¸¬è©¦å¯ç¶­è­·æ€§**: çµ±ä¸€æ¸¬è©¦å·¥å…·èˆ‡æ¨¡å¼
- **CI/CD æ•´åˆ**: åŸºæœ¬å“è³ªé–€æª»

### é–‹ç™¼é«”é©—æå‡
- **æ¸¬è©¦ç·¨å¯«æ•ˆç‡**: æå‡ 30%
- **é™¤éŒ¯ä¾¿åˆ©æ€§**: æ¸…æ™°çš„æ¸¬è©¦è¼”åŠ©å·¥å…·
- **å“è³ªä¿è­‰**: åŸºæœ¬çš„è‡ªå‹•åŒ–æª¢æŸ¥

### è¦†è“‹ç‡ç›£æ§
ä½¿ç”¨ `scripts/check_coverage.sh` ä½œç‚ºä¸»è¦è¦†è“‹ç‡æª¢æŸ¥å·¥å…·ï¼š
```bash
# å¿«é€Ÿè¦†è“‹ç‡æª¢æŸ¥ (æ¨è–¦)
./scripts/check_coverage.sh

# è©³ç´°è¦†è“‹ç‡åˆ†æ (é€²éšä½¿ç”¨)
cargo llvm-cov --all-features --workspace --json --summary-only -q
```

## ğŸ¯ æˆåŠŸæ¨™æº–

1. **æ¸¬è©¦å·¥å…·éˆå¯¦ç”¨æ€§**: æ¶µè“‹ CLIã€æ¨¡æ“¬ã€é©—è­‰çš„æ ¸å¿ƒåŠŸèƒ½
2. **CI/CD åŸºæœ¬æ•´åˆ**: è¦†è“‹ç‡æª¢æŸ¥èˆ‡ç¨‹å¼ç¢¼å“è³ªæª¢æŸ¥
3. **æ¸¬è©¦å¯ç¶­è­·æ€§**: çµ±ä¸€ä¸”ç°¡æ½”çš„æ¸¬è©¦å·¥å…·
4. **è¦†è“‹ç‡ç›£æ§**: `scripts/check_coverage.sh` æ•´åˆåˆ°æ¨™æº–å·¥ä½œæµç¨‹

---

**å»ºç«‹æ—¥æœŸ**: 2025-06-09  
**é æœŸå®Œæˆ**: 2025-06-15 (6 å¤©)  
**å‰ç½®æ¢ä»¶**: [#19.3 åŒæ­¥èˆ‡ä¸¦è¡Œæ¸¬è©¦](19.3-sync-parallel-testing.md) å®Œæˆ  
**å¾ŒçºŒå·¥ä½œ**: æŒçºŒæ¸¬è©¦ç¶­è­·èˆ‡å„ªåŒ–
