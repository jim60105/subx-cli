# Product Backlog #19.4: 測試基礎設施優化

## 領域範圍
優化測試基礎設施、提升測試工具鏈的效率與可維護性

## 背景脈絡

隨著測試覆蓋率的提升，需要實用的測試工具來支援：
- **測試工具鏈優化**: 提升測試執行效率
- **測試資料管理**: 統一測試資料產生與管理
- **CI/CD 整合**: 確保品質門檻

## 完成項目

### 🛠️ 第一階段：測試工具增強 (2-3 天)

#### 1.1 CLI 測試輔助工具開發
- [ ] **指令列參數測試輔助函式**
  ```rust
  // tests/common/cli_helpers### 🚀 第二階段：CI/CD 整合強化 (1 天)rs
  pub struct CLITestHelper {
      temp_dir: TempDir,
      test_files: Vec<PathBuf>,
  }
  
  impl CLITestHelper {
      pub fn new() -> Self {
          Self {
              temp_dir: TempDir::new().unwrap(),
              test_files: Vec::new(),
          }
      }
      
      pub async fn create_test_workspace(&mut self) -> &Path {
          let workspace = self.temp_dir.path();
          
          // 建立標準測試檔案結構
          self.create_media_files(workspace).await;
          self.create_subtitle_files(workspace).await;
          self.create_config_file(workspace).await;
          
          workspace
      }
      
      pub async fn run_command(&self, args: &[&str]) -> CommandResult {
          let mut cmd = Command::cargo_bin("subx-cli").unwrap();
          cmd.args(args);
          cmd.current_dir(&self.temp_dir);
          
          let output = cmd.output().unwrap();
          CommandResult {
              success: output.status.success(),
              stdout: String::from_utf8_lossy(&output.stdout).to_string(),
              stderr: String::from_utf8_lossy(&output.stderr).to_string(),
          }
      }
      
      pub fn assert_command_success(&self, result: &CommandResult) {
          if !result.success {
              panic!("Command failed:\nstdout: {}\nstderr: {}", 
                     result.stdout, result.stderr);
          }
      }
  }
  ```

- [ ] **輸出捕獲與驗證工具**
  ```rust
  pub struct OutputValidator {
      patterns: Vec<regex::Regex>,
      anti_patterns: Vec<regex::Regex>,
  }
  
  impl OutputValidator {
      pub fn new() -> Self {
          Self {
              patterns: Vec::new(),
              anti_patterns: Vec::new(),
          }
      }
      
      pub fn expect_pattern(mut self, pattern: &str) -> Self {
          self.patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn reject_pattern(mut self, pattern: &str) -> Self {
          self.anti_patterns.push(regex::Regex::new(pattern).unwrap());
          self
      }
      
      pub fn validate(&self, output: &str) -> ValidationResult {
          let mut result = ValidationResult::new();
          
          // 檢查期望模式
          for pattern in &self.patterns {
              if !pattern.is_match(output) {
                  result.add_error(format!("Missing expected pattern: {}", pattern));
              }
          }
          
          // 檢查排除模式
          for pattern in &self.anti_patterns {
              if pattern.is_match(output) {
                  result.add_error(format!("Found rejected pattern: {}", pattern));
              }
          }
          
          result
      }
  }
  ```

- [ ] **臨時檔案管理工具**
  ```rust
  pub struct TestFileManager {
      temp_dirs: Vec<TempDir>,
      cleanup_on_drop: bool,
  }
  
  impl TestFileManager {
      pub fn new() -> Self {
          Self {
              temp_dirs: Vec::new(),
              cleanup_on_drop: true,
          }
      }
      
      pub fn preserve_on_failure(mut self) -> Self {
          self.cleanup_on_drop = false;
          self
      }
      
      pub async fn create_test_directory(&mut self, name: &str) -> &Path {
          let temp_dir = TempDir::new().unwrap();
          let path = temp_dir.path();
          
          // 為除錯方便，建立符號連結
          if cfg!(debug_assertions) {
              let debug_path = format!("/tmp/subx_test_{}", name);
              let _ = std::os::unix::fs::symlink(path, &debug_path);
              println!("Test directory: {}", debug_path);
          }
          
          self.temp_dirs.push(temp_dir);
          path
      }
  }
  ```

#### 1.2 模擬服務擴充
- [ ] **音訊檔案模擬器**
  ```rust
  pub struct AudioMockGenerator {
      sample_rate: u32,
      duration: f64,
  }
  
  impl AudioMockGenerator {
      pub fn new(sample_rate: u32) -> Self {
          Self {
              sample_rate,
              duration: 5.0, // 預設 5 秒
          }
      }
      
      pub fn with_duration(mut self, duration: f64) -> Self {
          self.duration = duration;
          self
      }
      
      pub async fn generate_dialogue_audio(&self, path: &Path) -> Result<AudioMetadata> {
          // 生成包含對話和靜音的音訊
          let dialogue_segments = vec![
              DialogueSegment { start: 0.0, end: 1.0, is_speech: false },
              DialogueSegment { start: 1.0, end: 3.0, is_speech: true },
              DialogueSegment { start: 3.0, end: 3.5, is_speech: false },
              DialogueSegment { start: 3.5, end: 5.0, is_speech: true },
          ];
          
          let samples = self.generate_samples_from_segments(&dialogue_segments);
          self.write_wav_file(path, &samples).await?;
          
          Ok(AudioMetadata {
              duration: self.duration,
              sample_rate: self.sample_rate,
              channels: 1,
              dialogue_segments,
          })
      }
      
      pub async fn generate_music_audio(&self, path: &Path) -> Result<()> {
          // 生成純音樂音訊（無對話）
          let samples = self.generate_sine_wave(440.0); // A4 音符
          self.write_wav_file(path, &samples).await
      }
  }
  ```

- [ ] **檔案系統模擬器增強**
  ```rust
  pub struct FileSystemMock {
      root: TempDir,
      permissions: HashMap<PathBuf, u32>,
      readonly_files: HashSet<PathBuf>,
  }
  
  impl FileSystemMock {
      pub fn new() -> Self {
          Self {
              root: TempDir::new().unwrap(),
              permissions: HashMap::new(),
              readonly_files: HashSet::new(),
          }
      }
      
      pub fn create_readonly_file(&mut self, path: &str, content: &str) -> Result<PathBuf> {
          let full_path = self.root.path().join(path);
          fs::write(&full_path, content)?;
          
          // 設定為唯讀
          let mut perms = fs::metadata(&full_path)?.permissions();
          perms.set_readonly(true);
          fs::set_permissions(&full_path, perms)?;
          
          self.readonly_files.insert(full_path.clone());
          Ok(full_path)
      }
      
      pub fn simulate_permission_error(&mut self, path: &str) {
          let full_path = self.root.path().join(path);
          self.permissions.insert(full_path, 0o000); // 無任何權限
      }
  }
  ```

#### 1.3 測試資料產生器升級
- [ ] **各種格式字幕檔案產生器**
  ```rust
  pub struct SubtitleGenerator {
      encoding: Charset,
      format: SubtitleFormat,
      entries: Vec<SubtitleEntry>,
  }
  
  impl SubtitleGenerator {
      pub fn new(format: SubtitleFormat) -> Self {
          Self {
              encoding: Charset::Utf8,
              format,
              entries: Vec::new(),
          }
      }
      
      pub fn with_encoding(mut self, encoding: Charset) -> Self {
          self.encoding = encoding;
          self
      }
      
      pub fn add_entry(mut self, start: f64, end: f64, text: &str) -> Self {
          self.entries.push(SubtitleEntry {
              start_time: Duration::from_secs_f64(start),
              end_time: Duration::from_secs_f64(end),
              text: text.to_string(),
              ..Default::default()
          });
          self
      }
      
      pub fn generate_typical_movie(mut self) -> Self {
          // 生成典型電影字幕模式
          let dialogues = vec![
              (5.0, 8.0, "電影開始了"),
              (10.0, 15.0, "這是第一段對話，比較長一點的內容"),
              (18.0, 20.0, "短對話"),
              (25.0, 30.0, "另一個角色的回應"),
          ];
          
          for (start, end, text) in dialogues {
              self = self.add_entry(start, end, text);
          }
          
          self
      }
      
      pub async fn save_to_file(&self, path: &Path) -> Result<()> {
          let content = match self.format {
              SubtitleFormat::Srt => self.generate_srt_content(),
              SubtitleFormat::Ass => self.generate_ass_content(),
              SubtitleFormat::Vtt => self.generate_vtt_content(),
          };
          
          let encoded_content = self.encode_content(&content)?;
          fs::write(path, encoded_content).await
      }
  }
  ```

### � 第二階段：CI/CD 整合強化 (1-2 天)

#### 2.1 整合至現有 GitHub Actions 工作流程
- [ ] **整合覆蓋率門檻檢查至現有工作流程**
  > 在現有的 `.github/workflows/build-test-audit-coverage.yml` 中的 `coverage` job 添加覆蓋率門檻檢查
  
  ```yaml
  # 在 coverage job 的最後添加
  - name: Check coverage threshold with standard script
    run: ./scripts/check_coverage.sh
    
  # 可選：詳細覆蓋率報告
  - name: Generate detailed coverage report (if needed)
    run: cargo llvm-cov --all-features --workspace --json --summary-only -q
  ```

- [ ] **測試工具驗證**
  > 在現有的 `test` job 中添加測試工具的驗證步驟
  
  ```yaml
  # 在 test job 中添加
  - name: Run test infrastructure validation
    run: cargo test --test test_infrastructure_validation --verbose
  ```

#### 2.2 使用現有工具與工作流程
- [x] **覆蓋率檢查**: 使用現有的 `scripts/check_coverage.sh`
- [x] **現有 CI/CD**: 已有完整的 `build-test-audit-coverage.yml` 工作流程
- [ ] **整合測試基礎設施**: 將新的測試工具整合至現有工作流程中

## 📊 實作指南

### 簡化的檔案結構
```
tests/common/
├── cli_helpers.rs              # CLI 測試輔助
├── mock_generators.rs          # 模擬資料生成  
├── file_generators.rs          # 檔案生成器
└── validators.rs               # 測試驗證工具

scripts/
├── check_coverage.sh           # 覆蓋率檢查腳本 (已存在)
└── setup_test_env.sh          # 測試環境設定 (如需要)
```

### 配置檔案
```toml
# Cargo.toml 測試配置
[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"  
tempfile = "3.0"
regex = "1.10"
```

## 📈 預期成果

### 基礎設施改善
- **測試執行效率**: 提升 20%
- **測試可維護性**: 統一測試工具與模式
- **CI/CD 整合**: 基本品質門檻

### 開發體驗提升
- **測試編寫效率**: 提升 30%
- **除錯便利性**: 清晰的測試輔助工具
- **品質保證**: 基本的自動化檢查

### 覆蓋率監控
使用 `scripts/check_coverage.sh` 作為主要覆蓋率檢查工具：
```bash
# 快速覆蓋率檢查 (推薦)
./scripts/check_coverage.sh

# 詳細覆蓋率分析 (進階使用)
cargo llvm-cov --all-features --workspace --json --summary-only -q
```

## 🎯 成功標準

1. **測試工具鏈實用性**: 涵蓋 CLI、模擬、驗證的核心功能
2. **CI/CD 基本整合**: 覆蓋率檢查與程式碼品質檢查
3. **測試可維護性**: 統一且簡潔的測試工具
4. **覆蓋率監控**: `scripts/check_coverage.sh` 整合到標準工作流程

---

**建立日期**: 2025-06-09  
**預期完成**: 2025-06-15 (6 天)  
**前置條件**: [#19.3 同步與並行測試](19.3-sync-parallel-testing.md) 完成  
**後續工作**: 持續測試維護與優化
