# Backlog #21.5: 命令模組和核心模組遷移

## 概述

本子任務負責遷移所有命令模組和核心模組，移除對全域配置管理器的依賴，實現依賴注入模式。這是確保整個系統完全脫離 unsafe 程式碼的關鍵步驟。

## 遷移計劃

### 階段 1：命令模組遷移 (2 天)

#### 1.1 分析需要遷移的命令模組

需要重構的命令模組：
- `src/commands/sync_command.rs` (34 處 `load_config` 使用)
- `src/commands/match_command.rs`
- `src/commands/convert_command.rs`
- `src/commands/config_command.rs`
- `src/commands/detect_encoding_command.rs`
- `src/commands/cache_command.rs`

#### 1.2 重構 sync_command.rs

**重構前**：
```rust
// src/commands/sync_command.rs
pub async fn execute_sync_command(args: &SyncArgs) -> Result<()> {
    let app_config = load_config()?;  // 內部載入配置
    let sync_config = &app_config.sync;
    
    // 使用配置執行邏輯...
    let detector = DialogueDetector::new();
    let correlator = AudioCorrelator::new();
    
    Ok(())
}
```

**重構後**：
```rust
// src/commands/sync_command.rs
use crate::config::ConfigService;

pub async fn execute(
    args: &SyncArgs,
    config_service: &dyn ConfigService,  // 注入配置服務
) -> Result<()> {
    let app_config = config_service.get_config()?;
    let sync_config = &app_config.sync;
    
    // 直接使用傳入的配置建立組件
    let detector = DialogueDetector::new(sync_config);
    let correlator = AudioCorrelator::new(sync_config);
    
    // 執行同步邏輯
    execute_sync_logic(args, sync_config, detector, correlator).await
}

async fn execute_sync_logic(
    args: &SyncArgs,
    config: &SyncConfig,
    detector: DialogueDetector,
    correlator: AudioCorrelator,
) -> Result<()> {
    // 同步邏輯實作，完全使用傳入的組件
    Ok(())
}
```

#### 1.3 重構 match_command.rs

**重構前**：
```rust
// src/commands/match_command.rs
pub async fn execute_match_command(args: &MatchArgs) -> Result<()> {
    let config = load_config()?;
    let ai_config = &config.ai;
    
    let match_engine = MatchEngine::new();
    match_engine.execute(args).await
}
```

**重構後**：
```rust
// src/commands/match_command.rs
use crate::config::ConfigService;

pub async fn execute(
    args: &MatchArgs,
    config_service: &dyn ConfigService,
) -> Result<()> {
    let config = config_service.get_config()?;
    let ai_config = &config.ai;
    
    // 建立 AI 提供者
    let ai_provider = create_ai_provider(ai_config)?;
    
    // 建立配對引擎，傳入依賴
    let match_engine = MatchEngine::new(
        ai_provider,
        MatchConfig::from(ai_config)
    );
    
    match_engine.execute(args).await
}

fn create_ai_provider(ai_config: &AIConfig) -> Result<Box<dyn AIProvider>> {
    match ai_config.provider.as_str() {
        "openai" => Ok(Box::new(OpenAIProvider::new(ai_config)?)),
        "anthropic" => Ok(Box::new(AnthropicProvider::new(ai_config)?)),
        _ => Err(SubXError::config(&format!(
            "Unsupported AI provider: {}", ai_config.provider
        ))),
    }
}
```

#### 1.4 重構其他命令模組

**convert_command.rs**：
```rust
// src/commands/convert_command.rs
pub async fn execute(
    args: &ConvertArgs,
    config_service: &dyn ConfigService,
) -> Result<()> {
    let config = config_service.get_config()?;
    let formats_config = &config.formats;
    
    let converter = FormatConverter::new(formats_config);
    converter.convert(args).await
}
```

**detect_encoding_command.rs**：
```rust
// src/commands/detect_encoding_command.rs
pub async fn execute(
    args: &DetectEncodingArgs,
    config_service: &dyn ConfigService,
) -> Result<()> {
    let config = config_service.get_config()?;
    let ai_config = &config.ai;
    
    let detector = EncodingDetector::new(ai_config);
    detector.detect_encoding(args).await
}
```

**config_command.rs**：
```rust
// src/commands/config_command.rs
pub async fn execute(
    args: &ConfigArgs,
    config_service: &dyn ConfigService,
) -> Result<()> {
    match &args.action {
        ConfigAction::Show => {
            let config = config_service.get_config()?;
            println!("{}", serde_json::to_string_pretty(&config)?);
        },
        ConfigAction::Validate => {
            let config = config_service.get_config()?;
            crate::config::validator::validate_config(&config)?;
            println!("Configuration is valid");
        },
        ConfigAction::Reload => {
            config_service.reload()?;
            println!("Configuration reloaded");
        },
    }
    Ok(())
}
```

### 階段 2：核心模組遷移 (2.5 天)

#### 2.1 重構 DialogueDetector

**重構前**：
```rust
// src/core/sync/dialogue/detector.rs
impl DialogueDetector {
    pub fn new() -> Self {
        // 內部載入配置
        crate::config::init_config_manager().unwrap();
        let config = crate::config::load_config().unwrap();
        
        Self {
            config: config.sync,
        }
    }
}
```

**重構後**：
```rust
// src/core/sync/dialogue/detector.rs
impl DialogueDetector {
    pub fn new(sync_config: &SyncConfig) -> Self {
        Self {
            config: sync_config.clone(),
        }
    }
    
    pub fn with_custom_threshold(mut self, threshold: f32) -> Self {
        self.config.correlation_threshold = threshold;
        self
    }
    
    pub fn with_custom_offset(mut self, offset: f32) -> Self {
        self.config.max_offset_seconds = offset;
        self
    }
}
```

#### 2.2 重構 MatchEngine

**重構前**：
```rust
// src/core/matcher/engine.rs
impl MatchEngine {
    pub fn new() -> Self {
        let config = crate::config::load_config().unwrap();
        let ai_provider = create_ai_provider_from_config(&config.ai);
        
        Self {
            ai_provider,
            config: config.ai,
        }
    }
}
```

**重構後**：
```rust
// src/core/matcher/engine.rs
impl MatchEngine {
    pub fn new(
        ai_provider: Box<dyn AIProvider>,
        config: MatchConfig
    ) -> Self {
        Self {
            ai_provider,
            config,
        }
    }
    
    pub fn from_config(ai_config: &AIConfig) -> Result<Self> {
        let ai_provider = create_ai_provider(ai_config)?;
        let match_config = MatchConfig::from(ai_config);
        Ok(Self::new(ai_provider, match_config))
    }
}

#[derive(Debug, Clone)]
pub struct MatchConfig {
    pub max_sample_length: usize,
    pub temperature: f32,
    pub model: String,
}

impl From<&AIConfig> for MatchConfig {
    fn from(ai_config: &AIConfig) -> Self {
        Self {
            max_sample_length: ai_config.max_sample_length,
            temperature: ai_config.temperature,
            model: ai_config.model.clone(),
        }
    }
}
```

#### 2.3 重構 FileManager

**重構前**：
```rust
// src/core/file_manager.rs
impl FileManager {
    pub fn new() -> Self {
        let config = crate::config::load_config().unwrap();
        Self {
            general_config: config.general,
        }
    }
}
```

**重構後**：
```rust
// src/core/file_manager.rs
impl FileManager {
    pub fn new(general_config: &GeneralConfig) -> Self {
        Self {
            general_config: general_config.clone(),
        }
    }
    
    pub fn with_temp_dir(mut self, temp_dir: PathBuf) -> Self {
        self.general_config.temp_dir = Some(temp_dir);
        self
    }
}
```

#### 2.4 重構並行處理模組

**重構 `src/core/parallel/executor.rs`**：
```rust
// 重構前
impl ParallelExecutor {
    pub fn new() -> Self {
        let config = crate::config::load_config().unwrap();
        Self {
            max_workers: config.parallel.max_workers,
            queue: VecDeque::new(),
        }
    }
}

// 重構後
impl ParallelExecutor {
    pub fn new(parallel_config: &ParallelConfig) -> Self {
        Self {
            max_workers: parallel_config.max_workers,
            chunk_size: parallel_config.chunk_size,
            queue: VecDeque::new(),
        }
    }
    
    pub fn with_custom_workers(mut self, workers: usize) -> Self {
        self.max_workers = workers;
        self
    }
}
```

### 階段 3：建立工廠模式輔助 (1 天)

#### 3.1 建立組件工廠
```rust
// src/core/factory.rs
use crate::config::{Config, ConfigService};
use crate::core::{
    DialogueDetector,
    MatchEngine,
    FileManager,
    ParallelExecutor,
};

pub struct ComponentFactory {
    config: Config,
}

impl ComponentFactory {
    pub fn new(config_service: &dyn ConfigService) -> Result<Self> {
        let config = config_service.get_config()?;
        Ok(Self { config })
    }
    
    pub fn create_dialogue_detector(&self) -> DialogueDetector {
        DialogueDetector::new(&self.config.sync)
    }
    
    pub fn create_match_engine(&self) -> Result<MatchEngine> {
        MatchEngine::from_config(&self.config.ai)
    }
    
    pub fn create_file_manager(&self) -> FileManager {
        FileManager::new(&self.config.general)
    }
    
    pub fn create_parallel_executor(&self) -> ParallelExecutor {
        ParallelExecutor::new(&self.config.parallel)
    }
    
    pub fn create_ai_provider(&self) -> Result<Box<dyn crate::services::ai::AIProvider>> {
        create_ai_provider(&self.config.ai)
    }
}

// 輔助工廠函式
pub fn create_ai_provider(ai_config: &crate::config::AIConfig) -> Result<Box<dyn crate::services::ai::AIProvider>> {
    match ai_config.provider.as_str() {
        "openai" => Ok(Box::new(crate::services::ai::OpenAIProvider::new(ai_config)?)),
        "anthropic" => Ok(Box::new(crate::services::ai::AnthropicProvider::new(ai_config)?)),
        _ => Err(crate::error::SubXError::config(&format!(
            "Unsupported AI provider: {}", ai_config.provider
        ))),
    }
}
```

#### 3.2 建立服務註冊模式
```rust
// src/core/services.rs
use std::sync::Arc;
use crate::config::ConfigService;

pub struct ServiceContainer {
    config_service: Arc<dyn ConfigService>,
    component_factory: ComponentFactory,
}

impl ServiceContainer {
    pub fn new(config_service: Arc<dyn ConfigService>) -> Result<Self> {
        let component_factory = ComponentFactory::new(config_service.as_ref())?;
        
        Ok(Self {
            config_service,
            component_factory,
        })
    }
    
    pub fn config_service(&self) -> &Arc<dyn ConfigService> {
        &self.config_service
    }
    
    pub fn component_factory(&self) -> &ComponentFactory {
        &self.component_factory
    }
    
    pub fn reload(&mut self) -> Result<()> {
        self.config_service.reload()?;
        self.component_factory = ComponentFactory::new(self.config_service.as_ref())?;
        Ok(())
    }
}
```

### 階段 4：更新主程式整合 (0.5 天)

#### 4.1 更新主程式使用服務容器
```rust
// src/main.rs
use crate::core::{ServiceContainer};
use crate::config::ProductionConfigService;

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    // 建立配置服務
    let config_service = Arc::new(ProductionConfigService::new()?);
    
    // 建立服務容器
    let service_container = ServiceContainer::new(config_service)?;
    
    // 建立應用程式
    let app = App::with_services(service_container);
    app.run().await
}

// src/lib.rs 更新
impl App {
    pub fn with_services(services: ServiceContainer) -> Self {
        Self { services }
    }
    
    pub async fn run(&self) -> Result<()> {
        let cli = crate::cli::Cli::parse();
        
        // 使用服務容器處理命令
        crate::cli::handle_command_with_services(
            cli.command,
            &self.services
        ).await
    }
}
```

#### 4.2 更新 CLI 處理使用服務容器
```rust
// src/cli/mod.rs
use crate::core::ServiceContainer;

pub async fn handle_command_with_services(
    command: SubCommand,
    services: &ServiceContainer
) -> Result<()> {
    let config_service = services.config_service();
    
    match command {
        SubCommand::Match(args) => {
            crate::commands::match_command::execute(&args, config_service.as_ref()).await
        },
        SubCommand::Sync(args) => {
            crate::commands::sync_command::execute(&args, config_service.as_ref()).await
        },
        // 其他命令...
    }
}
```

## 具體模組遷移清單

### 命令模組遷移對應表

| 模組檔案 | 主要函式 | 遷移後簽章 | 預估時間 |
|---------|---------|-----------|----------|
| `sync_command.rs` | `execute_sync_command` | `execute(args, config_service)` | 3 小時 |
| `match_command.rs` | `execute_match_command` | `execute(args, config_service)` | 2 小時 |
| `convert_command.rs` | `execute_convert_command` | `execute(args, config_service)` | 1 小時 |
| `config_command.rs` | `execute_config_command` | `execute(args, config_service)` | 1 小時 |
| `detect_encoding_command.rs` | `execute_detect_encoding_command` | `execute(args, config_service)` | 1 小時 |
| `cache_command.rs` | `execute_cache_command` | `execute(args, config_service)` | 1 小時 |

### 核心模組遷移對應表

| 模組檔案 | 原建構函式 | 新建構函式 | 預估時間 |
|---------|-----------|-----------|----------|
| `dialogue/detector.rs` | `new()` | `new(sync_config)` | 2 小時 |
| `matcher/engine.rs` | `new()` | `new(ai_provider, config)` | 3 小時 |
| `file_manager.rs` | `new()` | `new(general_config)` | 1 小時 |
| `parallel/executor.rs` | `new()` | `new(parallel_config)` | 1 小時 |
| `formats/*` | 各種 `new()` | `new(formats_config)` | 2 小時 |

## 遷移模式和範例

### 標準遷移模式

**模式 1：簡單配置注入**
```rust
// 舊模式
impl Component {
    pub fn new() -> Self {
        let config = load_config().unwrap();
        Self { config: config.section }
    }
}

// 新模式
impl Component {
    pub fn new(config: &SectionConfig) -> Self {
        Self { config: config.clone() }
    }
}
```

**模式 2：複雜依賴注入**
```rust
// 舊模式
impl ComplexComponent {
    pub fn new() -> Self {
        let config = load_config().unwrap();
        let dependency = Dependency::new();
        Self { config: config.section, dependency }
    }
}

// 新模式
impl ComplexComponent {
    pub fn new(config: &SectionConfig, dependency: Dependency) -> Self {
        Self { config: config.clone(), dependency }
    }
    
    pub fn from_config(config: &SectionConfig) -> Result<Self> {
        let dependency = Dependency::from_config(config)?;
        Ok(Self::new(config, dependency))
    }
}
```

**模式 3：工廠函式**
```rust
// 為複雜組件提供工廠函式
pub fn create_complex_component(
    config_service: &dyn ConfigService
) -> Result<ComplexComponent> {
    let config = config_service.get_config()?;
    let dependency = create_dependency(&config.dependency_section)?;
    Ok(ComplexComponent::new(&config.section, dependency))
}
```

## 測試更新

### 核心模組測試更新
```rust
// src/core/sync/dialogue/detector.rs 測試更新
#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::TestConfigBuilder;

    #[test]
    fn test_detector_with_custom_config() {
        let config = TestConfigBuilder::new()
            .with_sync_threshold(0.6)
            .with_max_offset(15.0)
            .build_config();
        
        let detector = DialogueDetector::new(&config.sync);
        assert_eq!(detector.config.correlation_threshold, 0.6);
        assert_eq!(detector.config.max_offset_seconds, 15.0);
    }
    
    #[test]
    fn test_detector_builder_pattern() {
        let config = TestConfigBuilder::new().build_config();
        let detector = DialogueDetector::new(&config.sync)
            .with_custom_threshold(0.9)
            .with_custom_offset(5.0);
        
        assert_eq!(detector.config.correlation_threshold, 0.9);
        assert_eq!(detector.config.max_offset_seconds, 5.0);
    }
}
```

### 命令測試更新
```rust
// tests/commands/sync_command_tests.rs
use subx_cli::config::TestConfigBuilder;
use subx_cli::commands::sync_command;

#[test]
async fn test_sync_command_execution() {
    let config_service = TestConfigBuilder::new()
        .with_sync_threshold(0.8)
        .with_dialogue_detection(true)
        .build_service();
    
    let args = SyncArgs::default();
    let result = sync_command::execute(&args, &config_service).await;
    assert!(result.is_ok());
}
```

## 效能優化

### 配置快取策略
```rust
// 實作智能配置快取
impl ComponentFactory {
    fn get_cached_config(&self) -> &Config {
        &self.config // 配置已在建構時載入和驗證
    }
    
    // 延遲建立昂貴的組件
    pub fn create_match_engine_lazy(&self) -> Result<Box<dyn Fn() -> Result<MatchEngine>>> {
        let ai_config = self.config.ai.clone();
        Ok(Box::new(move || {
            MatchEngine::from_config(&ai_config)
        }))
    }
}
```

## 驗證標準

### 功能驗證
- [ ] 所有命令模組成功移除 `load_config()` 調用
- [ ] 所有核心模組接受配置參數而非內部載入
- [ ] 組件工廠正常運作
- [ ] 服務容器正確管理依賴
- [ ] 所有現有功能保持正常

### 架構驗證
- [ ] 依賴注入模式正確實施
- [ ] 配置傳播路徑清晰
- [ ] 組件間耦合度降低
- [ ] 介面設計合理

### 測試驗證
- [ ] 所有核心模組測試更新並通過
- [ ] 命令模組測試正確使用配置服務
- [ ] 整合測試覆蓋新的依賴注入模式
- [ ] 效能測試確認無明顯倒退

## 下一步行動

完成此命令和核心模組遷移後，將進入：
- [Backlog #21.6: 系統清理和部署準備](21.6-system-cleanup-deployment-preparation.md)

## 相關檔案

### 需要重構的命令檔案
- `src/commands/sync_command.rs`
- `src/commands/match_command.rs`
- `src/commands/convert_command.rs`
- `src/commands/config_command.rs`
- `src/commands/detect_encoding_command.rs`
- `src/commands/cache_command.rs`

### 需要重構的核心檔案
- `src/core/sync/dialogue/detector.rs`
- `src/core/matcher/engine.rs`
- `src/core/file_manager.rs`
- `src/core/parallel/executor.rs`
- `src/core/formats/` 下的所有格式處理器

### 新建檔案
- `src/core/factory.rs` - 組件工廠
- `src/core/services.rs` - 服務容器
