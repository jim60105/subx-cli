# Product Backlog #19.3: 同步與並行處理測試

## 領域範圍
針對同步功能 (sync/) 和並行處理 (parallel/) 模組建立測試覆蓋，確保核心處理邏輯的穩定性

## 背景脈絡

同步和並行處理是 SubX 的核心技術特色，但目前測試覆蓋不足：
- **sync/engine.rs**: 0% → 65% (重點建立)
- **sync/dialogue/detector.rs**: 0% → 60% (全新建立)
- **parallel/worker.rs**: 32.28% → 70% (重點提升)
- **parallel/scheduler.rs**: 需要補強測試

## 完成項目

### 🔥 第一階段：同步功能測試體系 (4-5 天)

#### 1.1 sync/engine.rs 測試實作
**目標覆蓋率**: 0% → 65%

- [ ] **時間軸同步算法測試**
  ```rust
  #[tokio::test]
  async fn test_timeline_sync_algorithm() {
      let engine = SyncEngine::new(SyncConfig::default());
      
      // 建立測試音訊和字幕
      let audio_file = create_test_audio_with_dialogue().await;
      let subtitle_file = create_test_subtitle_file().await;
      
      let result = engine.sync_timeline(&audio_file, &subtitle_file).await.unwrap();
      
      assert!(result.confidence > 0.7);
      assert!(!result.adjustments.is_empty());
      
      // 驗證同步調整合理性
      for adjustment in &result.adjustments {
          assert!(adjustment.offset.abs() < 5.0); // 調整幅度合理
          assert!(adjustment.confidence > 0.5);
      }
  }
  ```

- [ ] **音訊與字幕對齊測試**
  ```rust
  #[tokio::test]
  async fn test_audio_subtitle_alignment() {
      let engine = SyncEngine::new(SyncConfig {
          method: SyncMethod::EnergyBased,
          threshold: 0.3,
          window_size: 1000,
      });
      
      // 測試不同同步方法
      let test_cases = vec![
          SyncMethod::EnergyBased,
          SyncMethod::SpectralBased,
          SyncMethod::Hybrid,
      ];
      
      for method in test_cases {
          let mut config = SyncConfig::default();
          config.method = method;
          
          let result = engine.align_with_method(&audio_file, &subtitle_file, &config).await;
          assert!(result.is_ok(), "Method {:?} should work", method);
      }
  }
  ```

- [ ] **同步品質評估測試**
  ```rust
  #[tokio::test]
  async fn test_sync_quality_assessment() {
      let engine = SyncEngine::new(SyncConfig::default());
      
      // 建立已知好品質和壞品質的測試案例
      let good_sync = create_well_synced_pair().await;
      let bad_sync = create_poorly_synced_pair().await;
      
      let good_quality = engine.assess_quality(&good_sync.audio, &good_sync.subtitle).await.unwrap();
      let bad_quality = engine.assess_quality(&bad_sync.audio, &bad_sync.subtitle).await.unwrap();
      
      assert!(good_quality.score > 0.8);
      assert!(bad_quality.score < 0.5);
  }
  ```

- [ ] **手動調整功能測試**
- [ ] **同步結果驗證測試**

#### 1.2 sync/dialogue/detector.rs 測試實作
**目標覆蓋率**: 0% → 60%

- [ ] **對話檢測算法測試**
  ```rust
  #[tokio::test]
  async fn test_dialogue_detection_algorithm() {
      let detector = DialogueDetector::new();
      let audio_file = create_speech_pattern_audio().await;
      
      let segments = detector.detect_dialogue(&audio_file).await.unwrap();
      
      // 驗證檢測到的對話段落
      assert!(!segments.is_empty());
      
      let speech_segments: Vec<_> = segments.iter()
          .filter(|s| s.is_speech)
          .collect();
      let silence_segments: Vec<_> = segments.iter()
          .filter(|s| !s.is_speech)
          .collect();
      
      assert!(!speech_segments.is_empty());
      assert!(!silence_segments.is_empty());
  }
  ```

- [ ] **語音活動檢測測試**
  ```rust
  #[tokio::test]
  async fn test_voice_activity_detection() {
      let detector = DialogueDetector::with_config(DialogueConfig {
          energy_threshold: 0.1,
          spectral_threshold: 0.2,
          min_speech_duration: 200,
          min_silence_duration: 100,
      });
      
      // 測試不同音訊場景
      let test_cases = vec![
          ("quiet_speech.wav", ExpectedResult { speech_ratio: 0.3 }),
          ("loud_speech.wav", ExpectedResult { speech_ratio: 0.8 }),
          ("background_noise.wav", ExpectedResult { speech_ratio: 0.1 }),
      ];
      
      for (audio_file, expected) in test_cases {
          let segments = detector.detect_dialogue(&audio_file).await.unwrap();
          let speech_ratio = calculate_speech_ratio(&segments);
          
          assert!((speech_ratio - expected.speech_ratio).abs() < 0.2);
      }
  }
  ```

- [ ] **靜音區間檢測測試**
- [ ] **對話分段測試**
- [ ] **檢測精度評估測試**

#### 1.3 sync/dialogue/analyzer.rs 測試實作
**目標覆蓋率**: 新建立 → 60%

- [ ] **能量分析器測試**
  ```rust
  #[test]
  fn test_energy_analyzer() {
      let analyzer = EnergyAnalyzer::new(0.3, 100);
      
      // 建立測試音訊資料
      let samples = create_test_audio_samples_with_pattern();
      let segments = analyzer.analyze(&samples, 44100).unwrap();
      
      // 驗證能量分析結果
      assert!(!segments.is_empty());
      
      // 檢查能量變化檢測
      let energy_changes = segments.windows(2)
          .filter(|w| w[0].is_speech != w[1].is_speech)
          .count();
      assert!(energy_changes > 0);
  }
  ```

- [ ] **視窗化分析測試**
- [ ] **閾值調整測試**
- [ ] **分析精度測試**

### ⚡ 第二階段：並行處理測試提升 (3-4 天)

#### 2.1 parallel/worker.rs 測試提升  
**目標覆蓋率**: 32.28% → 70%

- [ ] **工作分配邏輯測試**
  ```rust
  #[tokio::test]
  async fn test_worker_job_distribution() {
      let pool = WorkerPool::new(4).await;
      
      // 建立多個測試任務
      let tasks = create_test_processing_tasks(10).await;
      
      // 分配任務到工作池
      let results = pool.distribute_tasks(tasks).await.unwrap();
      
      assert_eq!(results.len(), 10);
      assert!(results.iter().all(|r| r.is_success()));
      
      // 驗證負載平衡
      let worker_loads = pool.get_worker_loads().await;
      let max_load = worker_loads.iter().max().unwrap();
      let min_load = worker_loads.iter().min().unwrap();
      assert!(max_load - min_load <= 3); // 負載差異不超過 3 個任務
  }
  ```

- [ ] **錯誤恢復機制測試**
  ```rust
  #[tokio::test]
  async fn test_worker_error_recovery() {
      let pool = WorkerPool::new(2).await;
      
      // 建立包含失敗任務的測試案例
      let tasks = vec![
          create_success_task(),
          create_failure_task(),
          create_success_task(),
      ];
      
      let results = pool.process_with_recovery(tasks).await.unwrap();
      
      // 驗證錯誤恢復
      assert_eq!(results.len(), 3);
      assert_eq!(results.iter().filter(|r| r.is_success()).count(), 2);
      assert_eq!(results.iter().filter(|r| r.is_failure()).count(), 1);
      
      // 確認失敗任務有重試記錄
      let failed_result = results.iter().find(|r| r.is_failure()).unwrap();
      assert!(failed_result.retry_count > 0);
  }
  ```

- [ ] **並行處理效能測試**
  ```rust
  #[tokio::test]
  async fn test_parallel_processing_performance() {
      let sequential_pool = WorkerPool::new(1).await;
      let parallel_pool = WorkerPool::new(4).await;
      
      let tasks = create_cpu_intensive_tasks(8).await;
      
      // 測量循序處理時間
      let start = Instant::now();
      sequential_pool.process_tasks(tasks.clone()).await.unwrap();
      let sequential_time = start.elapsed();
      
      // 測量並行處理時間
      let start = Instant::now();
      parallel_pool.process_tasks(tasks).await.unwrap();
      let parallel_time = start.elapsed();
      
      // 驗證並行處理有效能提升
      assert!(parallel_time < sequential_time);
      let speedup = sequential_time.as_millis() as f64 / parallel_time.as_millis() as f64;
      assert!(speedup > 2.0); // 至少 2 倍提升
  }
  ```

- [ ] **資源管理測試**

#### 2.2 parallel/scheduler.rs 測試補強
**目標覆蓋率**: 提升現有 → 70%

- [ ] **任務調度策略測試**
  ```rust
  #[tokio::test]
  async fn test_task_scheduling_strategies() {
      let scheduler = TaskScheduler::new(SchedulerConfig {
          max_concurrent: 4,
          strategy: SchedulingStrategy::FIFO,
      }).await;
      
      // 測試不同調度策略
      let strategies = vec![
          SchedulingStrategy::FIFO,
          SchedulingStrategy::Priority,
          SchedulingStrategy::RoundRobin,
      ];
      
      for strategy in strategies {
          scheduler.set_strategy(strategy).await;
          
          let tasks = create_prioritized_tasks().await;
          let results = scheduler.schedule_and_execute(tasks).await.unwrap();
          
          verify_scheduling_behavior(&results, strategy);
      }
  }
  ```

- [ ] **負載平衡測試**
- [ ] **任務優先級處理測試**
- [ ] **調度器狀態管理測試**

#### 2.3 parallel/task.rs 測試擴充
**目標覆蓋率**: 補強現有 → 80%

- [ ] **任務生命週期測試**
  ```rust
  #[tokio::test]
  async fn test_task_lifecycle() {
      let mut task = FileProcessingTask::new(
          "test_file.srt",
          ProcessingOperation::EncodingConversion
      );
      
      // 測試任務狀態轉換
      assert_eq!(task.status(), TaskStatus::Pending);
      
      task.start().await;
      assert_eq!(task.status(), TaskStatus::Running);
      
      let result = task.execute().await.unwrap();
      assert_eq!(task.status(), TaskStatus::Completed);
      assert!(result.is_success());
  }
  ```

- [ ] **任務結果序列化測試**
- [ ] **任務錯誤處理測試**
- [ ] **任務超時處理測試**

### 🎯 第三階段：整合與效能基準測試 (2-3 天)

#### 3.1 同步功能整合測試
- [ ] **端到端同步流程測試**
  ```rust
  #[tokio::test]
  async fn test_end_to_end_sync_workflow() {
      // 建立完整的測試場景
      let temp_dir = TempDir::new().unwrap();
      let audio_file = create_realistic_audio_file(&temp_dir).await;
      let subtitle_file = create_misaligned_subtitle_file(&temp_dir).await;
      
      // 執行完整同步流程
      let sync_engine = SyncEngine::new(SyncConfig::default());
      
      // 1. 對話檢測
      let dialogue_segments = sync_engine.detect_dialogue(&audio_file).await.unwrap();
      
      // 2. 時間軸分析
      let timeline_analysis = sync_engine.analyze_timeline(&subtitle_file).await.unwrap();
      
      // 3. 同步對齊
      let sync_result = sync_engine.align_subtitles(
          &dialogue_segments,
          &timeline_analysis
      ).await.unwrap();
      
      // 4. 結果驗證
      assert!(sync_result.confidence > 0.7);
      assert!(sync_result.adjustments.len() > 0);
      
      // 5. 應用調整
      let adjusted_subtitle = sync_engine.apply_adjustments(
          &subtitle_file,
          &sync_result.adjustments
      ).await.unwrap();
      
      verify_sync_improvement(&audio_file, &subtitle_file, &adjusted_subtitle).await;
  }
  ```

#### 3.2 並行處理整合測試
- [ ] **大規模並行處理測試**
  ```rust
  #[tokio::test]
  async fn test_large_scale_parallel_processing() {
      let scheduler = TaskScheduler::new(SchedulerConfig {
          max_concurrent: 8,
          overflow_strategy: OverflowStrategy::Queue,
      }).await;
      
      // 建立大量測試任務
      let tasks = create_bulk_processing_tasks(100).await;
      
      let start_time = Instant::now();
      let results = scheduler.process_bulk(tasks).await.unwrap();
      let processing_time = start_time.elapsed();
      
      // 驗證處理結果
      assert_eq!(results.len(), 100);
      assert!(results.iter().filter(|r| r.is_success()).count() > 95); // 95% 成功率
      
      // 驗證效能指標
      assert!(processing_time < Duration::from_secs(30)); // 30 秒內完成
      
      // 驗證資源使用
      let memory_usage = get_peak_memory_usage();
      assert!(memory_usage < 500_000_000); // 少於 500MB
  }
  ```

## 📊 實作指南

### 測試檔案結構
```
tests/
├── sync/
│   ├── engine_tests.rs             # 同步引擎測試
│   ├── dialogue_detector_tests.rs  # 對話檢測測試
│   ├── dialogue_analyzer_tests.rs  # 對話分析測試
│   └── integration_tests.rs        # 同步整合測試
├── parallel/
│   ├── worker_tests.rs             # 工作器測試
│   ├── scheduler_tests.rs          # 調度器測試
│   ├── task_tests.rs               # 任務測試
│   └── performance_tests.rs        # 效能測試
└── fixtures/
    ├── sync/                       # 同步測試資料
    │   ├── dialogue_audio.wav
    │   ├── misaligned_subtitle.srt
    │   └── reference_sync.json
    └── parallel/                   # 並行測試資料
        ├── bulk_files/
        └── performance_datasets/
```

### 測試輔助工具
```rust
// tests/common/sync_helpers.rs
pub async fn create_test_audio_with_dialogue() -> PathBuf {
    let temp_dir = TempDir::new().unwrap();
    let path = temp_dir.path().join("dialogue.wav");
    
    // 建立包含對話模式的音訊
    let dialogue_pattern = vec![
        (0.0, 1.0, false),   // 靜音
        (1.0, 3.0, true),    // 對話 1
        (3.0, 3.5, false),   // 短暫靜音
        (3.5, 6.0, true),    // 對話 2
        (6.0, 7.0, false),   // 靜音
    ];
    
    generate_dialogue_audio(&path, &dialogue_pattern, 44100).await;
    path
}

pub async fn create_misaligned_subtitle_file() -> PathBuf {
    let temp_dir = TempDir::new().unwrap();
    let path = temp_dir.path().join("misaligned.srt");
    
    let content = r#"1
00:00:02,500 --> 00:00:04,500
第一句對話（延遲 1.5 秒）

2
00:00:05,000 --> 00:00:07,500
第二句對話（延遲 1.5 秒）
"#;
    
    fs::write(&path, content).await.unwrap();
    path
}

// tests/common/parallel_helpers.rs
pub async fn create_test_processing_tasks(count: usize) -> Vec<Box<dyn Task>> {
    let mut tasks = Vec::new();
    
    for i in 0..count {
        let task = FileProcessingTask::new(
            &format!("test_file_{}.srt", i),
            ProcessingOperation::FormatConversion
        );
        tasks.push(Box::new(task) as Box<dyn Task>);
    }
    
    tasks
}

pub async fn create_cpu_intensive_tasks(count: usize) -> Vec<Box<dyn Task>> {
    // 建立 CPU 密集型任務來測試並行效能
    let mut tasks = Vec::new();
    
    for i in 0..count {
        let task = CpuIntensiveTask::new(Duration::from_millis(500)); // 500ms 計算
        tasks.push(Box::new(task) as Box<dyn Task>);
    }
    
    tasks
}
```

## 📈 預期成果

### 覆蓋率目標
- **sync/engine.rs**: 0% → 65%
- **sync/dialogue/detector.rs**: 0% → 60%
- **sync/dialogue/analyzer.rs**: 新建立 → 60%
- **parallel/worker.rs**: 32.28% → 70%
- **parallel/scheduler.rs**: 提升 → 70%

### 測試數量
- **新增測試**: ~45 個
- **測試檔案**: ~12 個
- **效能基準測試**: ~8 個

### 覆蓋率檢查
使用 `scripts/check_coverage.sh` 進行定期覆蓋率檢查，確保達成目標：
```bash
# 快速覆蓋率檢查
./scripts/check_coverage.sh

# 詳細模組覆蓋率分析
cargo llvm-cov --all-features --workspace --json --summary-only -q
```

## 🎯 成功標準

1. **同步功能模組達到 65% 覆蓋率**
2. **並行處理模組達到 70% 覆蓋率**
3. **整合測試完整覆蓋關鍵工作流程**
4. **效能測試建立基準指標**
5. **大規模處理穩定性驗證**
6. **覆蓋率驗證**: 使用 `scripts/check_coverage.sh` 確認達標

---

**建立日期**: 2025-06-09  
**預期完成**: 2025-06-20 (11 天)  
**前置條件**: [#19.2 音訊與編碼測試](19.2-audio-encoding-testing.md) 完成  
**後續工作**: [#19.4 測試基礎設施優化](19.4-test-infrastructure-optimization.md)
