# Product Backlog #19.3: åŒæ­¥èˆ‡ä¸¦è¡Œè™•ç†æ¸¬è©¦

## é ˜åŸŸç¯„åœ
é‡å°åŒæ­¥åŠŸèƒ½ (sync/) å’Œä¸¦è¡Œè™•ç† (parallel/) æ¨¡çµ„å»ºç«‹æ¸¬è©¦è¦†è“‹ï¼Œç¢ºä¿æ ¸å¿ƒè™•ç†é‚è¼¯çš„ç©©å®šæ€§

## èƒŒæ™¯è„ˆçµ¡

åŒæ­¥å’Œä¸¦è¡Œè™•ç†æ˜¯ SubX çš„æ ¸å¿ƒæŠ€è¡“ç‰¹è‰²ï¼Œä½†ç›®å‰æ¸¬è©¦è¦†è“‹ä¸è¶³ï¼š
- **sync/engine.rs**: 0% â†’ 65% (é‡é»å»ºç«‹)
- **sync/dialogue/detector.rs**: 0% â†’ 60% (å…¨æ–°å»ºç«‹)
- **parallel/worker.rs**: 32.28% â†’ 70% (é‡é»æå‡)
- **parallel/scheduler.rs**: éœ€è¦è£œå¼·æ¸¬è©¦

## å®Œæˆé …ç›®

### ğŸ”¥ ç¬¬ä¸€éšæ®µï¼šåŒæ­¥åŠŸèƒ½æ¸¬è©¦é«”ç³» (4-5 å¤©)

#### 1.1 sync/engine.rs æ¸¬è©¦å¯¦ä½œ
**ç›®æ¨™è¦†è“‹ç‡**: 0% â†’ 65%

- [ ] **æ™‚é–“è»¸åŒæ­¥ç®—æ³•æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_timeline_sync_algorithm() {
      let engine = SyncEngine::new(SyncConfig::default());
      
      // å»ºç«‹æ¸¬è©¦éŸ³è¨Šå’Œå­—å¹•
      let audio_file = create_test_audio_with_dialogue().await;
      let subtitle_file = create_test_subtitle_file().await;
      
      let result = engine.sync_timeline(&audio_file, &subtitle_file).await.unwrap();
      
      assert!(result.confidence > 0.7);
      assert!(!result.adjustments.is_empty());
      
      // é©—è­‰åŒæ­¥èª¿æ•´åˆç†æ€§
      for adjustment in &result.adjustments {
          assert!(adjustment.offset.abs() < 5.0); // èª¿æ•´å¹…åº¦åˆç†
          assert!(adjustment.confidence > 0.5);
      }
  }
  ```

- [ ] **éŸ³è¨Šèˆ‡å­—å¹•å°é½Šæ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_audio_subtitle_alignment() {
      let engine = SyncEngine::new(SyncConfig {
          method: SyncMethod::EnergyBased,
          threshold: 0.3,
          window_size: 1000,
      });
      
      // æ¸¬è©¦ä¸åŒåŒæ­¥æ–¹æ³•
      let test_cases = vec![
          SyncMethod::EnergyBased,
          SyncMethod::SpectralBased,
          SyncMethod::Hybrid,
      ];
      
      for method in test_cases {
          let mut config = SyncConfig::default();
          config.method = method;
          
          let result = engine.align_with_method(&audio_file, &subtitle_file, &config).await;
          assert!(result.is_ok(), "Method {:?} should work", method);
      }
  }
  ```

- [ ] **åŒæ­¥å“è³ªè©•ä¼°æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_sync_quality_assessment() {
      let engine = SyncEngine::new(SyncConfig::default());
      
      // å»ºç«‹å·²çŸ¥å¥½å“è³ªå’Œå£å“è³ªçš„æ¸¬è©¦æ¡ˆä¾‹
      let good_sync = create_well_synced_pair().await;
      let bad_sync = create_poorly_synced_pair().await;
      
      let good_quality = engine.assess_quality(&good_sync.audio, &good_sync.subtitle).await.unwrap();
      let bad_quality = engine.assess_quality(&bad_sync.audio, &bad_sync.subtitle).await.unwrap();
      
      assert!(good_quality.score > 0.8);
      assert!(bad_quality.score < 0.5);
  }
  ```

- [ ] **æ‰‹å‹•èª¿æ•´åŠŸèƒ½æ¸¬è©¦**
- [ ] **åŒæ­¥çµæœé©—è­‰æ¸¬è©¦**

#### 1.2 sync/dialogue/detector.rs æ¸¬è©¦å¯¦ä½œ
**ç›®æ¨™è¦†è“‹ç‡**: 0% â†’ 60%

- [ ] **å°è©±æª¢æ¸¬ç®—æ³•æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_dialogue_detection_algorithm() {
      let detector = DialogueDetector::new();
      let audio_file = create_speech_pattern_audio().await;
      
      let segments = detector.detect_dialogue(&audio_file).await.unwrap();
      
      // é©—è­‰æª¢æ¸¬åˆ°çš„å°è©±æ®µè½
      assert!(!segments.is_empty());
      
      let speech_segments: Vec<_> = segments.iter()
          .filter(|s| s.is_speech)
          .collect();
      let silence_segments: Vec<_> = segments.iter()
          .filter(|s| !s.is_speech)
          .collect();
      
      assert!(!speech_segments.is_empty());
      assert!(!silence_segments.is_empty());
  }
  ```

- [ ] **èªéŸ³æ´»å‹•æª¢æ¸¬æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_voice_activity_detection() {
      let detector = DialogueDetector::with_config(DialogueConfig {
          energy_threshold: 0.1,
          spectral_threshold: 0.2,
          min_speech_duration: 200,
          min_silence_duration: 100,
      });
      
      // æ¸¬è©¦ä¸åŒéŸ³è¨Šå ´æ™¯
      let test_cases = vec![
          ("quiet_speech.wav", ExpectedResult { speech_ratio: 0.3 }),
          ("loud_speech.wav", ExpectedResult { speech_ratio: 0.8 }),
          ("background_noise.wav", ExpectedResult { speech_ratio: 0.1 }),
      ];
      
      for (audio_file, expected) in test_cases {
          let segments = detector.detect_dialogue(&audio_file).await.unwrap();
          let speech_ratio = calculate_speech_ratio(&segments);
          
          assert!((speech_ratio - expected.speech_ratio).abs() < 0.2);
      }
  }
  ```

- [ ] **éœéŸ³å€é–“æª¢æ¸¬æ¸¬è©¦**
- [ ] **å°è©±åˆ†æ®µæ¸¬è©¦**
- [ ] **æª¢æ¸¬ç²¾åº¦è©•ä¼°æ¸¬è©¦**

#### 1.3 sync/dialogue/analyzer.rs æ¸¬è©¦å¯¦ä½œ
**ç›®æ¨™è¦†è“‹ç‡**: æ–°å»ºç«‹ â†’ 60%

- [ ] **èƒ½é‡åˆ†æå™¨æ¸¬è©¦**
  ```rust
  #[test]
  fn test_energy_analyzer() {
      let analyzer = EnergyAnalyzer::new(0.3, 100);
      
      // å»ºç«‹æ¸¬è©¦éŸ³è¨Šè³‡æ–™
      let samples = create_test_audio_samples_with_pattern();
      let segments = analyzer.analyze(&samples, 44100).unwrap();
      
      // é©—è­‰èƒ½é‡åˆ†æçµæœ
      assert!(!segments.is_empty());
      
      // æª¢æŸ¥èƒ½é‡è®ŠåŒ–æª¢æ¸¬
      let energy_changes = segments.windows(2)
          .filter(|w| w[0].is_speech != w[1].is_speech)
          .count();
      assert!(energy_changes > 0);
  }
  ```

- [ ] **è¦–çª—åŒ–åˆ†ææ¸¬è©¦**
- [ ] **é–¾å€¼èª¿æ•´æ¸¬è©¦**
- [ ] **åˆ†æç²¾åº¦æ¸¬è©¦**

### âš¡ ç¬¬äºŒéšæ®µï¼šä¸¦è¡Œè™•ç†æ¸¬è©¦æå‡ (3-4 å¤©)

#### 2.1 parallel/worker.rs æ¸¬è©¦æå‡  
**ç›®æ¨™è¦†è“‹ç‡**: 32.28% â†’ 70%

- [ ] **å·¥ä½œåˆ†é…é‚è¼¯æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_worker_job_distribution() {
      let pool = WorkerPool::new(4).await;
      
      // å»ºç«‹å¤šå€‹æ¸¬è©¦ä»»å‹™
      let tasks = create_test_processing_tasks(10).await;
      
      // åˆ†é…ä»»å‹™åˆ°å·¥ä½œæ± 
      let results = pool.distribute_tasks(tasks).await.unwrap();
      
      assert_eq!(results.len(), 10);
      assert!(results.iter().all(|r| r.is_success()));
      
      // é©—è­‰è² è¼‰å¹³è¡¡
      let worker_loads = pool.get_worker_loads().await;
      let max_load = worker_loads.iter().max().unwrap();
      let min_load = worker_loads.iter().min().unwrap();
      assert!(max_load - min_load <= 3); // è² è¼‰å·®ç•°ä¸è¶…é 3 å€‹ä»»å‹™
  }
  ```

- [ ] **éŒ¯èª¤æ¢å¾©æ©Ÿåˆ¶æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_worker_error_recovery() {
      let pool = WorkerPool::new(2).await;
      
      // å»ºç«‹åŒ…å«å¤±æ•—ä»»å‹™çš„æ¸¬è©¦æ¡ˆä¾‹
      let tasks = vec![
          create_success_task(),
          create_failure_task(),
          create_success_task(),
      ];
      
      let results = pool.process_with_recovery(tasks).await.unwrap();
      
      // é©—è­‰éŒ¯èª¤æ¢å¾©
      assert_eq!(results.len(), 3);
      assert_eq!(results.iter().filter(|r| r.is_success()).count(), 2);
      assert_eq!(results.iter().filter(|r| r.is_failure()).count(), 1);
      
      // ç¢ºèªå¤±æ•—ä»»å‹™æœ‰é‡è©¦è¨˜éŒ„
      let failed_result = results.iter().find(|r| r.is_failure()).unwrap();
      assert!(failed_result.retry_count > 0);
  }
  ```

- [ ] **ä¸¦è¡Œè™•ç†æ•ˆèƒ½æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_parallel_processing_performance() {
      let sequential_pool = WorkerPool::new(1).await;
      let parallel_pool = WorkerPool::new(4).await;
      
      let tasks = create_cpu_intensive_tasks(8).await;
      
      // æ¸¬é‡å¾ªåºè™•ç†æ™‚é–“
      let start = Instant::now();
      sequential_pool.process_tasks(tasks.clone()).await.unwrap();
      let sequential_time = start.elapsed();
      
      // æ¸¬é‡ä¸¦è¡Œè™•ç†æ™‚é–“
      let start = Instant::now();
      parallel_pool.process_tasks(tasks).await.unwrap();
      let parallel_time = start.elapsed();
      
      // é©—è­‰ä¸¦è¡Œè™•ç†æœ‰æ•ˆèƒ½æå‡
      assert!(parallel_time < sequential_time);
      let speedup = sequential_time.as_millis() as f64 / parallel_time.as_millis() as f64;
      assert!(speedup > 2.0); // è‡³å°‘ 2 å€æå‡
  }
  ```

- [ ] **è³‡æºç®¡ç†æ¸¬è©¦**

#### 2.2 parallel/scheduler.rs æ¸¬è©¦è£œå¼·
**ç›®æ¨™è¦†è“‹ç‡**: æå‡ç¾æœ‰ â†’ 70%

- [ ] **ä»»å‹™èª¿åº¦ç­–ç•¥æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_task_scheduling_strategies() {
      let scheduler = TaskScheduler::new(SchedulerConfig {
          max_concurrent: 4,
          strategy: SchedulingStrategy::FIFO,
      }).await;
      
      // æ¸¬è©¦ä¸åŒèª¿åº¦ç­–ç•¥
      let strategies = vec![
          SchedulingStrategy::FIFO,
          SchedulingStrategy::Priority,
          SchedulingStrategy::RoundRobin,
      ];
      
      for strategy in strategies {
          scheduler.set_strategy(strategy).await;
          
          let tasks = create_prioritized_tasks().await;
          let results = scheduler.schedule_and_execute(tasks).await.unwrap();
          
          verify_scheduling_behavior(&results, strategy);
      }
  }
  ```

- [ ] **è² è¼‰å¹³è¡¡æ¸¬è©¦**
- [ ] **ä»»å‹™å„ªå…ˆç´šè™•ç†æ¸¬è©¦**
- [ ] **èª¿åº¦å™¨ç‹€æ…‹ç®¡ç†æ¸¬è©¦**

#### 2.3 parallel/task.rs æ¸¬è©¦æ“´å……
**ç›®æ¨™è¦†è“‹ç‡**: è£œå¼·ç¾æœ‰ â†’ 80%

- [ ] **ä»»å‹™ç”Ÿå‘½é€±æœŸæ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_task_lifecycle() {
      let mut task = FileProcessingTask::new(
          "test_file.srt",
          ProcessingOperation::EncodingConversion
      );
      
      // æ¸¬è©¦ä»»å‹™ç‹€æ…‹è½‰æ›
      assert_eq!(task.status(), TaskStatus::Pending);
      
      task.start().await;
      assert_eq!(task.status(), TaskStatus::Running);
      
      let result = task.execute().await.unwrap();
      assert_eq!(task.status(), TaskStatus::Completed);
      assert!(result.is_success());
  }
  ```

- [ ] **ä»»å‹™çµæœåºåˆ—åŒ–æ¸¬è©¦**
- [ ] **ä»»å‹™éŒ¯èª¤è™•ç†æ¸¬è©¦**
- [ ] **ä»»å‹™è¶…æ™‚è™•ç†æ¸¬è©¦**

### ğŸ¯ ç¬¬ä¸‰éšæ®µï¼šæ•´åˆèˆ‡æ•ˆèƒ½åŸºæº–æ¸¬è©¦ (2-3 å¤©)

#### 3.1 åŒæ­¥åŠŸèƒ½æ•´åˆæ¸¬è©¦
- [ ] **ç«¯åˆ°ç«¯åŒæ­¥æµç¨‹æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_end_to_end_sync_workflow() {
      // å»ºç«‹å®Œæ•´çš„æ¸¬è©¦å ´æ™¯
      let temp_dir = TempDir::new().unwrap();
      let audio_file = create_realistic_audio_file(&temp_dir).await;
      let subtitle_file = create_misaligned_subtitle_file(&temp_dir).await;
      
      // åŸ·è¡Œå®Œæ•´åŒæ­¥æµç¨‹
      let sync_engine = SyncEngine::new(SyncConfig::default());
      
      // 1. å°è©±æª¢æ¸¬
      let dialogue_segments = sync_engine.detect_dialogue(&audio_file).await.unwrap();
      
      // 2. æ™‚é–“è»¸åˆ†æ
      let timeline_analysis = sync_engine.analyze_timeline(&subtitle_file).await.unwrap();
      
      // 3. åŒæ­¥å°é½Š
      let sync_result = sync_engine.align_subtitles(
          &dialogue_segments,
          &timeline_analysis
      ).await.unwrap();
      
      // 4. çµæœé©—è­‰
      assert!(sync_result.confidence > 0.7);
      assert!(sync_result.adjustments.len() > 0);
      
      // 5. æ‡‰ç”¨èª¿æ•´
      let adjusted_subtitle = sync_engine.apply_adjustments(
          &subtitle_file,
          &sync_result.adjustments
      ).await.unwrap();
      
      verify_sync_improvement(&audio_file, &subtitle_file, &adjusted_subtitle).await;
  }
  ```

#### 3.2 ä¸¦è¡Œè™•ç†æ•´åˆæ¸¬è©¦
- [ ] **å¤§è¦æ¨¡ä¸¦è¡Œè™•ç†æ¸¬è©¦**
  ```rust
  #[tokio::test]
  async fn test_large_scale_parallel_processing() {
      let scheduler = TaskScheduler::new(SchedulerConfig {
          max_concurrent: 8,
          overflow_strategy: OverflowStrategy::Queue,
      }).await;
      
      // å»ºç«‹å¤§é‡æ¸¬è©¦ä»»å‹™
      let tasks = create_bulk_processing_tasks(100).await;
      
      let start_time = Instant::now();
      let results = scheduler.process_bulk(tasks).await.unwrap();
      let processing_time = start_time.elapsed();
      
      // é©—è­‰è™•ç†çµæœ
      assert_eq!(results.len(), 100);
      assert!(results.iter().filter(|r| r.is_success()).count() > 95); // 95% æˆåŠŸç‡
      
      // é©—è­‰æ•ˆèƒ½æŒ‡æ¨™
      assert!(processing_time < Duration::from_secs(30)); // 30 ç§’å…§å®Œæˆ
      
      // é©—è­‰è³‡æºä½¿ç”¨
      let memory_usage = get_peak_memory_usage();
      assert!(memory_usage < 500_000_000); // å°‘æ–¼ 500MB
  }
  ```

## ğŸ“Š å¯¦ä½œæŒ‡å—

### æ¸¬è©¦æª”æ¡ˆçµæ§‹
```
tests/
â”œâ”€â”€ sync/
â”‚   â”œâ”€â”€ engine_tests.rs             # åŒæ­¥å¼•æ“æ¸¬è©¦
â”‚   â”œâ”€â”€ dialogue_detector_tests.rs  # å°è©±æª¢æ¸¬æ¸¬è©¦
â”‚   â”œâ”€â”€ dialogue_analyzer_tests.rs  # å°è©±åˆ†ææ¸¬è©¦
â”‚   â””â”€â”€ integration_tests.rs        # åŒæ­¥æ•´åˆæ¸¬è©¦
â”œâ”€â”€ parallel/
â”‚   â”œâ”€â”€ worker_tests.rs             # å·¥ä½œå™¨æ¸¬è©¦
â”‚   â”œâ”€â”€ scheduler_tests.rs          # èª¿åº¦å™¨æ¸¬è©¦
â”‚   â”œâ”€â”€ task_tests.rs               # ä»»å‹™æ¸¬è©¦
â”‚   â””â”€â”€ performance_tests.rs        # æ•ˆèƒ½æ¸¬è©¦
â””â”€â”€ fixtures/
    â”œâ”€â”€ sync/                       # åŒæ­¥æ¸¬è©¦è³‡æ–™
    â”‚   â”œâ”€â”€ dialogue_audio.wav
    â”‚   â”œâ”€â”€ misaligned_subtitle.srt
    â”‚   â””â”€â”€ reference_sync.json
    â””â”€â”€ parallel/                   # ä¸¦è¡Œæ¸¬è©¦è³‡æ–™
        â”œâ”€â”€ bulk_files/
        â””â”€â”€ performance_datasets/
```

### æ¸¬è©¦è¼”åŠ©å·¥å…·
```rust
// tests/common/sync_helpers.rs
pub async fn create_test_audio_with_dialogue() -> PathBuf {
    let temp_dir = TempDir::new().unwrap();
    let path = temp_dir.path().join("dialogue.wav");
    
    // å»ºç«‹åŒ…å«å°è©±æ¨¡å¼çš„éŸ³è¨Š
    let dialogue_pattern = vec![
        (0.0, 1.0, false),   // éœéŸ³
        (1.0, 3.0, true),    // å°è©± 1
        (3.0, 3.5, false),   // çŸ­æš«éœéŸ³
        (3.5, 6.0, true),    // å°è©± 2
        (6.0, 7.0, false),   // éœéŸ³
    ];
    
    generate_dialogue_audio(&path, &dialogue_pattern, 44100).await;
    path
}

pub async fn create_misaligned_subtitle_file() -> PathBuf {
    let temp_dir = TempDir::new().unwrap();
    let path = temp_dir.path().join("misaligned.srt");
    
    let content = r#"1
00:00:02,500 --> 00:00:04,500
ç¬¬ä¸€å¥å°è©±ï¼ˆå»¶é² 1.5 ç§’ï¼‰

2
00:00:05,000 --> 00:00:07,500
ç¬¬äºŒå¥å°è©±ï¼ˆå»¶é² 1.5 ç§’ï¼‰
"#;
    
    fs::write(&path, content).await.unwrap();
    path
}

// tests/common/parallel_helpers.rs
pub async fn create_test_processing_tasks(count: usize) -> Vec<Box<dyn Task>> {
    let mut tasks = Vec::new();
    
    for i in 0..count {
        let task = FileProcessingTask::new(
            &format!("test_file_{}.srt", i),
            ProcessingOperation::FormatConversion
        );
        tasks.push(Box::new(task) as Box<dyn Task>);
    }
    
    tasks
}

pub async fn create_cpu_intensive_tasks(count: usize) -> Vec<Box<dyn Task>> {
    // å»ºç«‹ CPU å¯†é›†å‹ä»»å‹™ä¾†æ¸¬è©¦ä¸¦è¡Œæ•ˆèƒ½
    let mut tasks = Vec::new();
    
    for i in 0..count {
        let task = CpuIntensiveTask::new(Duration::from_millis(500)); // 500ms è¨ˆç®—
        tasks.push(Box::new(task) as Box<dyn Task>);
    }
    
    tasks
}
```

## ğŸ“ˆ é æœŸæˆæœ

### è¦†è“‹ç‡ç›®æ¨™
- **sync/engine.rs**: 0% â†’ 65%
- **sync/dialogue/detector.rs**: 0% â†’ 60%
- **sync/dialogue/analyzer.rs**: æ–°å»ºç«‹ â†’ 60%
- **parallel/worker.rs**: 32.28% â†’ 70%
- **parallel/scheduler.rs**: æå‡ â†’ 70%

### æ¸¬è©¦æ•¸é‡
- **æ–°å¢æ¸¬è©¦**: ~45 å€‹
- **æ¸¬è©¦æª”æ¡ˆ**: ~12 å€‹
- **æ•ˆèƒ½åŸºæº–æ¸¬è©¦**: ~8 å€‹

### è¦†è“‹ç‡æª¢æŸ¥
ä½¿ç”¨ `scripts/check_coverage.sh` é€²è¡Œå®šæœŸè¦†è“‹ç‡æª¢æŸ¥ï¼Œç¢ºä¿é”æˆç›®æ¨™ï¼š
```bash
# å¿«é€Ÿè¦†è“‹ç‡æª¢æŸ¥
./scripts/check_coverage.sh

# è©³ç´°æ¨¡çµ„è¦†è“‹ç‡åˆ†æ
cargo llvm-cov --all-features --workspace --json --summary-only -q
```

## ğŸ¯ æˆåŠŸæ¨™æº–

1. **åŒæ­¥åŠŸèƒ½æ¨¡çµ„é”åˆ° 65% è¦†è“‹ç‡**
2. **ä¸¦è¡Œè™•ç†æ¨¡çµ„é”åˆ° 70% è¦†è“‹ç‡**
3. **æ•´åˆæ¸¬è©¦å®Œæ•´è¦†è“‹é—œéµå·¥ä½œæµç¨‹**
4. **æ•ˆèƒ½æ¸¬è©¦å»ºç«‹åŸºæº–æŒ‡æ¨™**
5. **å¤§è¦æ¨¡è™•ç†ç©©å®šæ€§é©—è­‰**
6. **è¦†è“‹ç‡é©—è­‰**: ä½¿ç”¨ `scripts/check_coverage.sh` ç¢ºèªé”æ¨™

---

**å»ºç«‹æ—¥æœŸ**: 2025-06-09  
**é æœŸå®Œæˆ**: 2025-06-20 (11 å¤©)  
**å‰ç½®æ¢ä»¶**: [#19.2 éŸ³è¨Šèˆ‡ç·¨ç¢¼æ¸¬è©¦](19.2-audio-encoding-testing.md) å®Œæˆ  
**å¾ŒçºŒå·¥ä½œ**: [#19.4 æ¸¬è©¦åŸºç¤è¨­æ–½å„ªåŒ–](19.4-test-infrastructure-optimization.md)
