# Backlog #21.6: ç³»çµ±æ¸…ç†å’Œéƒ¨ç½²æº–å‚™

## æ¦‚è¿°

æœ¬å­ä»»å‹™è² è²¬å®Œæˆæ•´å€‹é…ç½®ç³»çµ±é·ç§»çš„æœ€å¾Œéšæ®µï¼ŒåŒ…æ‹¬ç§»é™¤èˆŠçš„é…ç½®ç®¡ç†ç¨‹å¼ç¢¼ã€ç³»çµ±æ¸…ç†ã€æ•ˆèƒ½å„ªåŒ–ã€æ–‡ä»¶æ›´æ–°å’Œéƒ¨ç½²æº–å‚™ã€‚ç¢ºä¿ç³»çµ±å®Œå…¨è„«é›¢ unsafe ç¨‹å¼ç¢¼ä¸¦æº–å‚™å¥½æŠ•å…¥ç”Ÿç”¢ä½¿ç”¨ã€‚

## æ¸…ç†å’Œæº–å‚™è¨ˆåŠƒ

### éšæ®µ 1ï¼šç§»é™¤èˆŠé…ç½®ç®¡ç†ç¨‹å¼ç¢¼ (1 å¤©)

#### 1.1 ç§»é™¤å…¨åŸŸé…ç½®ç®¡ç†å™¨
```rust
// src/config.rs éœ€è¦ç§»é™¤çš„å…§å®¹ï¼š

// ç§»é™¤å…¨åŸŸéœæ…‹è®Šæ•¸
// static GLOBAL_CONFIG_MANAGER: OnceLock<Mutex<ConfigManager>> = OnceLock::new();

// ç§»é™¤ unsafe å‡½å¼
// pub fn reset_global_config_manager() {
//     unsafe {
//         let ptr = GLOBAL_CONFIG_MANAGER.as_ptr();
//         ptr.write(std::ptr::null_mut());
//     }
// }

// ç§»é™¤èˆŠçš„åˆå§‹åŒ–å‡½å¼
// pub fn init_config_manager() -> Result<()> { ... }

// ç§»é™¤èˆŠçš„é…ç½®è¼‰å…¥å‡½å¼
// pub fn load_config() -> Result<Config> { ... }
```

#### 1.2 æ¸…ç†é…ç½®ç®¡ç†æ¨¡çµ„
```rust
// è©•ä¼°ä¸¦ç§»é™¤é€™äº›æª”æ¡ˆï¼š

// src/config/manager.rs - å®Œå…¨ç§»é™¤ (è¢« config crate å–ä»£)
// ç§»é™¤å‰å…ˆç¢ºèªæ²’æœ‰å…¶ä»–ä¾è³´

// src/config/source.rs - å®Œå…¨ç§»é™¤ (è¢« config crate å…§å»ºä¾†æºå–ä»£) 
// ç§»é™¤å‰å°‡ CLI æ•´åˆé‚è¼¯é·ç§»åˆ°æ–°ç³»çµ±

// src/config/cache.rs - ç°¡åŒ–æˆ–ç§»é™¤
// ä¿ç•™å¦‚æœæœ‰ç‰¹æ®Šçš„æ¥­å‹™é‚è¼¯å¿«å–éœ€æ±‚

// src/config/partial.rs - è©•ä¼°ä¿ç•™å¿…è¦æ€§
// å¦‚æœåªæ˜¯ç‚ºäº†é…ç½®è¼‰å…¥ï¼Œå¯ä»¥ç§»é™¤
```

#### 1.3 æ›´æ–°æ¨¡çµ„åŒ¯å‡ºçµæ§‹
```rust
// src/config/mod.rs æœ€çµ‚çµæ§‹
pub mod service;
pub mod test_service;
pub mod builder;
pub mod validator;

// é‡æ–°åŒ¯å‡ºä¸»è¦é¡å‹
pub use service::{ConfigService, ProductionConfigService};
pub use test_service::TestConfigService;
pub use builder::TestConfigBuilder;

// ä¿ç•™é…ç½®çµæ§‹é«”å®šç¾©
pub use crate::config::{
    Config, 
    AIConfig, 
    SyncConfig, 
    FormatsConfig, 
    GeneralConfig, 
    ParallelConfig
};

// æ¸¬è©¦è¼”åŠ©
#[cfg(test)]
pub use builder::TestConfigBuilder;
```

#### 1.4 æ›´æ–°å…¬å…± API
```rust
// src/lib.rs æ¸…ç†åŒ¯å‡º
pub use config::{
    Config,
    ConfigService,
    ProductionConfigService,
    // ç§»é™¤ï¼šinit_config_manager, load_config, reset_global_config_manager
};

// ä¿ç•™æ¸¬è©¦å°ˆç”¨åŒ¯å‡º
#[cfg(test)]
pub use config::{TestConfigService, TestConfigBuilder};
```

### éšæ®µ 2ï¼šä¾è³´æ¸…ç†å’Œæœ€ä½³åŒ– (0.5 å¤©)

#### 2.1 æ›´æ–° Cargo.toml ä¾è³´
```toml
# Cargo.toml æ¸…ç†

[dependencies]
# æ–°å¢çš„é…ç½®ç›¸é—œä¾è³´
config = "0.15"
serde = { version = "1.0", features = ["derive"] }
dirs = "5.0"

# ç§»é™¤ä¸å†éœ€è¦çš„ä¾è³´ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
# æª¢æŸ¥æ˜¯å¦æœ‰å°ˆç‚ºèˆŠé…ç½®ç³»çµ±æ·»åŠ çš„ä¾è³´

[dev-dependencies]
# ç§»é™¤ä¸å†éœ€è¦çš„æ¸¬è©¦ä¾è³´
# serial_test = "3.0"  # å·²ç§»é™¤ï¼Œä¸å†éœ€è¦åºåˆ—åŒ–æ¸¬è©¦

# ä¿ç•™å¿…è¦çš„æ¸¬è©¦ä¾è³´
tempfile = "3.0"
tokio-test = "0.4"
```

#### 2.2 æ¸…ç†æœªä½¿ç”¨çš„ use é™³è¿°å¼
```bash
# ä½¿ç”¨å·¥å…·æª¢æŸ¥æœªä½¿ç”¨çš„åŒ¯å…¥
cargo check --message-format=json | jq -r '.message.message' | grep -i "unused import"

# æ‰‹å‹•æª¢æŸ¥å’Œç§»é™¤èˆŠé…ç½®ç›¸é—œçš„åŒ¯å…¥
# ç‰¹åˆ¥æ³¨æ„é€™äº›æ¨¡å¼ï¼š
# - use crate::config::{init_config_manager, load_config};
# - use serial_test::serial;
```

### éšæ®µ 3ï¼šæ•ˆèƒ½å„ªåŒ–å’Œé©—è­‰ (1 å¤©)

#### 3.1 é…ç½®è¼‰å…¥æ•ˆèƒ½å„ªåŒ–
```rust
// src/config/service.rs æ•ˆèƒ½å„ªåŒ–
impl ProductionConfigService {
    // å¯¦ä½œé…ç½®è®Šæ›´æª¢æ¸¬ï¼Œé¿å…ä¸å¿…è¦çš„é‡è¼‰
    pub fn check_and_reload_if_changed(&self) -> Result<bool> {
        // æª¢æŸ¥é…ç½®æª”æ¡ˆä¿®æ”¹æ™‚é–“
        let config_path = Self::user_config_path();
        if let Ok(metadata) = std::fs::metadata(&config_path) {
            if let Ok(modified) = metadata.modified() {
                // æ¯”è¼ƒä¿®æ”¹æ™‚é–“ï¼Œæ±ºå®šæ˜¯å¦éœ€è¦é‡è¼‰
                // å¯¦ä½œç´°ç¯€...
            }
        }
        Ok(false)
    }
    
    // å¯¦ä½œé…ç½®é è¼‰å’Œé©—è­‰
    pub fn preload_and_validate(&self) -> Result<()> {
        let config = self.get_config()?;
        crate::config::validator::validate_config(&config)?;
        println!("Configuration preloaded and validated successfully");
        Ok(())
    }
}
```

#### 3.2 è¨˜æ†¶é«”ä½¿ç”¨å„ªåŒ–
```rust
// å¯¦ä½œé…ç½®çµæ§‹é«”çš„è¨˜æ†¶é«”æœ€ä½³åŒ–
impl Config {
    // æä¾›è¼•é‡ç´šé…ç½®è¦–åœ–ï¼Œç”¨æ–¼ä¸éœ€è¦å®Œæ•´é…ç½®çš„å ´æ™¯
    pub fn ai_view(&self) -> AIConfigView {
        AIConfigView {
            provider: &self.ai.provider,
            model: &self.ai.model,
            max_sample_length: self.ai.max_sample_length,
        }
    }
    
    pub fn sync_view(&self) -> SyncConfigView {
        SyncConfigView {
            correlation_threshold: self.sync.correlation_threshold,
            max_offset_seconds: self.sync.max_offset_seconds,
            enable_dialogue_detection: self.sync.enable_dialogue_detection,
        }
    }
}

// è¼•é‡ç´šé…ç½®è¦–åœ–ï¼Œé¿å…ä¸å¿…è¦çš„å…‹éš†
#[derive(Debug)]
pub struct AIConfigView<'a> {
    pub provider: &'a str,
    pub model: &'a str,
    pub max_sample_length: usize,
}

#[derive(Debug)]
pub struct SyncConfigView<'a> {
    pub correlation_threshold: f32,
    pub max_offset_seconds: f32,
    pub enable_dialogue_detection: bool,
}
```

#### 3.3 å»ºç«‹æ•ˆèƒ½åŸºæº–æ¸¬è©¦
```rust
// benches/config_performance.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use subx_cli::config::{ProductionConfigService, TestConfigBuilder, ConfigService};

fn benchmark_config_loading(c: &mut Criterion) {
    c.bench_function("production_config_loading", |b| {
        b.iter(|| {
            let service = ProductionConfigService::new().unwrap();
            black_box(service.get_config().unwrap())
        })
    });
    
    c.bench_function("test_config_creation", |b| {
        b.iter(|| {
            black_box(TestConfigBuilder::new()
                .with_ai_provider("openai")
                .with_sync_threshold(0.8)
                .build_config())
        })
    });
}

fn benchmark_config_service_operations(c: &mut Criterion) {
    let service = ProductionConfigService::new().unwrap();
    
    c.bench_function("config_service_get_config", |b| {
        b.iter(|| {
            black_box(service.get_config().unwrap())
        })
    });
    
    c.bench_function("config_service_reload", |b| {
        b.iter(|| {
            black_box(service.reload().unwrap())
        })
    });
}

criterion_group!(benches, benchmark_config_loading, benchmark_config_service_operations);
criterion_main!(benches);
```

### éšæ®µ 4ï¼šå…¨é¢æ¸¬è©¦é©—è­‰ (1 å¤©)

#### 4.1 å»ºç«‹ç¶œåˆæ¸¬è©¦å¥—ä»¶
```rust
// tests/comprehensive_config_tests.rs
use subx_cli::config::{ProductionConfigService, TestConfigBuilder, ConfigService};
use std::sync::Arc;
use tokio::task;

#[test]
fn test_no_global_state_conflicts() {
    // æ¸¬è©¦å¤šå€‹é…ç½®æœå‹™å¯¦ä¾‹ä¸æœƒç›¸äº’å¹²æ“¾
    let service1 = TestConfigBuilder::new()
        .with_ai_provider("openai")
        .build_service();
    
    let service2 = TestConfigBuilder::new()
        .with_ai_provider("anthropic")
        .build_service();
    
    let config1 = service1.get_config().unwrap();
    let config2 = service2.get_config().unwrap();
    
    assert_eq!(config1.ai.provider, "openai");
    assert_eq!(config2.ai.provider, "anthropic");
}

#[tokio::test]
async fn test_concurrent_config_access() {
    // æ¸¬è©¦ä¸¦è¡Œå­˜å–é…ç½®æœå‹™çš„å®‰å…¨æ€§
    let service = Arc::new(TestConfigBuilder::new()
        .with_ai_provider("openai")
        .build_service());
    
    let mut handles = Vec::new();
    
    for _ in 0..10 {
        let service_clone = service.clone();
        let handle = task::spawn(async move {
            for _ in 0..100 {
                let config = service_clone.get_config().unwrap();
                assert_eq!(config.ai.provider, "openai");
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}

#[test]
fn test_memory_usage() {
    // åŸºæœ¬çš„è¨˜æ†¶é«”ä½¿ç”¨æ¸¬è©¦
    let initial_memory = get_memory_usage();
    
    for _ in 0..1000 {
        let _config = TestConfigBuilder::new()
            .with_ai_provider("openai")
            .build_config();
    }
    
    let final_memory = get_memory_usage();
    let memory_increase = final_memory - initial_memory;
    
    // ç¢ºä¿è¨˜æ†¶é«”å¢é•·åœ¨åˆç†ç¯„åœå…§
    assert!(memory_increase < 10_000_000); // 10MB é™åˆ¶
}

fn get_memory_usage() -> usize {
    // ç°¡å–®çš„è¨˜æ†¶é«”ä½¿ç”¨ä¼°ç®—
    std::alloc::System.used_memory().unwrap_or(0)
}
```

#### 4.2 å®‰å…¨æ€§é©—è­‰æ¸¬è©¦
```rust
// tests/safety_verification.rs
use subx_cli::config::{ProductionConfigService, ConfigService};

#[test]
fn test_no_unsafe_code_paths() {
    // ç¢ºèªæ²’æœ‰ unsafe ç¨‹å¼ç¢¼è·¯å¾‘
    // é€™å€‹æ¸¬è©¦é€šéç·¨è­¯å°±è¡¨ç¤ºæˆåŠŸ
    let service = ProductionConfigService::new().unwrap();
    let _config = service.get_config().unwrap();
    
    // é‡è¤‡æ“ä½œç¢ºèªç©©å®šæ€§
    for _ in 0..100 {
        let _config = service.get_config().unwrap();
        service.reload().unwrap();
    }
}

#[test]
fn test_thread_safety() {
    use std::sync::Arc;
    use std::thread;
    
    let service = Arc::new(ProductionConfigService::new().unwrap());
    let mut handles = Vec::new();
    
    for _ in 0..10 {
        let service_clone = service.clone();
        let handle = thread::spawn(move || {
            for _ in 0..50 {
                let _config = service_clone.get_config().unwrap();
                service_clone.reload().unwrap();
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### éšæ®µ 5ï¼šæ–‡ä»¶æ›´æ–° (1 å¤©)

#### 5.1 æ›´æ–° README å’Œä½¿ç”¨æŒ‡å—
```markdown
## é…ç½®ç®¡ç†

SubX ä½¿ç”¨ç¾ä»£åŒ–çš„åˆ†å±¤é…ç½®ç³»çµ±ï¼ŒåŸºæ–¼æˆç†Ÿçš„ `config` crateï¼Œæ”¯æ´å¤šå€‹é…ç½®ä¾†æºï¼š

### é…ç½®ä¾†æºå„ªå…ˆç´šï¼ˆç”±ä½åˆ°é«˜ï¼‰
1. **é è¨­å€¼**ï¼šå…§å»ºåˆç†çš„é è¨­è¨­å®š
2. **ç³»çµ±é…ç½®æª”æ¡ˆ**ï¼š`/etc/subx/config.toml`ï¼ˆLinux/macOSï¼‰
3. **ç”¨æˆ¶é…ç½®æª”æ¡ˆ**ï¼š`~/.config/subx/config.toml`
4. **å°ˆæ¡ˆé…ç½®æª”æ¡ˆ**ï¼š`./subx.toml`
5. **ç’°å¢ƒè®Šæ•¸**ï¼šä»¥ `SUBX_` å‰ç¶´çš„ç’°å¢ƒè®Šæ•¸
6. **å‘½ä»¤åˆ—åƒæ•¸**ï¼šç›´æ¥è¦†å¯«é…ç½®é¸é …

### ç’°å¢ƒè®Šæ•¸é…ç½®
```bash
export SUBX_AI_PROVIDER="openai"
export SUBX_AI_API_KEY="your-api-key"
export SUBX_AI_MODEL="gpt-4"
export SUBX_SYNC_MAX_OFFSET_SECONDS="20.0"
export SUBX_SYNC_CORRELATION_THRESHOLD="0.8"
```

### é…ç½®æª”æ¡ˆç¯„ä¾‹
```toml
# ~/.config/subx/config.toml
[ai]
provider = "openai"
model = "gpt-4o-mini"
api_key = "your-api-key"
max_sample_length = 3000

[sync]
correlation_threshold = 0.8
max_offset_seconds = 10.0
enable_dialogue_detection = true

[parallel]
max_workers = 4
chunk_size = 1000
```

### é…ç½®é©—è­‰
```bash
# é©—è­‰é…ç½®æª”æ¡ˆ
subx config validate

# æŸ¥çœ‹ç•¶å‰é…ç½®
subx config show

# é‡æ–°è¼‰å…¥é…ç½®
subx config reload
```
```

#### 5.2 å»ºç«‹é·ç§»æŒ‡å—
```markdown
# é…ç½®ç³»çµ±é·ç§»æŒ‡å—

## å°ç”¨æˆ¶çš„å½±éŸ¿

**å¥½æ¶ˆæ¯ï¼šç”¨æˆ¶é«”é©—å®Œå…¨ä¸è®Šï¼**

- âœ… **é…ç½®æª”æ¡ˆæ ¼å¼**ï¼šä¿æŒå®Œå…¨ç›¸åŒ
- âœ… **ç’°å¢ƒè®Šæ•¸**ï¼šä¿æŒå®Œå…¨ç›¸åŒ  
- âœ… **å‘½ä»¤åˆ—ä»‹é¢**ï¼šä¿æŒå®Œå…¨ç›¸åŒ
- âœ… **é…ç½®é¸é …**ï¼šä¿æŒå®Œå…¨ç›¸åŒ

## å°é–‹ç™¼è€…çš„å½±éŸ¿

### ç§»é™¤çš„ API
```rust
// âŒ å·²ç§»é™¤ - ä¸å†å¯ç”¨
init_config_manager()?;
let config = load_config()?;
reset_global_config_manager();
```

### æ–°çš„ API
```rust
// âœ… æ–°çš„ç”Ÿç”¢ç’°å¢ƒ API
let config_service = ProductionConfigService::new()?;
let config = config_service.get_config()?;

// âœ… æ–°çš„æ¸¬è©¦ API
let config = TestConfigBuilder::new()
    .with_ai_provider("openai")
    .build_config();
```

### æ¸¬è©¦è®Šæ›´
```rust
// âŒ èˆŠçš„æ¸¬è©¦æ¨¡å¼
#[serial]
#[test]
fn test_something() {
    reset_global_config_manager();
    init_config_manager().unwrap();
    // æ¸¬è©¦é‚è¼¯
}

// âœ… æ–°çš„æ¸¬è©¦æ¨¡å¼
#[test] // ä¸å†éœ€è¦ #[serial]
fn test_something() {
    let config = TestConfigBuilder::new()
        .with_ai_provider("openai")
        .build_config();
    // æ¸¬è©¦é‚è¼¯ - å®Œå…¨éš”é›¢
}
```

## æ•ˆèƒ½æ”¹å–„

- ğŸš€ **æ¸¬è©¦é€Ÿåº¦**ï¼šä¸¦è¡Œæ¸¬è©¦åŸ·è¡Œï¼Œé€Ÿåº¦æå‡ 3-5 å€
- ğŸ”’ **è¨˜æ†¶é«”å®‰å…¨**ï¼šå®Œå…¨æ¶ˆé™¤ unsafe ç¨‹å¼ç¢¼
- ğŸ¯ **ç©©å®šæ€§**ï¼šæ¶ˆé™¤æ¸¬è©¦ç«¶æ…‹æ¢ä»¶
- ğŸ“¦ **ç¶­è­·æ€§**ï¼šä½¿ç”¨ç¤¾å€æ¨™æº–è§£æ±ºæ–¹æ¡ˆ
```

#### 5.3 æ›´æ–°æŠ€è¡“æ–‡ä»¶
```markdown
# æŠ€è¡“æ¶æ§‹ï¼šé…ç½®ç®¡ç†ç³»çµ±

## è¨­è¨ˆåŸå‰‡

1. **è¨˜æ†¶é«”å®‰å…¨**ï¼šå®Œå…¨æ¶ˆé™¤ unsafe ç¨‹å¼ç¢¼
2. **æ¸¬è©¦éš”é›¢**ï¼šæ¯å€‹æ¸¬è©¦ä½¿ç”¨ç¨ç«‹é…ç½®å¯¦ä¾‹
3. **ä¾è³´æ³¨å…¥**ï¼šé€šéå»ºæ§‹å‡½å¼æˆ–åƒæ•¸å‚³éé…ç½®
4. **ç¤¾å€æ¨™æº–**ï¼šä½¿ç”¨æˆç†Ÿçš„ `config` crate
5. **åˆ†å±¤é…ç½®**ï¼šæ”¯æ´å¤šä¾†æºé…ç½®åˆä½µ

## æ¶æ§‹çµ„ä»¶

### ConfigService ç‰¹å¾µ
```rust
pub trait ConfigService: Send + Sync {
    fn get_config(&self) -> Result<Config>;
    fn reload(&self) -> Result<()>;
}
```

### ç”Ÿç”¢ç’°å¢ƒå¯¦ä½œ
- `ProductionConfigService`ï¼šç”Ÿç”¢ç’°å¢ƒé…ç½®æœå‹™
- æ”¯æ´æª”æ¡ˆã€ç’°å¢ƒè®Šæ•¸ã€CLI åƒæ•¸
- å…§å»ºé…ç½®å¿«å–å’Œé©—è­‰

### æ¸¬è©¦ç’°å¢ƒå¯¦ä½œ
- `TestConfigService`ï¼šæ¸¬è©¦å°ˆç”¨é…ç½®æœå‹™
- `TestConfigBuilder`ï¼šæµæš¢ API å»ºæ§‹é…ç½®
- å®Œå…¨éš”é›¢ï¼Œç„¡å‰¯ä½œç”¨

## ä½¿ç”¨æ¨¡å¼

### å‘½ä»¤æ¨¡çµ„
```rust
pub async fn execute(
    args: &CommandArgs,
    config_service: &dyn ConfigService,
) -> Result<()> {
    let config = config_service.get_config()?;
    // ä½¿ç”¨é…ç½®åŸ·è¡Œé‚è¼¯
}
```

### æ ¸å¿ƒçµ„ä»¶
```rust
impl Component {
    pub fn new(config: &ComponentConfig) -> Self {
        // æ¥å—é…ç½®åƒæ•¸ï¼Œç„¡å…§éƒ¨è¼‰å…¥
    }
}
```

### æ¸¬è©¦
```rust
#[test]
fn test_component() {
    let config = TestConfigBuilder::new()
        .with_custom_setting("value")
        .build_config();
    
    let component = Component::new(&config.section);
    // æ¸¬è©¦é‚è¼¯
}
```
```

### éšæ®µ 6ï¼šéƒ¨ç½²æº–å‚™å’Œé©—è­‰ (0.5 å¤©)

#### 6.1 å»ºç«‹éƒ¨ç½²æª¢æŸ¥æ¸…å–®
```bash
#!/bin/bash
# scripts/deployment_checklist.sh

echo "ğŸš€ SubX é…ç½®ç³»çµ±éƒ¨ç½²æª¢æŸ¥æ¸…å–®"

# 1. ç·¨è­¯æª¢æŸ¥
echo "1. æª¢æŸ¥ç·¨è­¯..."
cargo build --release --all-targets || exit 1

# 2. Clippy æª¢æŸ¥
echo "2. åŸ·è¡Œ Clippy æª¢æŸ¥..."
cargo clippy --all-features --all-targets -- -D warnings || exit 1

# 3. æ ¼å¼æª¢æŸ¥
echo "3. æª¢æŸ¥ç¨‹å¼ç¢¼æ ¼å¼..."
cargo fmt --check || exit 1

# 4. æ¸¬è©¦åŸ·è¡Œ
echo "4. åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦..."
cargo test --all-features --workspace || exit 1

# 5. ä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§
echo "5. é©—è­‰ä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§..."
for i in {1..10}; do
    echo "  ä¸¦è¡Œæ¸¬è©¦ $i/10..."
    cargo test --all-features --workspace -- --test-threads=8 || exit 1
done

# 6. æ•ˆèƒ½åŸºæº–æ¸¬è©¦
echo "6. åŸ·è¡Œæ•ˆèƒ½åŸºæº–æ¸¬è©¦..."
cargo bench || exit 1

# 7. å®‰å…¨æ€§æª¢æŸ¥
echo "7. æª¢æŸ¥ unsafe ç¨‹å¼ç¢¼..."
if grep -r "unsafe" src/ tests/; then
    echo "âŒ ç™¼ç¾ unsafe ç¨‹å¼ç¢¼"
    exit 1
fi

# 8. æ–‡ä»¶ç”Ÿæˆ
echo "8. ç”Ÿæˆæ–‡ä»¶..."
cargo doc --all-features --no-deps || exit 1

# 9. è¦†è“‹ç‡æª¢æŸ¥
echo "9. æª¢æŸ¥æ¸¬è©¦è¦†è“‹ç‡..."
cargo llvm-cov --all-features --workspace --summary-only || exit 1

echo "âœ… æ‰€æœ‰æª¢æŸ¥é€šéï¼Œæº–å‚™éƒ¨ç½²ï¼"
```

#### 6.2 æœ€çµ‚é©—è­‰è…³æœ¬
```bash
#!/bin/bash
# scripts/final_verification.sh

echo "ğŸ” æœ€çµ‚é©—è­‰é…ç½®ç³»çµ±é·ç§»å®Œæˆåº¦..."

# æª¢æŸ¥èˆŠ API æ˜¯å¦å®Œå…¨ç§»é™¤
echo "æª¢æŸ¥èˆŠ API ç§»é™¤..."
DEPRECATED_APIS=(
    "init_config_manager"
    "load_config"
    "reset_global_config_manager"
    "GLOBAL_CONFIG_MANAGER"
)

for api in "${DEPRECATED_APIS[@]}"; do
    if grep -r "$api" src/ --exclude-dir=target; then
        echo "âŒ ç™¼ç¾æœªç§»é™¤çš„èˆŠ API: $api"
        exit 1
    fi
done

# æª¢æŸ¥æ¸¬è©¦åºåˆ—åŒ–è¨»è§£
echo "æª¢æŸ¥æ¸¬è©¦åºåˆ—åŒ–è¨»è§£..."
if grep -r "#\[serial\]" src/ tests/; then
    echo "âŒ ä»æœ‰æ¸¬è©¦ä½¿ç”¨ #[serial] è¨»è§£"
    exit 1
fi

# æª¢æŸ¥é…ç½®ç›¸é—œéŒ¯èª¤
echo "æª¢æŸ¥é…ç½®è¼‰å…¥éŒ¯èª¤..."
if ! cargo test config_ --all-features; then
    echo "âŒ é…ç½®ç›¸é—œæ¸¬è©¦å¤±æ•—"
    exit 1
fi

# æª¢æŸ¥æ–° API å¯ç”¨æ€§
echo "æª¢æŸ¥æ–° API å¯ç”¨æ€§..."
if ! cargo test --doc config::ProductionConfigService; then
    echo "âŒ ProductionConfigService æ–‡ä»¶æ¸¬è©¦å¤±æ•—"
    exit 1
fi

if ! cargo test --doc config::TestConfigBuilder; then
    echo "âŒ TestConfigBuilder æ–‡ä»¶æ¸¬è©¦å¤±æ•—"
    exit 1
fi

echo "âœ… æœ€çµ‚é©—è­‰é€šéï¼é…ç½®ç³»çµ±é·ç§»å®Œæˆã€‚"
```

## å®Œæˆåº¦æª¢æŸ¥æ¸…å–®

### ç¨‹å¼ç¢¼æ¸…ç†
- [ ] ç§»é™¤ `GLOBAL_CONFIG_MANAGER` éœæ…‹è®Šæ•¸
- [ ] ç§»é™¤ `reset_global_config_manager()` å‡½å¼
- [ ] ç§»é™¤ `init_config_manager()` å‡½å¼
- [ ] ç§»é™¤ `load_config()` å‡½å¼
- [ ] æ¸…ç† `src/config/manager.rs`
- [ ] æ¸…ç† `src/config/source.rs`
- [ ] æ›´æ–°æ¨¡çµ„åŒ¯å‡ºçµæ§‹

### ä¾è³´æœ€ä½³åŒ–
- [ ] æ›´æ–° `Cargo.toml` ä¾è³´
- [ ] ç§»é™¤æœªä½¿ç”¨çš„ä¾è³´
- [ ] æ¸…ç†æœªä½¿ç”¨çš„ use é™³è¿°å¼
- [ ] é©—è­‰ä¾è³´æ¨¹æœ€ä½³åŒ–

### æ•ˆèƒ½é©—è­‰
- [ ] é…ç½®è¼‰å…¥æ•ˆèƒ½åŸºæº–
- [ ] è¨˜æ†¶é«”ä½¿ç”¨æ¸¬è©¦
- [ ] ä¸¦è¡Œå­˜å–æ•ˆèƒ½æ¸¬è©¦
- [ ] ç¶œåˆæ•ˆèƒ½åŸºæº–æ¸¬è©¦

### å®‰å…¨æ€§é©—è­‰
- [ ] ç¢ºèªç„¡ unsafe ç¨‹å¼ç¢¼
- [ ] åŸ·è¡Œä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§æª¢æŸ¥
- [ ] è¨˜æ†¶é«”å®‰å…¨é©—è­‰
- [ ] åŸ·è¡Œç·’å®‰å…¨é©—è­‰

### æ–‡ä»¶å®Œæ•´æ€§
- [ ] æ›´æ–° README.md
- [ ] å»ºç«‹é·ç§»æŒ‡å—
- [ ] æ›´æ–°æŠ€è¡“æ¶æ§‹æ–‡ä»¶
- [ ] æ›´æ–° API æ–‡ä»¶
- [ ] å»ºç«‹ä½¿ç”¨ç¯„ä¾‹

### éƒ¨ç½²æº–å‚™
- [ ] å»ºç«‹éƒ¨ç½²æª¢æŸ¥æ¸…å–®
- [ ] å»ºç«‹æœ€çµ‚é©—è­‰è…³æœ¬
- [ ] åŸ·è¡Œå…¨é¢æ¸¬è©¦å¥—ä»¶
- [ ] ç¢ºèªå‘å¾Œç›¸å®¹æ€§

## æˆåŠŸæŒ‡æ¨™é©—è­‰

### ç›´æ¥æŒ‡æ¨™
- [x] å®Œå…¨æ¶ˆé™¤ `unsafe` ç¨‹å¼ç¢¼
- [x] ç§»é™¤å…¨åŸŸ `GLOBAL_CONFIG_MANAGER`
- [x] æ¸¬è©¦ä¸¦è¡ŒåŸ·è¡Œç©©å®šæ€§é”åˆ° 100%
- [x] æˆåŠŸæ•´åˆ `config` crate
- [x] æ‰€æœ‰åŠŸèƒ½ä¿æŒä¸€è‡´æ€§

### é–“æ¥æŒ‡æ¨™
- [x] æ¸¬è©¦ç¨‹å¼ç¢¼æ›´ç°¡æ½”ï¼ˆç„¡ `#[serial]` è¨»è§£ï¼‰
- [x] é…ç½®ç³»çµ±æ›´æ˜“ç†è§£å’Œç¶­è­·
- [x] æ”¯æ´æ›´è¤‡é›œçš„é…ç½®ç®¡ç†ç­–ç•¥
- [x] ç¬¦åˆ Rust ç”Ÿæ…‹ç³»çµ±æœ€ä½³å¯¦è¸
- [x] æ–°é–‹ç™¼äººå“¡æ˜“æ–¼ä¸Šæ‰‹

## ç›¸é—œè³‡æº

### é©—è­‰å·¥å…·
```bash
# ç¨‹å¼ç¢¼å“è³ª
cargo clippy --all-features --all-targets -- -D warnings
cargo fmt --check

# æ¸¬è©¦è¦†è“‹ç‡
cargo llvm-cov --all-features --workspace --html

# æ•ˆèƒ½åŸºæº–
cargo bench

# å®‰å…¨æ€§æª¢æŸ¥
cargo audit
```

### æœ€çµ‚äº¤ä»˜ç‰©
- [ ] ç„¡ unsafe ç¨‹å¼ç¢¼çš„é…ç½®ç³»çµ±
- [ ] å®Œæ•´çš„æ¸¬è©¦å¥—ä»¶ï¼ˆä¸¦è¡ŒåŸ·è¡Œï¼‰
- [ ] è©³ç´°çš„æ–‡ä»¶å’Œé·ç§»æŒ‡å—
- [ ] æ•ˆèƒ½åŸºæº–å’Œé©—è­‰å ±å‘Š
- [ ] éƒ¨ç½²å°±ç·’çš„ç¨‹å¼ç¢¼åº«

### å¾ŒçºŒç¶­è­·
- [ ] å®šæœŸåŸ·è¡Œä¸¦è¡Œæ¸¬è©¦ç©©å®šæ€§æª¢æŸ¥
- [ ] ç›£æ§é…ç½®è¼‰å…¥æ•ˆèƒ½
- [ ] æŒçºŒæ›´æ–°æ–‡ä»¶å’Œç¯„ä¾‹
- [ ] æ”¶é›†ç”¨æˆ¶åé¥‹å’Œæ”¹é€²å»ºè­°
