# Backlog #21.3: 配置服務系統實作

## 概述

本子任務負責實作完整的配置服務系統，包括生產環境和測試環境的配置服務，建立依賴注入機制，並重構應用程式進入點。

## 實作計劃

### 階段 1：實作配置服務介面 (1.5 天)

#### 1.1 建立配置服務介面
```rust
// src/config/service.rs
use config::{Config as ConfigCrate, ConfigBuilder, DefaultState};
use std::sync::{Arc, RwLock};
use std::path::PathBuf;

pub trait ConfigService: Send + Sync {
    fn get_config(&self) -> Result<crate::config::Config>;
    fn reload(&self) -> Result<()>;
}

pub struct ProductionConfigService {
    config_builder: ConfigBuilder<DefaultState>,
    cached_config: Arc<RwLock<Option<crate::config::Config>>>,
}

impl ProductionConfigService {
    pub fn new() -> Result<Self> {
        let config_builder = ConfigCrate::builder()
            .add_source(config::File::with_name("config/default").required(false))
            .add_source(config::File::from(Self::user_config_path()).required(false))
            .add_source(config::Environment::with_prefix("SUBX").separator("_"));
        
        Ok(Self {
            config_builder,
            cached_config: Arc::new(RwLock::new(None)),
        })
    }
    
    pub fn with_custom_sources(mut self, sources: Vec<config::Source>) -> Result<Self> {
        for source in sources {
            self.config_builder = self.config_builder.add_source(source);
        }
        Ok(self)
    }
    
    fn user_config_path() -> PathBuf {
        dirs::config_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("subx")
            .join("config.toml")
    }
}

impl ConfigService for ProductionConfigService {
    fn get_config(&self) -> Result<crate::config::Config> {
        // 檢查快取
        {
            let cache = self.cached_config.read().unwrap();
            if let Some(config) = cache.as_ref() {
                return Ok(config.clone());
            }
        }
        
        // 載入配置
        let config_crate = self.config_builder.build_cloned()
            .map_err(crate::error::SubXError::from)?;
        
        let app_config: crate::config::Config = config_crate
            .try_deserialize()
            .map_err(crate::error::SubXError::from)?;
        
        // 驗證配置
        crate::config::validator::validate_config(&app_config)?;
        
        // 更新快取
        {
            let mut cache = self.cached_config.write().unwrap();
            *cache = Some(app_config.clone());
        }
        
        Ok(app_config)
    }
    
    fn reload(&self) -> Result<()> {
        // 清空快取，強制重新載入
        {
            let mut cache = self.cached_config.write().unwrap();
            *cache = None;
        }
        
        // 觸發重新載入
        self.get_config()?;
        Ok(())
    }
}
```

#### 1.2 建立測試配置服務
```rust
// src/config/test_service.rs
pub struct TestConfigService {
    fixed_config: crate::config::Config,
}

impl TestConfigService {
    pub fn new(config: crate::config::Config) -> Self {
        Self { fixed_config: config }
    }
    
    pub fn with_defaults() -> Self {
        Self::new(crate::config::Config::default())
    }
    
    pub fn with_ai_settings(provider: &str, model: &str) -> Self {
        let mut config = crate::config::Config::default();
        config.ai.provider = provider.to_string();
        config.ai.model = model.to_string();
        Self::new(config)
    }
    
    pub fn with_sync_settings(correlation_threshold: f32, max_offset: f32) -> Self {
        let mut config = crate::config::Config::default();
        config.sync.correlation_threshold = correlation_threshold;
        config.sync.max_offset_seconds = max_offset;
        Self::new(config)
    }
}

impl ConfigService for TestConfigService {
    fn get_config(&self) -> Result<crate::config::Config> {
        Ok(self.fixed_config.clone())
    }
    
    fn reload(&self) -> Result<()> {
        Ok(()) // 測試配置不需要重新載入
    }
}
```

#### 1.3 建立配置建構器輔助工具
```rust
// src/config/builder.rs
pub struct TestConfigBuilder {
    config: crate::config::Config,
}

impl TestConfigBuilder {
    pub fn new() -> Self {
        Self {
            config: crate::config::Config::default(),
        }
    }
    
    pub fn with_ai_provider(mut self, provider: &str) -> Self {
        self.config.ai.provider = provider.to_string();
        self
    }
    
    pub fn with_ai_model(mut self, model: &str) -> Self {
        self.config.ai.model = model.to_string();
        self
    }
    
    pub fn with_ai_api_key(mut self, api_key: &str) -> Self {
        self.config.ai.api_key = Some(api_key.to_string());
        self
    }
    
    pub fn with_max_sample_length(mut self, length: usize) -> Self {
        self.config.ai.max_sample_length = length;
        self
    }
    
    pub fn with_sync_threshold(mut self, threshold: f32) -> Self {
        self.config.sync.correlation_threshold = threshold;
        self
    }
    
    pub fn with_max_offset(mut self, offset: f32) -> Self {
        self.config.sync.max_offset_seconds = offset;
        self
    }
    
    pub fn with_dialogue_detection(mut self, enabled: bool) -> Self {
        self.config.sync.enable_dialogue_detection = enabled;
        self
    }
    
    pub fn with_parallel_workers(mut self, workers: usize) -> Self {
        self.config.parallel.max_workers = workers;
        self
    }
    
    pub fn build_service(self) -> TestConfigService {
        TestConfigService::new(self.config)
    }
    
    pub fn build_config(self) -> crate::config::Config {
        self.config
    }
}

impl Default for TestConfigBuilder {
    fn default() -> Self {
        Self::new()
    }
}
```

### 階段 2：更新應用程式進入點 (1 天)

#### 2.1 更新主程式結構
```rust
// src/main.rs
use crate::config::{ConfigService, ProductionConfigService};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // 初始化日誌系統
    env_logger::init();
    
    // 建立配置服務
    let config_service = Arc::new(ProductionConfigService::new()?);
    
    // 建立應用程式與依賴注入
    let app = App::new(config_service);
    app.run().await
}

// src/lib.rs - 添加新的應用程式結構
pub struct App {
    config_service: Arc<dyn ConfigService>,
}

impl App {
    pub fn new(config_service: Arc<dyn ConfigService>) -> Self {
        Self { config_service }
    }
    
    pub async fn run(&self) -> Result<()> {
        let cli = crate::cli::Cli::parse();
        
        // 傳遞配置服務到命令處理器
        crate::cli::handle_command(cli.command, self.config_service.clone()).await
    }
    
    pub fn config_service(&self) -> &Arc<dyn ConfigService> {
        &self.config_service
    }
}
```

#### 2.2 更新 CLI 處理邏輯
```rust
// src/cli/mod.rs - 更新 CLI 處理
use crate::config::ConfigService;
use std::sync::Arc;

pub async fn handle_command(
    command: SubCommand,
    config_service: Arc<dyn ConfigService>
) -> Result<()> {
    match command {
        SubCommand::Match(args) => {
            crate::commands::match_command::execute(&args, config_service.as_ref()).await
        },
        SubCommand::Sync(args) => {
            crate::commands::sync_command::execute(&args, config_service.as_ref()).await
        },
        SubCommand::Convert(args) => {
            crate::commands::convert_command::execute(&args, config_service.as_ref()).await
        },
        SubCommand::Config(args) => {
            crate::commands::config_command::execute(&args, config_service.as_ref()).await
        },
        SubCommand::DetectEncoding(args) => {
            crate::commands::detect_encoding_command::execute(&args, config_service.as_ref()).await
        },
        SubCommand::Cache(args) => {
            crate::commands::cache_command::execute(&args, config_service.as_ref()).await
        },
        SubCommand::GenerateCompletion(args) => {
            crate::commands::generate_completion::execute(&args, config_service.as_ref()).await
        },
    }
}
```

### 階段 3：建立測試輔助巨集 (0.5 天)

#### 3.1 建立測試輔助巨集
```rust
// src/config/test_macros.rs
#[macro_export]
macro_rules! test_with_config {
    ($config_builder:expr, $test:expr) => {
        {
            let config_service = $config_builder.build_service();
            $test(&config_service)
        }
    };
}

#[macro_export]
macro_rules! test_with_default_config {
    ($test:expr) => {
        test_with_config!(
            $crate::config::TestConfigBuilder::new(),
            $test
        )
    };
}

#[macro_export]
macro_rules! test_with_ai_config {
    ($provider:expr, $model:expr, $test:expr) => {
        test_with_config!(
            $crate::config::TestConfigBuilder::new()
                .with_ai_provider($provider)
                .with_ai_model($model),
            $test
        )
    };
}

// 使用範例的測試
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_macro_usage() {
        test_with_config!(
            TestConfigBuilder::new().with_ai_provider("openai"),
            |config_service| {
                let config = config_service.get_config().unwrap();
                assert_eq!(config.ai.provider, "openai");
            }
        );
    }
    
    #[test]
    fn test_default_config_macro() {
        test_with_default_config!(|config_service| {
            let config = config_service.get_config().unwrap();
            assert_eq!(config.ai.provider, "openai");
        });
    }
    
    #[test]
    fn test_ai_config_macro() {
        test_with_ai_config!("anthropic", "claude-3", |config_service| {
            let config = config_service.get_config().unwrap();
            assert_eq!(config.ai.provider, "anthropic");
            assert_eq!(config.ai.model, "claude-3");
        });
    }
}
```

### 階段 4：進階配置功能實作 (1 天)

#### 4.1 支援配置檔案熱重載
```rust
impl ProductionConfigService {
    pub fn enable_hot_reload(&self) -> Result<()> {
        // 實作檔案系統監控和自動重載
        // 這可以作為未來的功能增強
        todo!("Implement file system watcher for hot reload")
    }
    
    pub fn add_custom_source(&mut self, source: config::Source) -> Result<()> {
        self.config_builder = self.config_builder.add_source(source);
        self.reload() // 重新載入以套用新來源
    }
}
```

#### 4.2 配置驗證增強
```rust
impl ProductionConfigService {
    fn validate_and_cache(&self, config: crate::config::Config) -> Result<crate::config::Config> {
        // 業務邏輯驗證
        crate::config::validator::validate_config(&config)?;
        
        // 檢查 API 金鑰有效性（如果需要）
        if let Some(api_key) = &config.ai.api_key {
            if api_key.is_empty() {
                return Err(crate::error::SubXError::config("AI API key cannot be empty"));
            }
        }
        
        // 檢查數值範圍
        if config.sync.correlation_threshold < 0.0 || config.sync.correlation_threshold > 1.0 {
            return Err(crate::error::SubXError::config(
                "Correlation threshold must be between 0.0 and 1.0"
            ));
        }
        
        Ok(config)
    }
}
```

#### 4.3 環境特定配置支援
```rust
// src/config/environment.rs
#[derive(Debug, Clone)]
pub enum Environment {
    Development,
    Testing,
    Production,
}

impl Environment {
    pub fn from_env() -> Self {
        match std::env::var("SUBX_ENVIRONMENT").as_deref() {
            Ok("development") | Ok("dev") => Environment::Development,
            Ok("testing") | Ok("test") => Environment::Testing,
            Ok("production") | Ok("prod") => Environment::Production,
            _ => Environment::Production, // 預設為生產環境
        }
    }
    
    pub fn config_file_name(&self) -> &str {
        match self {
            Environment::Development => "config.development.toml",
            Environment::Testing => "config.testing.toml", 
            Environment::Production => "config.toml",
        }
    }
}

impl ProductionConfigService {
    pub fn with_environment(env: Environment) -> Result<Self> {
        let config_builder = config::Config::builder()
            .add_source(config::File::with_name("config/default").required(false))
            .add_source(config::File::with_name(&format!("config/{}", env.config_file_name())).required(false))
            .add_source(config::Environment::with_prefix("SUBX").separator("_"));
            
        Ok(Self {
            config_builder,
            cached_config: Arc::new(RwLock::new(None)),
        })
    }
}
```

## 模組結構更新

### 更新模組結構
```rust
// src/config/mod.rs
pub mod service;
pub mod test_service;
pub mod builder;
pub mod test_macros;
pub mod environment;

// 重新匯出核心類型
pub use service::{ConfigService, ProductionConfigService};
pub use test_service::TestConfigService;
pub use builder::TestConfigBuilder;
pub use environment::Environment;

// 保留原有匯出以維持相容性
pub use crate::config::{Config, AIConfig, SyncConfig, FormatsConfig, GeneralConfig, ParallelConfig};

// 測試相關匯出
#[cfg(test)]
pub use test_macros::*;
```

## 驗證測試

### 配置服務功能測試
```rust
// tests/config_service_tests.rs
use subx_cli::config::{ConfigService, ProductionConfigService, TestConfigService, TestConfigBuilder};

#[test]
fn test_production_config_service_basic() {
    let service = ProductionConfigService::new().unwrap();
    let config = service.get_config().unwrap();
    
    // 驗證預設值
    assert_eq!(config.ai.provider, "openai");
    assert_eq!(config.ai.model, "gpt-4o-mini");
}

#[test]
fn test_config_service_reload() {
    let service = ProductionConfigService::new().unwrap();
    
    // 第一次載入
    let config1 = service.get_config().unwrap();
    
    // 重新載入
    service.reload().unwrap();
    let config2 = service.get_config().unwrap();
    
    // 配置應該一致（除非檔案已更改）
    assert_eq!(config1.ai.provider, config2.ai.provider);
}

#[test]
fn test_test_config_service() {
    let service = TestConfigService::with_ai_settings("anthropic", "claude-3");
    let config = service.get_config().unwrap();
    
    assert_eq!(config.ai.provider, "anthropic");
    assert_eq!(config.ai.model, "claude-3");
}

#[test]
fn test_config_builder_fluent_api() {
    let config = TestConfigBuilder::new()
        .with_ai_provider("openai")
        .with_ai_model("gpt-4")
        .with_max_sample_length(5000)
        .with_sync_threshold(0.7)
        .build_config();
    
    assert_eq!(config.ai.provider, "openai");
    assert_eq!(config.ai.model, "gpt-4");
    assert_eq!(config.ai.max_sample_length, 5000);
    assert_eq!(config.sync.correlation_threshold, 0.7);
}
```

### 依賴注入測試
```rust
// tests/dependency_injection_tests.rs
use subx_cli::{App, config::TestConfigService};

#[test]
fn test_app_with_test_config() {
    let config_service = std::sync::Arc::new(
        TestConfigService::with_ai_settings("test_provider", "test_model")
    );
    
    let app = App::new(config_service.clone());
    let retrieved_service = app.config_service();
    
    let config = retrieved_service.get_config().unwrap();
    assert_eq!(config.ai.provider, "test_provider");
    assert_eq!(config.ai.model, "test_model");
}
```

## 驗證標準

### 功能驗證
- [ ] ProductionConfigService 正常載入配置
- [ ] TestConfigService 提供隔離的測試配置
- [ ] TestConfigBuilder 流暢 API 正常工作
- [ ] 配置快取機制正常運作
- [ ] 配置重載功能正常
- [ ] 依賴注入機制正常運作

### 架構驗證
- [ ] 配置服務介面設計合理
- [ ] 生產和測試環境完全隔離
- [ ] 應用程式進入點正確重構
- [ ] 模組結構清晰明確

### 測試驗證
- [ ] 測試輔助巨集正常工作
- [ ] 所有新增的功能測試通過
- [ ] 配置建構器測試覆蓋完整

## 下一步行動

完成此配置服務系統實作後，將進入：
- [Backlog #21.4: 測試系統重構](21.4-test-system-refactoring.md)

## 相關檔案

### 新建檔案
- `src/config/service.rs` - 配置服務介面和實作
- `src/config/test_service.rs` - 測試配置服務
- `src/config/builder.rs` - 配置建構器
- `src/config/test_macros.rs` - 測試輔助巨集
- `src/config/environment.rs` - 環境特定配置

### 需要修改的檔案
- `src/main.rs` - 應用程式進入點重構
- `src/lib.rs` - 應用程式結構定義
- `src/cli/mod.rs` - CLI 處理邏輯更新
- `src/config/mod.rs` - 模組匯出更新
