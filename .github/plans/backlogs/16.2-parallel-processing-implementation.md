# Product Backlog #16.2: 平行處理系統實作

## 領域範圍
多檔案並行處理、資源管理、任務調度、效能最佳化

## 背景描述

**更新日期**: 2025-06-08  
**架構狀況**: 基於統一配置管理系統 (Backlog #14 已完成)  
**前置條件**: 統一配置管理系統、現有命令系統架構

隨著 SubX 功能的擴展，使用者經常需要批次處理大量檔案，如同時轉換多個字幕格式、批次匹配字幕與影片檔案、或並行執行同步操作。當前的單執行緒處理模式在面對大量檔案時效率低下，且無法充分利用多核心系統的性能優勢。

實作平行處理系統可以顯著提升批次操作的效率，同時提供良好的資源管理和任務監控能力。

## 功能概述

### 平行處理系統 (Parallel Processing System)
**相關配置**: `general.max_concurrent_jobs`  
**目標模組**: `src/core/parallel/` (新增目錄)

#### 核心功能描述
- **多檔案並行處理**: 同時處理多個字幕或影片檔案
- **智慧資源管理**: 根據系統資源和配置限制工作負載
- **任務佇列管理**: 高效的任務排程和優先級處理
- **進度追蹤**: 即時監控任務進度和狀態
- **錯誤隔離**: 單一任務失敗不影響其他並行任務
- **統一配置整合**: 透過 `load_config()` 載入並行處理參數

#### 技術需求與挑戰
- **任務調度器**: 高效的任務分配和執行管理
- **工作者執行緒池**: 可擴展的執行緒池管理
- **狀態管理**: 複雜的任務狀態追蹤和同步
- **資源限制**: CPU、記憶體和 I/O 資源的平衡使用

## 詳細實作計劃

### 階段 1: 任務調度器建立 (預估工時: 10 小時)

#### 1.1 建立平行處理系統架構
```rust
// src/core/parallel/mod.rs
pub mod scheduler;
pub mod worker;
pub mod task;
pub mod pool;

pub use scheduler::TaskScheduler;
pub use worker::{Worker, WorkerPool};
pub use task::{Task, TaskResult, TaskStatus};
```

**架構設計重點**:
- **模組化設計**: 清晰分離調度、執行和任務定義
- **可擴展性**: 支援未來新增不同類型的任務
- **統一介面**: 為不同命令提供一致的並行處理介面

#### 1.2 實作任務調度器核心
```rust
// src/core/parallel/scheduler.rs
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;
use tokio::sync::{mpsc, oneshot, Semaphore};
use crate::config::load_config;
use crate::Result;

pub struct TaskScheduler {
    task_queue: Arc<Mutex<VecDeque<PendingTask>>>,
    worker_pool: WorkerPool,
    semaphore: Arc<Semaphore>,
    max_concurrent: usize,
    active_tasks: Arc<Mutex<std::collections::HashMap<String, TaskInfo>>>,
}

struct PendingTask {
    task: Box<dyn Task + Send + Sync>,
    result_sender: oneshot::Sender<TaskResult>,
    task_id: String,
    priority: TaskPriority,
}

#[derive(Debug, Clone)]
pub struct TaskInfo {
    pub task_id: String,
    pub task_type: String,
    pub status: TaskStatus,
    pub start_time: std::time::Instant,
    pub progress: f32,
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum TaskPriority {
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3,
}

impl TaskScheduler {
    pub fn new() -> Result<Self> {
        let config = load_config()?;
        let max_concurrent_jobs = config.general.max_concurrent_jobs as usize;
        
        let worker_pool = WorkerPool::new(max_concurrent_jobs);
        let semaphore = Arc::new(Semaphore::new(max_concurrent_jobs));
        
        Ok(Self {
            task_queue: Arc::new(Mutex::new(VecDeque::new())),
            worker_pool,
            semaphore,
            max_concurrent: max_concurrent_jobs,
            active_tasks: Arc::new(Mutex::new(std::collections::HashMap::new())),
        })
    }
    
    pub async fn submit_task(&self, task: Box<dyn Task + Send + Sync>) -> Result<TaskResult> {
        self.submit_task_with_priority(task, TaskPriority::Normal).await
    }
    
    pub async fn submit_task_with_priority(
        &self, 
        task: Box<dyn Task + Send + Sync>,
        priority: TaskPriority
    ) -> Result<TaskResult> {
        let task_id = task.task_id();
        let task_type = task.task_type().to_string();
        let (tx, rx) = oneshot::channel();
        
        // 註冊任務資訊
        {
            let mut active_tasks = self.active_tasks.lock().unwrap();
            active_tasks.insert(task_id.clone(), TaskInfo {
                task_id: task_id.clone(),
                task_type,
                status: TaskStatus::Pending,
                start_time: std::time::Instant::now(),
                progress: 0.0,
            });
        }
        
        // 提交任務到佇列
        {
            let mut queue = self.task_queue.lock().unwrap();
            let pending_task = PendingTask {
                task,
                result_sender: tx,
                task_id: task_id.clone(),
                priority,
            };
            
            // 按優先級插入佇列
            let insert_position = queue.iter().position(|t| t.priority < priority)
                .unwrap_or(queue.len());
            queue.insert(insert_position, pending_task);
        }
        
        // 嘗試執行任務
        self.try_execute_next_task().await;
        
        // 等待任務完成
        let result = rx.await.map_err(|_| {
            crate::error::SubXError::parallel_processing("任務執行被中斷".to_string())
        })?;
        
        // 清理任務資訊
        {
            let mut active_tasks = self.active_tasks.lock().unwrap();
            active_tasks.remove(&task_id);
        }
        
        Ok(result)
    }
    
    async fn try_execute_next_task(&self) {
        // 嘗試取得執行許可
        if let Ok(permit) = self.semaphore.try_acquire() {
            // 從佇列取得下一個任務
            let pending_task = {
                let mut queue = self.task_queue.lock().unwrap();
                queue.pop_front()
            };
            
            if let Some(pending_task) = pending_task {
                // 更新任務狀態
                {
                    let mut active_tasks = self.active_tasks.lock().unwrap();
                    if let Some(task_info) = active_tasks.get_mut(&pending_task.task_id) {
                        task_info.status = TaskStatus::Running;
                    }
                }
                
                // 提交到工作者池執行
                let task_id = pending_task.task_id.clone();
                let active_tasks = Arc::clone(&self.active_tasks);
                
                tokio::spawn(async move {
                    let result = pending_task.task.execute().await;
                    
                    // 更新任務狀態
                    {
                        let mut active_tasks = active_tasks.lock().unwrap();
                        if let Some(task_info) = active_tasks.get_mut(&task_id) {
                            task_info.status = TaskStatus::Completed(result.clone());
                            task_info.progress = 1.0;
                        }
                    }
                    
                    // 發送結果
                    let _ = pending_task.result_sender.send(result);
                    
                    // 釋放許可
                    drop(permit);
                });
            } else {
                // 沒有待執行任務，釋放許可
                drop(permit);
            }
        }
    }
    
    pub async fn submit_batch_tasks(&self, tasks: Vec<Box<dyn Task + Send + Sync>>) -> Vec<TaskResult> {
        let mut handles = Vec::new();
        
        for task in tasks {
            let handle = tokio::spawn({
                let scheduler = self.clone();
                async move {
                    scheduler.submit_task(task).await
                }
            });
            handles.push(handle);
        }
        
        // 等待所有任務完成
        let mut results = Vec::new();
        for handle in handles {
            match handle.await {
                Ok(Ok(result)) => results.push(result),
                Ok(Err(_)) => results.push(TaskResult::Failed("任務執行失敗".to_string())),
                Err(_) => results.push(TaskResult::Cancelled),
            }
        }
        
        results
    }
    
    pub fn get_queue_size(&self) -> usize {
        self.task_queue.lock().unwrap().len()
    }
    
    pub fn get_active_workers(&self) -> usize {
        self.max_concurrent - self.semaphore.available_permits()
    }
    
    pub fn get_task_status(&self, task_id: &str) -> Option<TaskInfo> {
        let active_tasks = self.active_tasks.lock().unwrap();
        active_tasks.get(task_id).cloned()
    }
    
    pub fn list_active_tasks(&self) -> Vec<TaskInfo> {
        let active_tasks = self.active_tasks.lock().unwrap();
        active_tasks.values().cloned().collect()
    }
}

impl Clone for TaskScheduler {
    fn clone(&self) -> Self {
        Self {
            task_queue: Arc::clone(&self.task_queue),
            worker_pool: self.worker_pool.clone(),
            semaphore: Arc::clone(&self.semaphore),
            max_concurrent: self.max_concurrent,
            active_tasks: Arc::clone(&self.active_tasks),
        }
    }
}
```

#### 1.3 定義任務介面和類型
```rust
// src/core/parallel/task.rs
use async_trait::async_trait;
use std::fmt;

#[async_trait]
pub trait Task: Send + Sync {
    async fn execute(&self) -> TaskResult;
    fn task_type(&self) -> &'static str;
    fn task_id(&self) -> String;
    fn estimated_duration(&self) -> Option<std::time::Duration> {
        None
    }
    fn description(&self) -> String {
        format!("{} 任務", self.task_type())
    }
}

#[derive(Debug, Clone)]
pub enum TaskResult {
    Success(String),
    Failed(String),
    Cancelled,
    PartialSuccess(String, String), // (成功訊息, 警告訊息)
}

#[derive(Debug, Clone)]
pub enum TaskStatus {
    Pending,
    Running,
    Completed(TaskResult),
    Failed(String),
    Cancelled,
}

impl fmt::Display for TaskResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TaskResult::Success(msg) => write!(f, "✓ {}", msg),
            TaskResult::Failed(msg) => write!(f, "✗ {}", msg),
            TaskResult::Cancelled => write!(f, "⚠ 任務被取消"),
            TaskResult::PartialSuccess(success, warning) => {
                write!(f, "⚠ {} (警告: {})", success, warning)
            }
        }
    }
}

impl fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TaskStatus::Pending => write!(f, "等待中"),
            TaskStatus::Running => write!(f, "執行中"),
            TaskStatus::Completed(result) => write!(f, "已完成: {}", result),
            TaskStatus::Failed(msg) => write!(f, "失敗: {}", msg),
            TaskStatus::Cancelled => write!(f, "已取消"),
        }
    }
}

// 具體任務實作範例
pub struct FileProcessingTask {
    pub input_path: std::path::PathBuf,
    pub output_path: Option<std::path::PathBuf>,
    pub operation: ProcessingOperation,
}

#[derive(Debug, Clone)]
pub enum ProcessingOperation {
    ConvertFormat { from: String, to: String },
    SyncSubtitle { audio_path: std::path::PathBuf },
    MatchFiles { recursive: bool },
    ValidateFormat,
}

#[async_trait]
impl Task for FileProcessingTask {
    async fn execute(&self) -> TaskResult {
        use crate::commands;
        
        match &self.operation {
            ProcessingOperation::ConvertFormat { from, to } => {
                // 實作格式轉換邏輯
                match self.convert_format(from, to).await {
                    Ok(output_path) => TaskResult::Success(
                        format!("成功轉換 {} -> {}: {}", 
                            from, to, output_path.display())
                    ),
                    Err(e) => TaskResult::Failed(
                        format!("轉換失敗 {}: {}", self.input_path.display(), e)
                    ),
                }
            }
            ProcessingOperation::SyncSubtitle { audio_path } => {
                // 實作字幕同步邏輯
                match self.sync_subtitle(audio_path).await {
                    Ok(sync_result) => TaskResult::Success(
                        format!("字幕同步完成: {} (偏移: {:.2}s)", 
                            self.input_path.display(), sync_result.offset)
                    ),
                    Err(e) => TaskResult::Failed(
                        format!("同步失敗 {}: {}", self.input_path.display(), e)
                    ),
                }
            }
            ProcessingOperation::MatchFiles { recursive } => {
                // 實作檔案匹配邏輯
                match self.match_files(*recursive).await {
                    Ok(matches) => TaskResult::Success(
                        format!("檔案匹配完成: 找到 {} 組匹配", matches.len())
                    ),
                    Err(e) => TaskResult::Failed(
                        format!("匹配失敗: {}", e)
                    ),
                }
            }
            ProcessingOperation::ValidateFormat => {
                // 實作格式驗證邏輯
                match self.validate_format().await {
                    Ok(true) => TaskResult::Success(
                        format!("格式驗證通過: {}", self.input_path.display())
                    ),
                    Ok(false) => TaskResult::Failed(
                        format!("格式驗證失敗: {}", self.input_path.display())
                    ),
                    Err(e) => TaskResult::Failed(
                        format!("驗證錯誤: {}", e)
                    ),
                }
            }
        }
    }
    
    fn task_type(&self) -> &'static str {
        match &self.operation {
            ProcessingOperation::ConvertFormat { .. } => "convert",
            ProcessingOperation::SyncSubtitle { .. } => "sync",
            ProcessingOperation::MatchFiles { .. } => "match",
            ProcessingOperation::ValidateFormat => "validate",
        }
    }
    
    fn task_id(&self) -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        self.input_path.hash(&mut hasher);
        self.operation.hash(&mut hasher);
        
        format!("{}_{:x}", self.task_type(), hasher.finish())
    }
    
    fn estimated_duration(&self) -> Option<std::time::Duration> {
        // 根據檔案大小和操作類型估算執行時間
        if let Ok(metadata) = std::fs::metadata(&self.input_path) {
            let file_size_mb = metadata.len() as f64 / 1_048_576.0;
            
            let base_seconds = match &self.operation {
                ProcessingOperation::ConvertFormat { .. } => file_size_mb * 0.1,
                ProcessingOperation::SyncSubtitle { .. } => file_size_mb * 0.5,
                ProcessingOperation::MatchFiles { .. } => 2.0,
                ProcessingOperation::ValidateFormat => file_size_mb * 0.05,
            };
            
            Some(std::time::Duration::from_secs_f64(base_seconds))
        } else {
            None
        }
    }
    
    fn description(&self) -> String {
        match &self.operation {
            ProcessingOperation::ConvertFormat { from, to } => {
                format!("轉換 {} 從 {} 到 {}", self.input_path.display(), from, to)
            }
            ProcessingOperation::SyncSubtitle { audio_path } => {
                format!("同步字幕 {} 與音訊 {}", 
                    self.input_path.display(), audio_path.display())
            }
            ProcessingOperation::MatchFiles { recursive } => {
                format!("匹配 {} 中的檔案{}", 
                    self.input_path.display(), 
                    if *recursive { " (遞歸)" } else { "" })
            }
            ProcessingOperation::ValidateFormat => {
                format!("驗證 {} 的格式", self.input_path.display())
            }
        }
    }
}

impl FileProcessingTask {
    async fn convert_format(&self, from: &str, to: &str) -> crate::Result<std::path::PathBuf> {
        // 實作格式轉換邏輯（與現有 convert 命令整合）
        use crate::commands::convert_command;
        
        let output_path = self.output_path.clone().unwrap_or_else(|| {
            self.input_path.with_extension(to)
        });
        
        convert_command::execute_convert(
            &self.input_path,
            &output_path,
            Some(to)
        ).await?;
        
        Ok(output_path)
    }
    
    async fn sync_subtitle(&self, audio_path: &std::path::Path) -> crate::Result<SyncResult> {
        // 實作字幕同步邏輯（與現有 sync 命令整合）
        use crate::core::sync::SyncEngine;
        
        let sync_engine = SyncEngine::new()?;
        sync_engine.sync_files(&self.input_path, audio_path).await
    }
    
    async fn match_files(&self, recursive: bool) -> crate::Result<Vec<FileMatch>> {
        // 實作檔案匹配邏輯（與現有 match 命令整合）
        use crate::commands::match_command;
        
        match_command::execute_match(&self.input_path, recursive, self.output_path.as_deref()).await
    }
    
    async fn validate_format(&self) -> crate::Result<bool> {
        // 實作格式驗證邏輯
        use crate::core::formats::FormatManager;
        
        let format_manager = FormatManager::new()?;
        let content = tokio::fs::read_to_string(&self.input_path).await?;
        
        match format_manager.parse_auto(&content) {
            Ok(_) => Ok(true),
            Err(_) => Ok(false),
        }
    }
}

// 為 ProcessingOperation 實作 Hash trait（用於 task_id 生成）
impl std::hash::Hash for ProcessingOperation {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        match self {
            ProcessingOperation::ConvertFormat { from, to } => {
                "convert".hash(state);
                from.hash(state);
                to.hash(state);
            }
            ProcessingOperation::SyncSubtitle { audio_path } => {
                "sync".hash(state);
                audio_path.hash(state);
            }
            ProcessingOperation::MatchFiles { recursive } => {
                "match".hash(state);
                recursive.hash(state);
            }
            ProcessingOperation::ValidateFormat => {
                "validate".hash(state);
            }
        }
    }
}
```

### 階段 2: 工作者池實作 (預估工時: 8 小時)

#### 2.1 實作工作者池管理
```rust
// src/core/parallel/worker.rs
use tokio::task::JoinHandle;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use uuid::Uuid;

pub struct WorkerPool {
    workers: Arc<Mutex<HashMap<Uuid, WorkerInfo>>>,
    max_workers: usize,
}

#[derive(Debug)]
struct WorkerInfo {
    handle: JoinHandle<TaskResult>,
    task_id: String,
    start_time: std::time::Instant,
    worker_type: WorkerType,
}

#[derive(Debug, Clone)]
pub enum WorkerType {
    CpuIntensive,    // CPU 密集型任務
    IoIntensive,     // I/O 密集型任務
    Mixed,           // 混合型任務
}

impl WorkerPool {
    pub fn new(max_workers: usize) -> Self {
        Self {
            workers: Arc::new(Mutex::new(HashMap::new())),
            max_workers,
        }
    }
    
    pub async fn execute(&self, task: Box<dyn Task + Send + Sync>) -> Result<TaskResult, String> {
        let worker_id = Uuid::new_v4();
        let task_id = task.task_id();
        let worker_type = self.determine_worker_type(task.task_type());
        
        // 檢查是否有可用的工作者槽位
        {
            let workers = self.workers.lock().unwrap();
            if workers.len() >= self.max_workers {
                return Err("工作者池已滿".to_string());
            }
        }
        
        let handle = tokio::spawn(async move {
            let result = task.execute().await;
            result
        });
        
        // 註冊工作者資訊
        {
            let mut workers = self.workers.lock().unwrap();
            workers.insert(worker_id, WorkerInfo {
                handle,
                task_id: task_id.clone(),
                start_time: std::time::Instant::now(),
                worker_type,
            });
        }
        
        // 等待任務完成
        let result = {
            let workers = self.workers.lock().unwrap();
            if let Some(worker_info) = workers.get(&worker_id) {
                // 這裡需要複製 handle，但 JoinHandle 不能複製
                // 實際實作中需要更複雜的處理
                TaskResult::Success("任務已提交".to_string())
            } else {
                TaskResult::Failed("工作者未找到".to_string())
            }
        };
        
        // 清理工作者
        {
            let mut workers = self.workers.lock().unwrap();
            workers.remove(&worker_id);
        }
        
        Ok(result)
    }
    
    fn determine_worker_type(&self, task_type: &str) -> WorkerType {
        match task_type {
            "convert" => WorkerType::CpuIntensive,
            "sync" => WorkerType::Mixed,
            "match" => WorkerType::IoIntensive,
            "validate" => WorkerType::IoIntensive,
            _ => WorkerType::Mixed,
        }
    }
    
    pub fn get_active_count(&self) -> usize {
        self.workers.lock().unwrap().len()
    }
    
    pub fn get_capacity(&self) -> usize {
        self.max_workers
    }
    
    pub fn get_worker_stats(&self) -> WorkerStats {
        let workers = self.workers.lock().unwrap();
        let mut cpu_intensive_count = 0;
        let mut io_intensive_count = 0;
        let mut mixed_count = 0;
        
        for worker in workers.values() {
            match worker.worker_type {
                WorkerType::CpuIntensive => cpu_intensive_count += 1,
                WorkerType::IoIntensive => io_intensive_count += 1,
                WorkerType::Mixed => mixed_count += 1,
            }
        }
        
        WorkerStats {
            total_active: workers.len(),
            cpu_intensive_count,
            io_intensive_count,
            mixed_count,
            max_capacity: self.max_workers,
        }
    }
    
    pub async fn shutdown(&self) {
        let workers = {
            let mut workers_guard = self.workers.lock().unwrap();
            std::mem::take(&mut *workers_guard)
        };
        
        // 等待所有工作者完成
        for (worker_id, worker_info) in workers {
            println!("正在等待工作者 {} 完成任務 {}", worker_id, worker_info.task_id);
            let _ = worker_info.handle.await;
        }
    }
    
    pub fn list_active_workers(&self) -> Vec<ActiveWorkerInfo> {
        let workers = self.workers.lock().unwrap();
        workers.iter().map(|(id, info)| {
            ActiveWorkerInfo {
                worker_id: *id,
                task_id: info.task_id.clone(),
                worker_type: info.worker_type.clone(),
                runtime: info.start_time.elapsed(),
            }
        }).collect()
    }
}

impl Clone for WorkerPool {
    fn clone(&self) -> Self {
        Self {
            workers: Arc::clone(&self.workers),
            max_workers: self.max_workers,
        }
    }
}

#[derive(Debug, Clone)]
pub struct WorkerStats {
    pub total_active: usize,
    pub cpu_intensive_count: usize,
    pub io_intensive_count: usize,
    pub mixed_count: usize,
    pub max_capacity: usize,
}

#[derive(Debug, Clone)]
pub struct ActiveWorkerInfo {
    pub worker_id: Uuid,
    pub task_id: String,
    pub worker_type: WorkerType,
    pub runtime: std::time::Duration,
}

pub struct Worker {
    id: Uuid,
    status: WorkerStatus,
}

#[derive(Debug, Clone)]
pub enum WorkerStatus {
    Idle,
    Busy(String), // 任務ID
    Stopped,
    Error(String),
}

impl Worker {
    pub fn new() -> Self {
        Self {
            id: Uuid::new_v4(),
            status: WorkerStatus::Idle,
        }
    }
    
    pub fn id(&self) -> Uuid {
        self.id
    }
    
    pub fn status(&self) -> &WorkerStatus {
        &self.status
    }
    
    pub fn set_status(&mut self, status: WorkerStatus) {
        self.status = status;
    }
}
```

#### 2.2 整合到命令系統
```rust
// 修改現有命令檔案，例如 src/commands/match_command.rs
use crate::core::parallel::{TaskScheduler, FileProcessingTask, ProcessingOperation};

pub async fn execute_parallel_match(
    directory: &Path, 
    recursive: bool,
    output: Option<&Path>
) -> Result<()> {
    // 初始化配置和任務調度器
    crate::config::init_config_manager()?;
    let scheduler = TaskScheduler::new()?;
    
    // 發現需要處理的檔案
    let discovery = crate::core::file_manager::FileDiscovery::new();
    let files = discovery.scan_directory(directory, recursive)?;
    
    // 建立批次任務
    let mut tasks: Vec<Box<dyn Task + Send + Sync>> = Vec::new();
    
    for video_file in files.iter().filter(|f| matches!(f.file_type, MediaFileType::Video)) {
        let task = Box::new(FileProcessingTask {
            input_path: video_file.path.clone(),
            output_path: output.map(|p| p.to_path_buf()),
            operation: ProcessingOperation::MatchFiles { recursive },
        });
        tasks.push(task);
    }
    
    if tasks.is_empty() {
        println!("未找到需要處理的影片檔案");
        return Ok(());
    }
    
    // 顯示處理計劃
    println!("準備並行處理 {} 個檔案", tasks.len());
    println!("最大並行數: {}", scheduler.get_active_workers());
    
    // 顯示進度條初始化
    let progress_bar = create_progress_bar(tasks.len());
    
    // 提交批次任務並監控進度
    let results = monitor_batch_execution(&scheduler, tasks, &progress_bar).await?;
    
    // 處理結果統計
    let mut success_count = 0;
    let mut failed_count = 0;
    let mut partial_success_count = 0;
    
    for result in &results {
        match result {
            TaskResult::Success(_) => success_count += 1,
            TaskResult::Failed(_) => failed_count += 1,
            TaskResult::PartialSuccess(_, _) => partial_success_count += 1,
            TaskResult::Cancelled => failed_count += 1,
        }
    }
    
    // 顯示詳細結果
    println!("\n處理完成統計:");
    println!("  ✓ 成功: {} 個檔案", success_count);
    if partial_success_count > 0 {
        println!("  ⚠ 部分成功: {} 個檔案", partial_success_count);
    }
    if failed_count > 0 {
        println!("  ✗ 失敗: {} 個檔案", failed_count);
    }
    
    // 顯示失敗詳情
    for (i, result) in results.iter().enumerate() {
        if matches!(result, TaskResult::Failed(_)) {
            println!("  失敗詳情 {}: {}", i + 1, result);
        }
    }
    
    Ok(())
}

async fn monitor_batch_execution(
    scheduler: &TaskScheduler,
    tasks: Vec<Box<dyn Task + Send + Sync>>,
    progress_bar: &ProgressBar
) -> Result<Vec<TaskResult>> {
    use tokio::time::{interval, Duration};
    
    // 提交所有任務
    let task_handles: Vec<_> = tasks.into_iter().map(|task| {
        let scheduler = scheduler.clone();
        tokio::spawn(async move {
            scheduler.submit_task(task).await
        })
    }).collect();
    
    // 監控進度
    let mut monitor_interval = interval(Duration::from_millis(500));
    let mut completed_count = 0;
    let total_tasks = task_handles.len();
    
    // 等待所有任務完成並更新進度
    let mut results = Vec::new();
    for handle in task_handles {
        // 更新進度顯示
        loop {
            tokio::select! {
                // 檢查任務是否完成
                task_result = &mut handle => {
                    match task_result {
                        Ok(Ok(result)) => {
                            results.push(result);
                            completed_count += 1;
                            progress_bar.set_position(completed_count);
                            break;
                        }
                        Ok(Err(_)) => {
                            results.push(TaskResult::Failed("任務執行錯誤".to_string()));
                            completed_count += 1;
                            progress_bar.set_position(completed_count);
                            break;
                        }
                        Err(_) => {
                            results.push(TaskResult::Cancelled);
                            completed_count += 1;
                            progress_bar.set_position(completed_count);
                            break;
                        }
                    }
                }
                // 定期更新進度資訊
                _ = monitor_interval.tick() => {
                    let active_tasks = scheduler.list_active_tasks();
                    let queue_size = scheduler.get_queue_size();
                    
                    progress_bar.set_message(format!(
                        "執行中: {} | 佇列: {} | 已完成: {}/{}",
                        active_tasks.len(),
                        queue_size,
                        completed_count,
                        total_tasks
                    ));
                }
            }
        }
    }
    
    progress_bar.finish_with_message("所有任務已完成");
    Ok(results)
}

fn create_progress_bar(total: usize) -> ProgressBar {
    use indicatif::{ProgressBar, ProgressStyle};
    
    let pb = ProgressBar::new(total as u64);
    pb.set_style(
        ProgressStyle::default_bar()
            .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} {msg}")
            .unwrap()
            .progress_chars("#>-")
    );
    pb
}
```

## 配置項目規範

### 統一配置系統整合
平行處理系統必須完整整合到統一配置系統中：

```toml
# config.toml 新增配置項目
[general]
max_concurrent_jobs = 4                   # 最大並行任務數
task_timeout_seconds = 3600               # 任務超時時間（秒）
enable_progress_bar = true                # 是否顯示進度條
worker_idle_timeout_seconds = 300         # 工作者空閒超時時間

[parallel]
cpu_intensive_limit = 2                   # CPU 密集型任務限制
io_intensive_limit = 8                    # I/O 密集型任務限制
task_queue_size = 100                     # 任務佇列大小限制
enable_task_priorities = true             # 是否啟用任務優先級
auto_balance_workers = true               # 是否自動平衡工作者負載
```

### 配置載入標準
```rust
// 正確的配置載入方式
use crate::config::load_config;

let config = load_config()?;
let max_jobs = config.general.max_concurrent_jobs;
let timeout = config.general.task_timeout_seconds;
let enable_priorities = config.parallel.enable_task_priorities;
```

## 測試策略

### 單元測試規範
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;
    
    #[tokio::test]
    async fn test_task_scheduler_basic() {
        let scheduler = TaskScheduler::new().unwrap();
        
        // 測試基本任務提交
        let task = Box::new(MockTask::new("test_task", Duration::from_millis(100)));
        let result = scheduler.submit_task(task).await.unwrap();
        
        assert!(matches!(result, TaskResult::Success(_)));
    }
    
    #[tokio::test]
    async fn test_concurrent_task_execution() {
        let scheduler = TaskScheduler::new().unwrap();
        let counter = Arc::new(AtomicUsize::new(0));
        
        // 提交多個並行任務
        let mut handles = Vec::new();
        for i in 0..10 {
            let task = Box::new(CounterTask::new(Arc::clone(&counter)));
            let handle = tokio::spawn({
                let scheduler = scheduler.clone();
                async move {
                    scheduler.submit_task(task).await
                }
            });
            handles.push(handle);
        }
        
        // 等待所有任務完成
        for handle in handles {
            let result = handle.await.unwrap().unwrap();
            assert!(matches!(result, TaskResult::Success(_)));
        }
        
        // 驗證所有任務都執行了
        assert_eq!(counter.load(Ordering::SeqCst), 10);
    }
    
    #[tokio::test]
    async fn test_task_priority_ordering() {
        let scheduler = TaskScheduler::new().unwrap();
        let execution_order = Arc::new(Mutex::new(Vec::new()));
        
        // 提交不同優先級的任務
        let tasks = vec![
            (TaskPriority::Low, "low"),
            (TaskPriority::High, "high"),
            (TaskPriority::Normal, "normal"),
            (TaskPriority::Critical, "critical"),
        ];
        
        let mut handles = Vec::new();
        for (priority, name) in tasks {
            let task = Box::new(OrderTask::new(name, Arc::clone(&execution_order)));
            let handle = tokio::spawn({
                let scheduler = scheduler.clone();
                async move {
                    scheduler.submit_task_with_priority(task, priority).await
                }
            });
            handles.push(handle);
        }
        
        // 等待所有任務完成
        for handle in handles {
            handle.await.unwrap().unwrap();
        }
        
        // 驗證執行順序符合優先級
        let order = execution_order.lock().unwrap();
        assert_eq!(order[0], "critical");
        assert_eq!(order[1], "high");
    }
    
    #[tokio::test]
    async fn test_worker_pool_capacity() {
        let pool = WorkerPool::new(2);
        
        assert_eq!(pool.get_capacity(), 2);
        assert_eq!(pool.get_active_count(), 0);
        
        // 測試工作者統計
        let stats = pool.get_worker_stats();
        assert_eq!(stats.max_capacity, 2);
        assert_eq!(stats.total_active, 0);
    }
    
    #[tokio::test]
    async fn test_file_processing_task() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.srt");
        
        // 創建測試字幕檔案
        tokio::fs::write(&test_file, "1\n00:00:01,000 --> 00:00:02,000\nTest subtitle\n").await.unwrap();
        
        let task = FileProcessingTask {
            input_path: test_file,
            output_path: None,
            operation: ProcessingOperation::ValidateFormat,
        };
        
        let result = task.execute().await;
        assert!(matches!(result, TaskResult::Success(_)));
    }
    
    // 模擬任務實作
    struct MockTask {
        name: String,
        duration: Duration,
    }
    
    impl MockTask {
        fn new(name: &str, duration: Duration) -> Self {
            Self {
                name: name.to_string(),
                duration,
            }
        }
    }
    
    #[async_trait]
    impl Task for MockTask {
        async fn execute(&self) -> TaskResult {
            tokio::time::sleep(self.duration).await;
            TaskResult::Success(format!("完成任務: {}", self.name))
        }
        
        fn task_type(&self) -> &'static str {
            "mock"
        }
        
        fn task_id(&self) -> String {
            format!("mock_{}", self.name)
        }
    }
    
    struct CounterTask {
        counter: Arc<AtomicUsize>,
    }
    
    impl CounterTask {
        fn new(counter: Arc<AtomicUsize>) -> Self {
            Self { counter }
        }
    }
    
    #[async_trait]
    impl Task for CounterTask {
        async fn execute(&self) -> TaskResult {
            self.counter.fetch_add(1, Ordering::SeqCst);
            TaskResult::Success("計數任務完成".to_string())
        }
        
        fn task_type(&self) -> &'static str {
            "counter"
        }
        
        fn task_id(&self) -> String {
            format!("counter_{}", uuid::Uuid::new_v4())
        }
    }
    
    struct OrderTask {
        name: String,
        execution_order: Arc<Mutex<Vec<String>>>,
    }
    
    impl OrderTask {
        fn new(name: &str, execution_order: Arc<Mutex<Vec<String>>>) -> Self {
            Self {
                name: name.to_string(),
                execution_order,
            }
        }
    }
    
    #[async_trait]
    impl Task for OrderTask {
        async fn execute(&self) -> TaskResult {
            let mut order = self.execution_order.lock().unwrap();
            order.push(self.name.clone());
            TaskResult::Success(format!("順序任務完成: {}", self.name))
        }
        
        fn task_type(&self) -> &'static str {
            "order"
        }
        
        fn task_id(&self) -> String {
            format!("order_{}", self.name)
        }
    }
}
```

### 整合測試計劃
```rust
// tests/parallel_processing_integration_tests.rs
use subx_cli::core::parallel::{TaskScheduler, FileProcessingTask, ProcessingOperation};
use tempfile::TempDir;

#[tokio::test]
async fn test_batch_file_processing() {
    // 建立測試環境
    let temp_dir = TempDir::new().unwrap();
    
    // 創建多個測試檔案
    let test_files = vec!["test1.srt", "test2.srt", "test3.srt"];
    for file_name in &test_files {
        let file_path = temp_dir.path().join(file_name);
        tokio::fs::write(&file_path, "1\n00:00:01,000 --> 00:00:02,000\nTest\n").await.unwrap();
    }
    
    // 初始化任務調度器
    let scheduler = TaskScheduler::new().unwrap();
    
    // 創建批次任務
    let mut tasks = Vec::new();
    for file_name in &test_files {
        let file_path = temp_dir.path().join(file_name);
        let task = Box::new(FileProcessingTask {
            input_path: file_path,
            output_path: None,
            operation: ProcessingOperation::ValidateFormat,
        });
        tasks.push(task);
    }
    
    // 執行批次處理
    let results = scheduler.submit_batch_tasks(tasks).await;
    
    // 驗證結果
    assert_eq!(results.len(), test_files.len());
    for result in results {
        assert!(matches!(result, TaskResult::Success(_)));
    }
}

#[tokio::test]
async fn test_parallel_command_integration() {
    // 測試與現有命令系統的整合
    let temp_dir = TempDir::new().unwrap();
    
    // 創建測試檔案結構
    create_test_directory_structure(&temp_dir).await;
    
    // 測試並行匹配命令
    let result = subx_cli::commands::match_command::execute_parallel_match(
        temp_dir.path(),
        true,
        None
    ).await;
    
    assert!(result.is_ok());
}

async fn create_test_directory_structure(temp_dir: &TempDir) {
    // 創建測試目錄結構和檔案
    let video_dir = temp_dir.path().join("videos");
    let subtitle_dir = temp_dir.path().join("subtitles");
    
    tokio::fs::create_dir_all(&video_dir).await.unwrap();
    tokio::fs::create_dir_all(&subtitle_dir).await.unwrap();
    
    // 創建測試影片和字幕檔案
    // ...
}
```

## 品質標準

### 可靠性要求
- **任務隔離**: 單一任務失敗不影響其他任務
- **資源清理**: 任務完成後正確釋放所有資源
- **異常恢復**: 系統能夠從工作者崩潰中恢復
- **資料一致性**: 並行操作不產生資料競爭

### 程式碼品質檢查
```bash
# 開發過程中必須通過的檢查
cargo fmt
cargo clippy -- -D warnings
cargo test

# 並行安全性檢查
cargo test --release -- --test-threads=1
```

### 錯誤處理標準
```rust
// 在 src/error.rs 中新增平行處理相關錯誤
impl SubXError {
    pub fn parallel_processing(msg: String) -> Self {
        Self::CommandExecution(format!("並行處理錯誤: {}", msg))
    }
    
    pub fn task_execution_failed(task_id: String, reason: String) -> Self {
        Self::CommandExecution(format!("任務 {} 執行失敗: {}", task_id, reason))
    }
    
    pub fn worker_pool_exhausted() -> Self {
        Self::CommandExecution("工作者池資源已耗盡".to_string())
    }
    
    pub fn task_timeout(task_id: String, duration: std::time::Duration) -> Self {
        Self::CommandExecution(format!(
            "任務 {} 執行超時，限制時間: {:?}", 
            task_id, 
            duration
        ))
    }
}
```

## 驗收標準

### 功能驗收
1. **基本並行處理**: 能夠同時執行多個檔案處理任務
2. **任務優先級**: 高優先級任務優先執行
3. **進度監控**: 提供即時的任務進度和狀態資訊
4. **資源限制**: 遵守配置的並行數限制
5. **錯誤處理**: 單一任務失敗不影響其他任務

### 技術驗收
1. **架構設計**: 清晰的模組分離和責任劃分
2. **API 一致性**: 與現有命令系統無縫整合
3. **設定整合**: 完整整合到統一配置系統
4. **測試覆蓋**: 單元測試和整合測試覆蓋率 > 80%

### 使用者體驗驗收
1. **操作簡便**: 現有命令自動支援並行處理
2. **進度可視**: 清楚顯示處理進度和剩餘時間
3. **錯誤報告**: 詳細的錯誤訊息和處理建議
4. **效能提升**: 批次處理速度顯著提升

## 實作檢查清單

### 開發前準備
- [ ] 確認統一配置系統 (Backlog #14) 已完成並正常運作
- [ ] 檢查現有命令系統架構和 API
- [ ] 準備不同規模的測試資料集
- [ ] 確認 tokio 和 async/await 使用最佳實踐

### 階段 1: 核心架構實作
- [ ] 建立 `src/core/parallel/` 模組結構
- [ ] 實作 `TaskScheduler` 任務調度器
- [ ] 定義 `Task` trait 和相關類型
- [ ] 實作 `FileProcessingTask` 具體任務類型
- [ ] 編寫基礎單元測試

### 階段 2: 工作者池實作
- [ ] 實作 `WorkerPool` 工作者池管理
- [ ] 實作工作者類型分類和負載平衡
- [ ] 實作任務狀態監控和統計
- [ ] 編寫工作者池測試

### 階段 3: 命令系統整合
- [ ] 修改現有命令以支援並行處理
- [ ] 實作進度監控和使用者介面
- [ ] 整合統一配置系統
- [ ] 編寫整合測試

### 階段 4: 最佳化與驗證
- [ ] 效能調校和記憶體最佳化
- [ ] 實作任務超時和錯誤恢復
- [ ] 完整測試套件驗證

### 最終驗證
- [ ] 與現有功能完整整合測試
- [ ] 多種負載情境的壓力測試
- [ ] 程式碼品質檢查通過
- [ ] 使用者驗收測試通過
