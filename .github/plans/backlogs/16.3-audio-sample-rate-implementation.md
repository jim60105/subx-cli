# Product Backlog #16.3: 音訊採樣率動態配置實作

## 領域範圍
音訊重採樣、採樣率檢測與轉換、音訊品質最佳化

## 背景描述

**更新日期**: 2025-06-08  
**架構狀況**: 基於統一配置管理系統 (Backlog #14 已完成)  
**前置條件**: 統一配置管理系統、基礎音訊同步引擎

隨著 SubX 音訊同步功能的擴展，發現不同來源的音訊檔案具有不同的採樣率（如 22kHz、44.1kHz、48kHz 等），當前的固定採樣率處理方式無法有效處理這種多樣性。不同採樣率會影響同步精度，且可能導致音訊品質下降或處理效率低下。

實作動態音訊採樣率配置功能，可以自動檢測音訊檔案的採樣率，並根據需要進行智慧重採樣，提升音訊處理的靈活性和準確性。

## 功能概述

### 音訊採樣率動態配置 (Dynamic Audio Sample Rate)
**相關配置**: `sync.audio_sample_rate`  
**目標模組**: `src/services/audio/resampler.rs` (新增)

#### 核心功能描述
- **自動採樣率檢測**: 識別音訊檔案的原始採樣率
- **智慧重採樣**: 根據配置和需求自動轉換採樣率
- **品質最佳化**: 選擇最適合的採樣率以平衡品質和效能
- **多格式支援**: 支援各種音訊格式的採樣率處理
- **統一配置整合**: 透過 `load_config()` 載入重採樣參數

#### 技術需求與挑戰
- **重採樣演算法**: 高品質的音訊重採樣實作
- **採樣率檢測**: 精確識別音訊檔案的採樣頻率
- **品質評估**: 評估重採樣對音訊品質的影響
- **效能最佳化**: 在品質和處理速度間取得平衡

## 詳細實作計劃

### 階段 1: 採樣率檢測與分析基礎 (預估工時: 10 小時)

#### 1.1 建立重採樣系統架構
```rust
// src/services/audio/resampler.rs
pub mod detector;
pub mod converter;
pub mod quality;
pub mod optimizer;

pub use detector::SampleRateDetector;
pub use converter::{AudioResampler, ResampleConfig};
pub use quality::{QualityAssessor, ResampleQuality};
pub use optimizer::SampleRateOptimizer;
```

**架構設計重點**:
- **模組化設計**: 清晰分離檢測、轉換和品質評估
- **可擴展性**: 支援未來新增重採樣演算法
- **統一介面**: 為不同音訊服務提供一致的重採樣介面

#### 1.2 實作採樣率檢測器
```rust
// src/services/audio/resampler/detector.rs
use std::path::Path;
use crate::services::audio::{AudioData, AudioMetadata};
use crate::Result;

pub struct SampleRateDetector {
    supported_rates: Vec<u32>,
    auto_detect_enabled: bool,
}

impl SampleRateDetector {
    pub fn new() -> Self {
        Self {
            supported_rates: vec![
                8000, 11025, 16000, 22050, 24000,
                32000, 44100, 48000, 88200, 96000, 192000
            ],
            auto_detect_enabled: true,
        }
    }

    /// 檢測音訊檔案的採樣率
    pub async fn detect_sample_rate<P: AsRef<Path>>(&self, audio_path: P) -> Result<u32> {
        // 實作音訊檔案採樣率檢測
        // 1. 讀取音訊檔案標頭資訊
        // 2. 解析採樣率元資料
        // 3. 驗證採樣率有效性
        // 4. 返回檢測結果
        todo!("實作採樣率檢測")
    }

    /// 檢測音訊資料的採樣率
    pub fn detect_from_data(&self, audio_data: &AudioData) -> Result<u32> {
        // 從音訊資料中檢測採樣率
        // 1. 分析音訊頻譜特徵
        // 2. 計算可能的採樣率
        // 3. 驗證檢測結果
        todo!("從音訊資料檢測採樣率")
    }

    /// 驗證採樣率是否受支援
    pub fn is_supported_rate(&self, sample_rate: u32) -> bool {
        self.supported_rates.contains(&sample_rate)
    }

    /// 取得建議的採樣率
    pub fn get_recommended_rate(&self, source_rate: u32, target_use: AudioUseCase) -> u32 {
        match target_use {
            AudioUseCase::SpeechRecognition => self.optimize_for_speech(source_rate),
            AudioUseCase::MusicAnalysis => self.optimize_for_music(source_rate),
            AudioUseCase::SyncMatching => self.optimize_for_sync(source_rate),
        }
    }

    fn optimize_for_speech(&self, source_rate: u32) -> u32 {
        // 語音處理最佳化：通常 16kHz 已足夠
        match source_rate {
            rate if rate <= 16000 => rate,
            _ => 16000,
        }
    }

    fn optimize_for_music(&self, source_rate: u32) -> u32 {
        // 音樂分析最佳化：保持較高品質
        match source_rate {
            rate if rate >= 44100 => rate,
            _ => 44100,
        }
    }

    fn optimize_for_sync(&self, source_rate: u32) -> u32 {
        // 同步匹配最佳化：平衡精度和效能
        match source_rate {
            rate if rate <= 22050 => 22050,
            rate if rate <= 44100 => 44100,
            _ => 48000,
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum AudioUseCase {
    SpeechRecognition,
    MusicAnalysis,
    SyncMatching,
}
```

#### 1.3 定義重採樣配置結構
```rust
// src/services/audio/resampler/converter.rs
use crate::config::{load_config, SyncConfig};
use crate::services::audio::{AudioData, AudioFormat};
use crate::Result;

#[derive(Debug, Clone)]
pub struct ResampleConfig {
    pub target_sample_rate: u32,
    pub quality: ResampleQuality,
    pub preserve_duration: bool,
    pub anti_aliasing: bool,
    pub normalize_volume: bool,
}

impl ResampleConfig {
    pub fn new(target_rate: u32) -> Self {
        Self {
            target_sample_rate: target_rate,
            quality: ResampleQuality::High,
            preserve_duration: true,
            anti_aliasing: true,
            normalize_volume: false,
        }
    }

    pub fn from_config() -> Result<Self> {
        let config = load_config()?;
        Ok(Self {
            target_sample_rate: config.sync.audio_sample_rate,
            quality: ResampleQuality::from_string(&config.sync.resample_quality)?,
            preserve_duration: true,
            anti_aliasing: true,
            normalize_volume: false,
        })
    }

    pub fn for_speech() -> Self {
        Self {
            target_sample_rate: 16000,
            quality: ResampleQuality::Medium,
            preserve_duration: true,
            anti_aliasing: true,
            normalize_volume: true,
        }
    }

    pub fn for_sync() -> Self {
        Self {
            target_sample_rate: 22050,
            quality: ResampleQuality::High,
            preserve_duration: true,
            anti_aliasing: true,
            normalize_volume: false,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ResampleQuality {
    Low,      // 快速但品質較低
    Medium,   // 平衡品質和速度
    High,     // 高品質但較慢
    Best,     // 最佳品質但最慢
}

impl ResampleQuality {
    pub fn from_string(s: &str) -> Result<Self> {
        match s.to_lowercase().as_str() {
            "low" | "fast" => Ok(Self::Low),
            "medium" | "normal" => Ok(Self::Medium),
            "high" => Ok(Self::High),
            "best" | "highest" => Ok(Self::Best),
            _ => Err(crate::error::SubXError::Config(
                format!("無效的重採樣品質設定: {}", s)
            )),
        }
    }

    pub fn to_ratio_precision(&self) -> f64 {
        match self {
            Self::Low => 0.85,
            Self::Medium => 0.92,
            Self::High => 0.97,
            Self::Best => 0.99,
        }
    }
}
```

### 階段 2: 音訊重採樣器實作 (預估工時: 14 小時)

#### 2.1 實作核心重採樣器
```rust
// src/services/audio/resampler/converter.rs (續)
use std::collections::VecDeque;

pub struct AudioResampler {
    config: ResampleConfig,
    interpolator: Box<dyn Interpolator>,
    buffer: VecDeque<f32>,
}

impl AudioResampler {
    pub fn new(config: ResampleConfig) -> Result<Self> {
        let interpolator = Self::create_interpolator(&config)?;
        
        Ok(Self {
            config,
            interpolator,
            buffer: VecDeque::new(),
        })
    }

    /// 重採樣音訊資料
    pub fn resample(&mut self, input: &AudioData, target_rate: u32) -> Result<AudioData> {
        if input.sample_rate == target_rate {
            return Ok(input.clone());
        }

        let ratio = target_rate as f64 / input.sample_rate as f64;
        let output_length = (input.samples.len() as f64 * ratio) as usize;
        
        let resampled_samples = self.interpolator.interpolate(
            &input.samples,
            ratio,
            output_length,
        )?;

        Ok(AudioData {
            samples: resampled_samples,
            sample_rate: target_rate,
            channels: input.channels,
            duration: input.duration, // 持續時間不變
        })
    }

    /// 批次重採樣多個音訊檔案
    pub async fn resample_batch(&mut self, files: Vec<AudioData>, target_rate: u32) -> Result<Vec<AudioData>> {
        let mut results = Vec::with_capacity(files.len());
        
        for audio_data in files {
            let resampled = self.resample(&audio_data, target_rate)?;
            results.push(resampled);
        }
        
        Ok(results)
    }

    fn create_interpolator(config: &ResampleConfig) -> Result<Box<dyn Interpolator>> {
        match config.quality {
            ResampleQuality::Low => Ok(Box::new(LinearInterpolator::new())),
            ResampleQuality::Medium => Ok(Box::new(CubicInterpolator::new())),
            ResampleQuality::High => Ok(Box::new(SincInterpolator::new(8))),
            ResampleQuality::Best => Ok(Box::new(SincInterpolator::new(16))),
        }
    }
}

/// 插值器特質定義
trait Interpolator: Send + Sync {
    fn interpolate(&self, input: &[f32], ratio: f64, output_length: usize) -> Result<Vec<f32>>;
}

/// 線性插值器（快速但品質較低）
struct LinearInterpolator;

impl LinearInterpolator {
    fn new() -> Self {
        Self
    }
}

impl Interpolator for LinearInterpolator {
    fn interpolate(&self, input: &[f32], ratio: f64, output_length: usize) -> Result<Vec<f32>> {
        let mut output = Vec::with_capacity(output_length);
        
        for i in 0..output_length {
            let src_index = i as f64 / ratio;
            let index = src_index as usize;
            let fraction = src_index - index as f64;
            
            if index + 1 < input.len() {
                let sample = input[index] * (1.0 - fraction as f32) + 
                            input[index + 1] * fraction as f32;
                output.push(sample);
            } else if index < input.len() {
                output.push(input[index]);
            } else {
                output.push(0.0);
            }
        }
        
        Ok(output)
    }
}

/// 三次插值器（中等品質和速度）
struct CubicInterpolator;

impl CubicInterpolator {
    fn new() -> Self {
        Self
    }
    
    fn cubic_interpolate(&self, y0: f32, y1: f32, y2: f32, y3: f32, mu: f32) -> f32 {
        let a0 = y3 - y2 - y0 + y1;
        let a1 = y0 - y1 - a0;
        let a2 = y2 - y0;
        let a3 = y1;
        
        a0 * mu * mu * mu + a1 * mu * mu + a2 * mu + a3
    }
}

impl Interpolator for CubicInterpolator {
    fn interpolate(&self, input: &[f32], ratio: f64, output_length: usize) -> Result<Vec<f32>> {
        let mut output = Vec::with_capacity(output_length);
        
        for i in 0..output_length {
            let src_index = i as f64 / ratio;
            let index = src_index as usize;
            let fraction = (src_index - index as f64) as f32;
            
            if index >= 1 && index + 2 < input.len() {
                let sample = self.cubic_interpolate(
                    input[index - 1],
                    input[index],
                    input[index + 1],
                    input[index + 2],
                    fraction,
                );
                output.push(sample);
            } else if index < input.len() {
                // 邊界情況使用線性插值
                if index + 1 < input.len() {
                    let sample = input[index] * (1.0 - fraction) + 
                                input[index + 1] * fraction;
                    output.push(sample);
                } else {
                    output.push(input[index]);
                }
            } else {
                output.push(0.0);
            }
        }
        
        Ok(output)
    }
}

/// Sinc 插值器（最高品質）
struct SincInterpolator {
    kernel_size: usize,
}

impl SincInterpolator {
    fn new(kernel_size: usize) -> Self {
        Self { kernel_size }
    }
    
    fn sinc(&self, x: f64) -> f64 {
        if x.abs() < 1e-9 {
            1.0
        } else {
            let pi_x = std::f64::consts::PI * x;
            pi_x.sin() / pi_x
        }
    }
    
    fn windowed_sinc(&self, x: f64) -> f64 {
        if x.abs() >= self.kernel_size as f64 {
            0.0
        } else {
            // 使用 Blackman 視窗
            let window = 0.42 - 0.5 * (std::f64::consts::PI * x / self.kernel_size as f64).cos()
                        + 0.08 * (2.0 * std::f64::consts::PI * x / self.kernel_size as f64).cos();
            self.sinc(x) * window
        }
    }
}

impl Interpolator for SincInterpolator {
    fn interpolate(&self, input: &[f32], ratio: f64, output_length: usize) -> Result<Vec<f32>> {
        let mut output = Vec::with_capacity(output_length);
        
        for i in 0..output_length {
            let src_index = i as f64 / ratio;
            let center = src_index as isize;
            let mut sample = 0.0f64;
            
            for j in -self.kernel_size as isize..=self.kernel_size as isize {
                let input_idx = center + j;
                if input_idx >= 0 && input_idx < input.len() as isize {
                    let weight = self.windowed_sinc(src_index - input_idx as f64);
                    sample += input[input_idx as usize] as f64 * weight;
                }
            }
            
            output.push(sample as f32);
        }
        
        Ok(output)
    }
}
```

#### 2.2 實作品質評估器
```rust
// src/services/audio/resampler/quality.rs
use crate::services::audio::AudioData;
use crate::Result;

pub struct QualityAssessor {
    metrics: Vec<QualityMetric>,
}

impl QualityAssessor {
    pub fn new() -> Self {
        Self {
            metrics: vec![
                QualityMetric::SignalToNoiseRatio,
                QualityMetric::FrequencyResponse,
                QualityMetric::DynamicRange,
            ],
        }
    }

    /// 評估重採樣品質
    pub fn assess_quality(&self, original: &AudioData, resampled: &AudioData) -> Result<QualityReport> {
        let mut report = QualityReport::new();
        
        for metric in &self.metrics {
            let score = self.calculate_metric_score(metric, original, resampled)?;
            report.add_metric_score(metric.clone(), score);
        }
        
        report.calculate_overall_score();
        Ok(report)
    }

    fn calculate_metric_score(&self, metric: &QualityMetric, original: &AudioData, resampled: &AudioData) -> Result<f32> {
        match metric {
            QualityMetric::SignalToNoiseRatio => self.calculate_snr(original, resampled),
            QualityMetric::FrequencyResponse => self.calculate_frequency_response(original, resampled),
            QualityMetric::DynamicRange => self.calculate_dynamic_range(original, resampled),
        }
    }

    fn calculate_snr(&self, original: &AudioData, resampled: &AudioData) -> Result<f32> {
        // 計算信噪比
        // 1. 將重採樣音訊調整到與原始音訊相同長度
        // 2. 計算信號功率和噪音功率
        // 3. 返回 SNR 分數 (0.0-1.0)
        todo!("實作 SNR 計算")
    }

    fn calculate_frequency_response(&self, original: &AudioData, resampled: &AudioData) -> Result<f32> {
        // 計算頻率響應相似度
        // 1. 對原始和重採樣音訊進行 FFT
        // 2. 比較頻譜特徵
        // 3. 返回相似度分數 (0.0-1.0)
        todo!("實作頻率響應計算")
    }

    fn calculate_dynamic_range(&self, original: &AudioData, resampled: &AudioData) -> Result<f32> {
        // 計算動態範圍保持度
        // 1. 分析原始音訊的動態範圍
        // 2. 分析重採樣音訊的動態範圍
        // 3. 返回保持度分數 (0.0-1.0)
        todo!("實作動態範圍計算")
    }
}

#[derive(Debug, Clone)]
pub enum QualityMetric {
    SignalToNoiseRatio,    // 信噪比
    FrequencyResponse,     // 頻率響應
    DynamicRange,          // 動態範圍
}

#[derive(Debug, Clone)]
pub struct QualityReport {
    pub overall_score: f32,
    pub metric_scores: std::collections::HashMap<String, f32>,
    pub recommendations: Vec<String>,
}

impl QualityReport {
    pub fn new() -> Self {
        Self {
            overall_score: 0.0,
            metric_scores: std::collections::HashMap::new(),
            recommendations: Vec::new(),
        }
    }

    pub fn add_metric_score(&mut self, metric: QualityMetric, score: f32) {
        let metric_name = format!("{:?}", metric);
        self.metric_scores.insert(metric_name, score);
    }

    pub fn calculate_overall_score(&mut self) {
        if self.metric_scores.is_empty() {
            self.overall_score = 0.0;
            return;
        }

        let total: f32 = self.metric_scores.values().sum();
        self.overall_score = total / self.metric_scores.len() as f32;
        
        self.generate_recommendations();
    }

    fn generate_recommendations(&mut self) {
        self.recommendations.clear();
        
        if self.overall_score < 0.7 {
            self.recommendations.push("建議提高重採樣品質設定".to_string());
        }
        
        if let Some(&snr_score) = self.metric_scores.get("SignalToNoiseRatio") {
            if snr_score < 0.6 {
                self.recommendations.push("檢測到較高的噪音，建議使用較高品質的重採樣演算法".to_string());
            }
        }
        
        if let Some(&freq_score) = self.metric_scores.get("FrequencyResponse") {
            if freq_score < 0.8 {
                self.recommendations.push("頻率響應失真較大，建議使用 Sinc 插值器".to_string());
            }
        }
    }
}
```

### 階段 3: 採樣率最佳化器與整合 (預估工時: 8 小時)

#### 3.1 實作採樣率最佳化器
```rust
// src/services/audio/resampler/optimizer.rs
use crate::config::{load_config, SyncConfig};
use crate::services::audio::{AudioData, AudioMetadata};
use crate::core::sync::dialogue::DialogueDetector;
use super::{SampleRateDetector, AudioUseCase, ResampleConfig, QualityAssessor};
use crate::Result;

pub struct SampleRateOptimizer {
    detector: SampleRateDetector,
    quality_assessor: QualityAssessor,
    config: SyncConfig,
}

impl SampleRateOptimizer {
    pub fn new() -> Result<Self> {
        let config = load_config()?.sync;
        
        Ok(Self {
            detector: SampleRateDetector::new(),
            quality_assessor: QualityAssessor::new(),
            config,
        })
    }

    /// 為特定用途最佳化採樣率
    pub async fn optimize_for_use_case(&self, audio_data: &AudioData, use_case: AudioUseCase) -> Result<OptimizationResult> {
        let current_rate = audio_data.sample_rate;
        let recommended_rate = self.detector.get_recommended_rate(current_rate, use_case);
        
        let optimization = if current_rate != recommended_rate {
            Some(OptimizationSuggestion {
                current_rate,
                recommended_rate,
                reason: self.explain_optimization(current_rate, recommended_rate, use_case),
                expected_quality_change: self.estimate_quality_change(current_rate, recommended_rate),
                processing_time_estimate: self.estimate_processing_time(audio_data, recommended_rate),
            })
        } else {
            None
        };

        Ok(OptimizationResult {
            is_optimal: optimization.is_none(),
            current_sample_rate: current_rate,
            optimization,
            analysis: self.analyze_audio_characteristics(audio_data)?,
        })
    }

    /// 自動選擇最佳採樣率
    pub async fn auto_optimize(&self, audio_data: &AudioData) -> Result<AutoOptimizationResult> {
        let analysis = self.analyze_audio_characteristics(audio_data)?;
        let use_case = self.infer_use_case(&analysis);
        let optimization = self.optimize_for_use_case(audio_data, use_case).await?;
        
        Ok(AutoOptimizationResult {
            inferred_use_case: use_case,
            optimization_result: optimization,
            confidence: analysis.content_confidence,
        })
    }

    fn analyze_audio_characteristics(&self, audio_data: &AudioData) -> Result<AudioAnalysis> {
        // 分析音訊特徵以推斷最佳用途
        let spectral_centroid = self.calculate_spectral_centroid(&audio_data.samples)?;
        let zero_crossing_rate = self.calculate_zero_crossing_rate(&audio_data.samples)?;
        let energy_variance = self.calculate_energy_variance(&audio_data.samples)?;
        
        let content_type = if spectral_centroid < 2000.0 && zero_crossing_rate < 0.1 {
            AudioContentType::Speech
        } else if energy_variance > 0.5 {
            AudioContentType::Music
        } else {
            AudioContentType::Mixed
        };

        Ok(AudioAnalysis {
            content_type,
            spectral_centroid,
            zero_crossing_rate,
            energy_variance,
            content_confidence: self.calculate_confidence(spectral_centroid, zero_crossing_rate, energy_variance),
        })
    }

    fn infer_use_case(&self, analysis: &AudioAnalysis) -> AudioUseCase {
        match analysis.content_type {
            AudioContentType::Speech => AudioUseCase::SpeechRecognition,
            AudioContentType::Music => AudioUseCase::MusicAnalysis,
            AudioContentType::Mixed => AudioUseCase::SyncMatching,
        }
    }

    fn explain_optimization(&self, current: u32, recommended: u32, use_case: AudioUseCase) -> String {
        let use_case_str = match use_case {
            AudioUseCase::SpeechRecognition => "語音處理",
            AudioUseCase::MusicAnalysis => "音樂分析",
            AudioUseCase::SyncMatching => "同步匹配",
        };

        if recommended < current {
            format!("針對{}最佳化，降低採樣率可提升處理效率且不影響品質", use_case_str)
        } else {
            format!("針對{}最佳化，提高採樣率可改善分析精度", use_case_str)
        }
    }

    fn estimate_quality_change(&self, current: u32, recommended: u32) -> QualityChangeEstimate {
        let ratio = recommended as f32 / current as f32;
        
        if ratio > 1.0 {
            QualityChangeEstimate::Improved(((ratio - 1.0) * 100.0).min(25.0))
        } else if ratio < 0.8 {
            QualityChangeEstimate::Degraded(((1.0 - ratio) * 50.0).min(15.0))
        } else {
            QualityChangeEstimate::Neutral
        }
    }

    fn estimate_processing_time(&self, audio_data: &AudioData, target_rate: u32) -> std::time::Duration {
        let complexity_factor = match target_rate.cmp(&audio_data.sample_rate) {
            std::cmp::Ordering::Greater => 1.5, // 上採樣較複雜
            std::cmp::Ordering::Less => 1.2,    // 下採樣較簡單
            std::cmp::Ordering::Equal => 0.1,   // 無需處理
        };

        let base_time_ms = (audio_data.duration * 100.0 * complexity_factor) as u64;
        std::time::Duration::from_millis(base_time_ms)
    }

    // 音訊特徵計算方法
    fn calculate_spectral_centroid(&self, samples: &[f32]) -> Result<f32> {
        // 實作頻譜質心計算
        todo!("計算頻譜質心")
    }

    fn calculate_zero_crossing_rate(&self, samples: &[f32]) -> Result<f32> {
        let mut crossings = 0;
        for window in samples.windows(2) {
            if (window[0] >= 0.0) != (window[1] >= 0.0) {
                crossings += 1;
            }
        }
        Ok(crossings as f32 / samples.len() as f32)
    }

    fn calculate_energy_variance(&self, samples: &[f32]) -> Result<f32> {
        let window_size = 1024;
        let mut energies = Vec::new();
        
        for chunk in samples.chunks(window_size) {
            let energy: f32 = chunk.iter().map(|x| x * x).sum();
            energies.push(energy / chunk.len() as f32);
        }
        
        if energies.len() < 2 {
            return Ok(0.0);
        }
        
        let mean: f32 = energies.iter().sum::<f32>() / energies.len() as f32;
        let variance: f32 = energies.iter()
            .map(|x| (x - mean) * (x - mean))
            .sum::<f32>() / energies.len() as f32;
        
        Ok(variance.sqrt())
    }

    fn calculate_confidence(&self, spectral_centroid: f32, zero_crossing_rate: f32, energy_variance: f32) -> f32 {
        // 基於特徵計算內容類型判斷的信心度
        let features = vec![spectral_centroid / 5000.0, zero_crossing_rate * 10.0, energy_variance];
        let consistency = features.iter().map(|&x| (x - 0.5).abs()).sum::<f32>() / features.len() as f32;
        (1.0 - consistency).max(0.0).min(1.0)
    }
}

#[derive(Debug, Clone)]
pub struct OptimizationResult {
    pub is_optimal: bool,
    pub current_sample_rate: u32,
    pub optimization: Option<OptimizationSuggestion>,
    pub analysis: AudioAnalysis,
}

#[derive(Debug, Clone)]
pub struct OptimizationSuggestion {
    pub current_rate: u32,
    pub recommended_rate: u32,
    pub reason: String,
    pub expected_quality_change: QualityChangeEstimate,
    pub processing_time_estimate: std::time::Duration,
}

#[derive(Debug, Clone)]
pub struct AutoOptimizationResult {
    pub inferred_use_case: AudioUseCase,
    pub optimization_result: OptimizationResult,
    pub confidence: f32,
}

#[derive(Debug, Clone)]
pub struct AudioAnalysis {
    pub content_type: AudioContentType,
    pub spectral_centroid: f32,
    pub zero_crossing_rate: f32,
    pub energy_variance: f32,
    pub content_confidence: f32,
}

#[derive(Debug, Clone, Copy)]
pub enum AudioContentType {
    Speech,
    Music,
    Mixed,
}

#[derive(Debug, Clone)]
pub enum QualityChangeEstimate {
    Improved(f32),    // 改善百分比
    Degraded(f32),    // 下降百分比
    Neutral,          // 無顯著變化
}
```

#### 3.2 整合到現有音訊服務
```rust
// 修改 src/services/audio/mod.rs
pub mod analyzer;
pub mod extractor;
pub mod resampler; // 新增重採樣模組

pub use analyzer::AudioAnalyzer;
pub use extractor::AudioExtractor;
pub use resampler::{
    AudioResampler, SampleRateDetector, SampleRateOptimizer,
    ResampleConfig, ResampleQuality, OptimizationResult
};

// 為現有音訊服務添加重採樣功能
impl AudioAnalyzer {
    /// 使用最佳採樣率分析音訊
    pub async fn analyze_with_optimal_rate<P: AsRef<std::path::Path>>(&mut self, audio_path: P) -> crate::Result<crate::services::audio::AudioData> {
        // 1. 載入音訊檔案
        let audio_data = self.load_audio_file(audio_path).await?;
        
        // 2. 最佳化採樣率
        let optimizer = SampleRateOptimizer::new()?;
        let optimization = optimizer.auto_optimize(&audio_data).await?;
        
        // 3. 如果需要重採樣，執行重採樣
        if let Some(suggestion) = optimization.optimization_result.optimization {
            let config = ResampleConfig::new(suggestion.recommended_rate);
            let mut resampler = AudioResampler::new(config)?;
            resampler.resample(&audio_data, suggestion.recommended_rate)
        } else {
            Ok(audio_data)
        }
    }
}
```

#### 3.3 更新配置系統以支援重採樣設定
```rust
// 修改 src/config/source.rs 中的 SyncConfig
impl SyncConfig {
    // ...existing code...
    
    pub fn resample_quality(&self) -> String {
        self.resample_quality.clone().unwrap_or_else(|| "high".to_string())
    }
    
    pub fn auto_detect_sample_rate(&self) -> bool {
        self.auto_detect_sample_rate.unwrap_or(true)
    }
    
    pub fn enable_smart_resampling(&self) -> bool {
        self.enable_smart_resampling.unwrap_or(true)
    }
}
```

## 測試策略

### 單元測試
- 採樣率檢測準確性測試
- 重採樣演算法品質驗證
- 品質評估指標正確性測試
- 最佳化建議邏輯驗證

### 整合測試
- 與現有音訊服務的整合
- 多種音訊格式支援測試
- 配置系統整合驗證

## 完成指標

### 功能完整性
- ✅ 自動採樣率檢測功能正常運作
- ✅ 多種重採樣演算法可選擇使用
- ✅ 品質評估和最佳化建議準確
- ✅ 統一配置系統完整整合

### 品質標準
- ✅ 重採樣品質達到業界標準
- ✅ 錯誤處理和邊界情況完善
- ✅ 程式碼品質通過 Clippy 檢查

### 文件與測試
- ✅ API 文件完整且準確
- ✅ 測試覆蓋率達到 80% 以上
- ✅ 使用者指南包含重採樣功能說明

## 相關文件與資源

- [音訊重採樣理論](https://en.wikipedia.org/wiki/Sample-rate_conversion)
- [數位信號處理基礎](https://en.wikipedia.org/wiki/Digital_signal_processing)
- [Rust 音訊處理 Crate 參考](https://crates.io/categories/multimedia::audio)
- [統一配置管理系統 (Backlog #14)](./14-unified-config-management.md)
- [平行處理系統 (Backlog #16.2)](./16.2-parallel-processing-implementation.md)
